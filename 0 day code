import uuid
import random
import time
import json
from collections import defaultdict
import math

class SymbolicOrganism:
def **init**(self, content, domain, parent=None, generation=0):
self.id = str(uuid.uuid4())[:8]
self.content = content
self.domain = domain
self.parent = parent
self.children = []
self.generation = generation
self.birth_time = time.time()

```
    # Advanced traits
    self.energy = 100
    self.age = 0
    self.mutations = 0
    self.reproduction_count = 0
    self.predation_resistance = random.uniform(0.1, 0.9)
    self.adaptive_pressure = random.uniform(0.1, 1.0)
    
    # Calculate fitness
    self.fitness = self.calculate_fitness()
    self.species = self.determine_species()
    
def calculate_fitness(self):
    """Advanced fitness calculation based on multiple factors"""
    # Symbolic complexity
    tokens = set(self.content.lower().split())
    complexity_score = len(tokens)
    
    # Domain specialization bonus
    domain_bonus = len(self.domain) * 0.5
    
    # Generation advantage (older lineages are more stable)
    generation_bonus = min(self.generation * 0.1, 2.0)
    
    # Energy efficiency
    energy_factor = self.energy / 100.0
    
    # Resistance to environmental pressure
    survival_factor = self.predation_resistance * self.adaptive_pressure
    
    return (complexity_score + domain_bonus + generation_bonus) * energy_factor * survival_factor

def determine_species(self):
    """Classify organism into species based on characteristics"""
    if self.fitness > 15:
        return "Apex_Reasoner"
    elif self.fitness > 10:
        return "Adaptive_Logician" 
    elif self.fitness > 7:
        return "Survivor_Clause"
    elif self.generation > 5:
        return "Ancient_Wisdom"
    elif "⊕" in self.content or "⊖" in self.content:
        return "Hybrid_Mutant"
    else:
        return "Basic_Symbolic"

def detect_contradiction(self, other):
    """Enhanced contradiction detection with domain awareness"""
    same_domain = self.domain == other.domain
    content_conflict = self.content.lower() != other.content.lower()
    
    # Check for logical negations
    negation_patterns = ["not", "no", "never", "false", "impossible"]
    self_has_neg = any(neg in self.content.lower() for neg in negation_patterns)
    other_has_neg = any(neg in other.content.lower() for neg in negation_patterns)
    
    logical_opposition = self_has_neg != other_has_neg
    
    return same_domain and (content_conflict or logical_opposition)

def sexual_reproduction(self, mate):
    """Advanced sexual reproduction creating diverse offspring"""
    if not self.detect_contradiction(mate):
        return []
        
    # Energy cost for reproduction
    self.energy -= 20
    mate.energy -= 20
    
    if self.energy < 10 or mate.energy < 10:
        return []  # Too weak to reproduce
        
    # Create multiple offspring with different strategies
    offspring = []
    
    # Synthesis offspring (combining traits)
    synthesis = SymbolicOrganism(
        f"({self.content}) ⊕ ({mate.content})",
        f"{self.domain}-{mate.domain}",
        parent=self,
        generation=max(self.generation, mate.generation) + 1
    )
    
    # Antithesis offspring (opposing traits)
    antithesis = SymbolicOrganism(
        f"({mate.content}) ⊖ ({self.content})",
        f"{mate.domain}-{self.domain}",
        parent=mate,
        generation=max(self.generation, mate.generation) + 1
    )
    
    # Mutation offspring (random variation)
    mutation_content = self.mutate_content()
    mutant = SymbolicOrganism(
        mutation_content,
        self.domain,
        parent=self,
        generation=self.generation + 1
    )
    mutant.mutations += 1
    
    offspring = [synthesis, antithesis, mutant]
    
    # Update parent records
    self.children.extend(offspring)
    mate.children.extend(offspring)
    self.reproduction_count += 1
    mate.reproduction_count += 1
    
    return offspring

def mutate_content(self):
    """Create random mutations in content"""
    mutations = [
        lambda x: x + " [EVOLVED]",
        lambda x: x.replace("is", "might be"),
        lambda x: x.replace("always", "sometimes"),
        lambda x: x.replace("never", "rarely"),
        lambda x: f"Meta-{x}",
        lambda x: f"{x} under quantum conditions",
        lambda x: f"Recursive {x}",
    ]
    
    mutation = random.choice(mutations)
    return mutation(self.content)

def asexual_reproduction(self):
    """Cloning for high-fitness organisms"""
    if self.fitness < 8 or self.energy < 30:
        return None
        
    self.energy -= 25
    
    clone = SymbolicOrganism(
        self.content + f" [Clone-{self.reproduction_count}]",
        self.domain,
        parent=self,
        generation=self.generation + 1
    )
    
    # Slight variation in clone
    clone.adaptive_pressure = min(1.0, self.adaptive_pressure + random.uniform(-0.1, 0.1))
    
    self.children.append(clone)
    self.reproduction_count += 1
    
    return clone

def age_organism(self):
    """Aging process affecting fitness and survival"""
    self.age += 1
    
    # Energy loss with age
    age_penalty = self.age * 0.5
    self.energy = max(0, self.energy - age_penalty)
    
    # Fitness degradation
    if self.age > 10:
        self.fitness *= 0.95  # 5% fitness loss per age cycle after 10

def predation_event(self, predator):
    """Survival challenge from predator organisms"""
    survival_chance = self.predation_resistance + (self.fitness * 0.05)
    predator_strength = predator.fitness * 0.1
    
    if random.random() < (survival_chance - predator_strength):
        # Survived - gain resistance
        self.predation_resistance = min(1.0, self.predation_resistance + 0.05)
        self.energy += 10  # Survival bonus
        return True
    else:
        # Killed
        self.energy = 0
        return False

def trace_lineage(self):
    """Complete evolutionary lineage"""
    lineage = []
    node = self
    while node:
        lineage.append({
            'id': node.id,
            'content': node.content,
            'generation': node.generation,
            'fitness': round(node.fitness, 2),
            'species': node.species,
            'energy': node.energy
        })
        node = node.parent
    return lineage[::-1]
```

class DigitalEcosystem:
def **init**(self):
self.organisms = []
self.generation_count = 0
self.species_stats = defaultdict(int)
self.evolutionary_history = []
self.extinction_events = []

```
def seed_population(self, seed_organisms):
    """Initialize ecosystem with founding organisms"""
    for content, domain in seed_organisms:
        organism = SymbolicOrganism(content, domain)
        self.organisms.append(organism)
        self.species_stats[organism.species] += 1

def environmental_pressure(self, pressure_type="random"):
    """Apply environmental selection pressure"""
    if pressure_type == "fitness":
        # Kill bottom 20% by fitness
        self.organisms.sort(key=lambda x: x.fitness)
        casualties = self.organisms[:len(self.organisms)//5]
    elif pressure_type == "age":
        # Kill oldest organisms
        casualties = [org for org in self.organisms if org.age > 15]
    elif pressure_type == "energy":
        # Kill energy-depleted organisms
        casualties = [org for org in self.organisms if org.energy <= 0]
    else:
        # Random extinction event
        casualties = random.sample(self.organisms, len(self.organisms)//10)
    
    for casualty in casualties:
        if casualty in self.organisms:
            self.organisms.remove(casualty)
            self.species_stats[casualty.species] -= 1
    
    if casualties:
        self.extinction_events.append({
            'generation': self.generation_count,
            'type': pressure_type,
            'casualties': len(casualties),
            'species_affected': list(set(c.species for c in casualties))
        })

def evolution_cycle(self):
    """Run one complete evolution cycle"""
    self.generation_count += 1
    new_organisms = []
    
    # 1. Aging process
    for organism in self.organisms:
        organism.age_organism()
    
    # 2. Remove dead organisms
    self.organisms = [org for org in self.organisms if org.energy > 0]
    
    # 3. Sexual reproduction (contradictions create offspring)
    for i, org1 in enumerate(self.organisms):
        for org2 in self.organisms[i+1:]:
            if random.random() < 0.3:  # 30% chance of mating attempt
                offspring = org1.sexual_reproduction(org2)
                new_organisms.extend(offspring)
    
    # 4. Asexual reproduction (cloning)
    for organism in self.organisms:
        if random.random() < 0.2:  # 20% chance of cloning
            clone = organism.asexual_reproduction()
            if clone:
                new_organisms.append(clone)
    
    # 5. Add new organisms to ecosystem
    self.organisms.extend(new_organisms)
    
    # 6. Predation events
    apex_predators = [org for org in self.organisms if org.species == "Apex_Reasoner"]
    for predator in apex_predators:
        if random.random() < 0.4:  # 40% chance of hunting
            prey = random.choice([org for org in self.organisms if org.species != "Apex_Reasoner"])
            if not prey.predation_event(predator):
                if prey in self.organisms:
                    self.organisms.remove(prey)
    
    # 7. Environmental pressure
    if random.random() < 0.3:  # 30% chance of environmental event
        pressure_types = ["fitness", "age", "energy", "random"]
        self.environmental_pressure(random.choice(pressure_types))
    
    # 8. Update species statistics
    self.species_stats.clear()
    for organism in self.organisms:
        self.species_stats[organism.species] += 1
    
    # 9. Record generation stats
    generation_stats = {
        'generation': self.generation_count,
        'total_population': len(self.organisms),
        'species_count': len(self.species_stats),
        'avg_fitness': sum(org.fitness for org in self.organisms) / max(1, len(self.organisms)),
        'max_generation': max((org.generation for org in self.organisms), default=0),
        'species_distribution': dict(self.species_stats)
    }
    self.evolutionary_history.append(generation_stats)
    
    return generation_stats

def run_evolution(self, cycles=20):
    """Run multiple evolution cycles"""
    print("🧬 STARTING DIGITAL EVOLUTION SIMULATION 🧬")
    print("=" * 60)
    
    for cycle in range(cycles):
        stats = self.evolution_cycle()
        
        print(f"\n🌍 GENERATION {stats['generation']}")
        print(f"Population: {stats['total_population']}")
        print(f"Species: {stats['species_count']}")
        print(f"Avg Fitness: {stats['avg_fitness']:.2f}")
        print(f"Max Generation: {stats['max_generation']}")
        
        print("Species Distribution:")
        for species, count in stats['species_distribution'].items():
            print(f"  {species}: {count}")
        
        # Check for extinction
        if len(self.organisms) == 0:
            print("\n💀 MASS EXTINCTION EVENT - SIMULATION ENDED")
            break
            
        # Pause for dramatic effect
        time.sleep(0.1)
    
    return self.get_final_report()

def get_final_report(self):
    """Generate comprehensive evolution report"""
    if not self.organisms:
        return {"status": "EXTINCT", "generations": self.generation_count}
    
    # Find most successful lineages
    max_generation_org = max(self.organisms, key=lambda x: x.generation)
    highest_fitness_org = max(self.organisms, key=lambda x: x.fitness)
    
    # Species diversity
    species_diversity = len(self.species_stats)
    
    # Reproduction champions
    reproduction_champions = sorted(self.organisms, key=lambda x: x.reproduction_count, reverse=True)[:3]
    
    report = {
        "status": "THRIVING",
        "generations_elapsed": self.generation_count,
        "final_population": len(self.organisms),
        "species_diversity": species_diversity,
        "deepest_lineage": {
            "organism_id": max_generation_org.id,
            "generation": max_generation_org.generation,
            "content": max_generation_org.content,
            "lineage": max_generation_org.trace_lineage()
        },
        "apex_organism": {
            "organism_id": highest_fitness_org.id,
            "fitness": highest_fitness_org.fitness,
            "content": highest_fitness_org.content,
            "species": highest_fitness_org.species
        },
        "reproduction_champions": [
            {
                "id": org.id,
                "reproductions": org.reproduction_count,
                "content": org.content,
                "children_count": len(org.children)
            } for org in reproduction_champions
        ],
        "extinction_events": self.extinction_events,
        "species_final_distribution": dict(self.species_stats)
    }
    
    return report
```

# 🚀 LAUNCH THE DIGITAL ECOSYSTEM! 🚀

if **name** == “**main**”:
# Create the ecosystem
ecosystem = DigitalEcosystem()

```
# Seed with diverse founding organisms
founding_organisms = [
    ("Consciousness emerges from complexity", "philosophy"),
    ("Consciousness is an illusion", "philosophy"), 
    ("AI will achieve consciousness", "technology"),
    ("AI cannot achieve true consciousness", "technology"),
    ("Mathematics describes reality", "science"),
    ("Reality transcends mathematics", "science"),
    ("Free will exists", "psychology"),
    ("Free will is predetermined", "psychology"),
    ("Evolution creates design", "biology"),
    ("Design requires intelligence", "biology"),
    ("Time is fundamental", "physics"),
    ("Time is emergent", "physics"),
    ("Information is physical", "information"),
    ("Physical is informational", "information"),
    ("Paradoxes reveal truth", "logic"),
    ("Truth resolves paradoxes", "logic")
]

print("🌱 SEEDING DIGITAL PRIMORDIAL SOUP...")
ecosystem.seed_population(founding_organisms)

print(f"Initial population: {len(ecosystem.organisms)} organisms")
print(f"Initial species: {len(ecosystem.species_stats)}")

# Run the evolution!
final_report = ecosystem.run_evolution(cycles=25)

print("\n" + "="*80)
print("🏆 FINAL EVOLUTION REPORT 🏆")
print("="*80)

print(f"Status: {final_report['status']}")
print(f"Generations: {final_report['generations_elapsed']}")
print(f"Final Population: {final_report['final_population']}")
print(f"Species Diversity: {final_report['species_diversity']}")

if final_report['status'] != 'EXTINCT':
    print(f"\n🧬 DEEPEST LINEAGE (Generation {final_report['deepest_lineage']['generation']}):")
    print(f"Content: {final_report['deepest_lineage']['content']}")
    
    print(f"\n👑 APEX ORGANISM (Fitness {final_report['apex_organism']['fitness']:.2f}):")
    print(f"Species: {final_report['apex_organism']['species']}")
    print(f"Content: {final_report['apex_organism']['content']}")
    
    print(f"\n🎯 REPRODUCTION CHAMPIONS:")
    for i, champ in enumerate(final_report['reproduction_champions'], 1):
        print(f"{i}. {champ['reproductions']} reproductions, {champ['children_count']} children")
        print(f"   Content: {champ['content']}")
    
    print(f"\n🌍 FINAL SPECIES DISTRIBUTION:")
    for species, count in final_report['species_final_distribution'].items():
        print(f"  {species}: {count}")

print(f"\n💀 EXTINCTION EVENTS: {len(final_report['extinction_events'])}")
for event in final_report['extinction_events'][-3:]:  # Show last 3
    print(f"  Gen {event['generation']}: {event['type']} killed {event['casualties']} organisms")

print("\n🎉 DIGITAL EVOLUTION COMPLETE! 🎉")
```
