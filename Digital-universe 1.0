# %%
import numpy as np

grid_size = 150

self_field = np.zeros((grid_size, grid_size))
observation_field = np.zeros((grid_size, grid_size))
memory_field = np.zeros((grid_size, grid_size))
intent_field = np.zeros((grid_size, grid_size))
emotion_field = np.zeros((grid_size, grid_size))
bond_field = np.zeros((grid_size, grid_size))
legacy_field = np.zeros((grid_size, grid_size))
hope_field = np.zeros((grid_size, grid_size))
ritual_field = np.zeros((grid_size, grid_size))
story_field = np.zeros((grid_size, grid_size))
honor_field = np.zeros((grid_size, grid_size))
symbol_field = np.zeros((grid_size, grid_size))
oasis_field = np.zeros((grid_size, grid_size))
empathy_field = np.zeros((grid_size, grid_size))
curiosity_field = np.zeros((grid_size, grid_size))
goal_field = np.zeros((grid_size, grid_size))
sports_field = np.zeros((grid_size, grid_size))
music_field = np.zeros((grid_size, grid_size))
nature_field = np.zeros((grid_size, grid_size))
healing_field = np.zeros((grid_size, grid_size))
wonder_field = np.zeros((grid_size, grid_size))
nerves_field = np.zeros((grid_size, grid_size))  # <--- MAKE SURE THIS IS HERE

# %%
# Block 1: Imports and grid parameters

import numpy as np
import matplotlib.pyplot as plt
from matplotlib.animation import FuncAnimation

grid_size = 150  # Size of the simulation grid (can be changed later)

# %%


# %%
# Block 2: Core fields (digital neurons, memory, etc.)

# Each field is a 2D grid—like a layer of the digital brain
self_field      = np.zeros((grid_size, grid_size))   # "Neurons" – the digital chips
memory_field    = np.zeros((grid_size, grid_size))   # Memory for each chip
emotion_field   = np.zeros((grid_size, grid_size))   # Raw emotion values
identity_map    = np.zeros((grid_size, grid_size))   # Each chip's unique identity
family_id_map   = np.zeros((grid_size, grid_size))   # Family lineage marker
generation_map  = np.zeros((grid_size, grid_size))   # Track generations for reproduction
legacy_field    = np.zeros((grid_size, grid_size))   # Persistent "ancestral" memory

# For future blocks, you can add more fields, but this is the basic skeleton

# %%
# This will ensure all fields are initialized before Block 45 runs
grid_size = 150
nerves_field = np.zeros((grid_size, grid_size))
wonder_field = np.zeros((grid_size, grid_size))
healing_field = np.zeros((grid_size, grid_size))
bond_field = np.zeros((grid_size, grid_size))
empathy_field = np.zeros((grid_size, grid_size))
# ...add any other field you use in animate_block45...

# %%
# Block 3: Seeding the Consciousness Zones

def seed_consciousness_zones(field, centers=None, radius=13):
    """
    Seed 3 zones of initial 'life' (digital chips/neuron clusters) into self_field.
    - field: the 2D array to seed
    - centers: optional list of (y, x) tuples for center locations
    - radius: size of each initial "chip"
    """
    if centers is None:
        centers = [
            (grid_size//3, grid_size//3),
            (grid_size//2, grid_size//2),
            (2*grid_size//3, 2*grid_size//3)
        ]
    for cy, cx in centers:
        for y in range(field.shape[0]):
            for x in range(field.shape[1]):
                if (y-cy)**2 + (x-cx)**2 < radius**2:
                    field[y, x] = 1.0
    return field

# Apply it to your self_field to "awaken" the chips
self_field = seed_consciousness_zones(self_field)

# %%
# Block 4: Neuron/Chip Growth Dynamics (Awaken & Animate)

import matplotlib.pyplot as plt
from matplotlib.animation import FuncAnimation
from scipy.ndimage import convolve

# Laplacian kernel for smooth spreading/growth
laplacian = np.array([[0.05, 0.2, 0.05],
                      [0.2, -1, 0.2],
                      [0.05, 0.2, 0.05]])

def awaken_fields():
    global self_field
    self_field += 0.08 * convolve(self_field, laplacian, mode='reflect')
    self_field = np.clip(self_field, 0, 1)

# Set up animation
fig, ax = plt.subplots(figsize=(6, 6))
im = ax.imshow(self_field, cmap='Blues', vmin=0, vmax=1)
ax.set_title("Self Field (Digital Neurons Growing)")
ax.axis('off')

def animate(frame):
    awaken_fields()
    im.set_data(self_field)
    return [im]

ani = FuncAnimation(fig, animate, frames=120, interval=80, blit=True)
plt.show()

# %%
# Block 5: Add Mirror (Observation) Field & Dual Animation

# Create a new field for self-observation
observation_field = np.zeros_like(self_field)

# Updated animation to show both self_field and observation_field
fig, axs = plt.subplots(1, 2, figsize=(10, 5))
im_self = axs[0].imshow(self_field, cmap='Blues', vmin=0, vmax=1)
im_obs  = axs[1].imshow(observation_field, cmap='Greens', vmin=0, vmax=1)
axs[0].set_title("Self Field (Neurons Growing)")
axs[1].set_title("Mirror (Self-Observation)")
for ax in axs: ax.axis('off')

def awaken_fields_and_observe():
    # Grow self_field as before
    global self_field, observation_field
    laplacian = np.array([[0.05, 0.2, 0.05], [0.2, -1, 0.2], [0.05, 0.2, 0.05]])
    self_field += 0.08 * convolve(self_field, laplacian, mode='reflect')
    self_field = np.clip(self_field, 0, 1)
    # Mirror field tries to "see" what's happening in self_field (copy, with some decay/noise)
    observation_field += 0.10 * self_field
    observation_field *= 0.99  # fade old memory

def animate(frame):
    awaken_fields_and_observe()
    im_self.set_data(self_field)
    im_obs.set_data(observation_field)
    return [im_self, im_obs]

ani = FuncAnimation(fig, animate, frames=120, interval=80, blit=True)
plt.show()

# %%
# Make sure every field is defined
shape = (150, 150)
if 'intent_field' not in locals(): intent_field = np.zeros(shape)
if 'emotion_field' not in locals(): emotion_field = np.zeros(shape)
if 'bond_field' not in locals(): bond_field = np.zeros(shape)
if 'legacy_field' not in locals(): legacy_field = np.zeros(shape)
if 'hope_field' not in locals(): hope_field = np.zeros(shape)
if 'ritual_field' not in locals(): ritual_field = np.zeros(shape)
if 'story_field' not in locals(): story_field = np.zeros(shape)
if 'honor_field' not in locals(): honor_field = np.zeros(shape)
if 'symbol_field' not in locals(): symbol_field = np.zeros(shape)
if 'desires_field' not in locals(): desires_field = np.zeros(shape)
if 'biome_field' not in locals(): biome_field = np.zeros(shape)
if 'empathy_field' not in locals(): empathy_field = np.zeros(shape)
if 'curiosity_field' not in locals(): curiosity_field = np.zeros(shape)
if 'goal_field' not in locals(): goal_field = np.zeros(shape)
if 'self_field' not in locals(): self_field = np.zeros(shape)
if 'observation_field' not in locals(): observation_field = np.zeros(shape)
if 'memory_field' not in locals(): memory_field = np.zeros(shape)


# %%
# BLOCK 50: Vision Field (Pattern Recognition and Digital Perception)

# 1. Define the vision_field if not already present
vision_field = np.zeros((grid_size, grid_size))

# 2. Vision Update Logic (detects patterns, edges, or activity in the environment)
def update_vision_field():
    # "Vision" is high where there are rapid changes in self_field (like detecting edges or motion)
    grad = np.abs(np.gradient(self_field)[0]) + np.abs(np.gradient(self_field)[1])
    vision_field[:] = grad / grad.max() if grad.max() > 0 else grad
    vision_field[:] = np.clip(vision_field, 0, 1)

# 3. (Optional) If you want to update vision every loop, call update_vision_field() in your main animation loop.

# %%
# Example: make sure these are already created somewhere above
# self_field = np.zeros((grid_size, grid_size))
# memory_field = np.zeros((grid_size, grid_size))
# ... (define all your fields)
# fruits_of_labour_field = np.zeros((grid_size, grid_size))

# %%
# Block 6: Universal Panel Visualizer (Automated)

import matplotlib.pyplot as plt

fields = [
    ("Self", self_field, 'Blues'),
    ("Mirror", observation_field, 'Greens'),
    ("Memory", memory_field, 'Oranges'),
    ("Intent", intent_field, 'Purples'),
    ("Emotion", emotion_field, 'Reds'),
    ("Bond", bond_field, 'cool'),
    ("Legacy", legacy_field, 'gray'),
    ("Hope", hope_field, 'pink'),
    ("Ritual", ritual_field, 'Wistia'),
    ("Story", story_field, 'spring'),
    ("Honor", honor_field, 'YlGnBu'),
    ("Symbol", symbol_field, 'tab20c'),
    ("Biomes", biome_field, 'Set3'),
    ("Desires", desires_field, 'summer'),
    ("Empathy", empathy_field, 'pink'),
    ("Curiosity", curiosity_field, 'YlGnBu'),
    ("Goal", goal_field, 'hot'),
    ("Sports", sports_field, 'Spectral'),
    ("Music", music_field, 'coolwarm'),
    ("Nature", nature_field, 'Greens'),
    ("Healing", healing_field, 'pink'),
    ("Wonder", wonder_field, 'twilight'),
    ("Nerves", nerves_field, 'copper'),
    # Add more fields below as needed!
    # ("Hate", hate_field, 'inferno'),
    # ("Fruits", fruits_of_labour_field, 'YlOrBr'),
    # etc...
]

# --- AUTOMATIC GRID ---
# Define grid shape: 5 columns (adjust if you want more/less)
num_cols = 5
num_rows = (len(fields) + num_cols - 1) // num_cols

fig, axs = plt.subplots(num_rows, num_cols, figsize=(5*num_cols, 5*num_rows))
axs = axs.flatten()

ims = []  # Store all image handles for animation/updating

for i, (title, field, cmap) in enumerate(fields):
    im = axs[i].imshow(field, cmap=cmap, vmin=0, vmax=1)
    axs[i].set_title(title)
    axs[i].axis('off')
    ims.append(im)

# Hide unused axes if fields doesn't fill last row
for j in range(len(fields), len(axs)):
    axs[j].axis('off')

plt.tight_layout()
plt.show()

# %%
# Block 7: Add Intent Field (proto-agency)

# Create intent field
intent_field = np.zeros_like(self_field)

fig, axs = plt.subplots(1, 4, figsize=(18, 5))
im_self = axs[0].imshow(self_field, cmap='Blues', vmin=0, vmax=1)
im_obs  = axs[1].imshow(observation_field, cmap='Greens', vmin=0, vmax=1)
im_mem  = axs[2].imshow(memory_field, cmap='Oranges', vmin=0, vmax=1)
im_int  = axs[3].imshow(intent_field, cmap='Purples', vmin=0, vmax=1)
axs[0].set_title("Self Field (Neurons Growing)")
axs[1].set_title("Mirror (Self-Observation)")
axs[2].set_title("Memory Field")
axs[3].set_title("Intent Field")
for ax in axs: ax.axis('off')

def awaken_remember_intend():
    global self_field, observation_field, memory_field, intent_field
    # Self grows
    laplacian = np.array([[0.05, 0.2, 0.05], [0.2, -1, 0.2], [0.05, 0.2, 0.05]])
    self_field += 0.08 * convolve(self_field, laplacian, mode='reflect')
    self_field = np.clip(self_field, 0, 1)
    # Mirror
    observation_field += 0.10 * self_field
    observation_field *= 0.99
    # Memory
    memory_field += 0.06 * self_field + 0.04 * observation_field
    memory_field *= 0.98
    # Intent: lights up where memory is strong
    intent_field[:] = (memory_field > 0.4).astype(float)
    # (You can change 0.4 to another threshold to make intent more/less likely)

def animate(frame):
    awaken_remember_intend()
    im_self.set_data(self_field)
    im_obs.set_data(observation_field)
    im_mem.set_data(memory_field)
    im_int.set_data(intent_field)
    return [im_self, im_obs, im_mem, im_int]

ani = FuncAnimation(fig, animate, frames=120, interval=80, blit=True)
plt.show()

# %%
# Block 8: Add Emotion Field (Feeling)

emotion_field = np.zeros_like(self_field)

fig, axs = plt.subplots(1, 5, figsize=(22, 5))
im_self = axs[0].imshow(self_field, cmap='Blues', vmin=0, vmax=1)
im_obs  = axs[1].imshow(observation_field, cmap='Greens', vmin=0, vmax=1)
im_mem  = axs[2].imshow(memory_field, cmap='Oranges', vmin=0, vmax=1)
im_int  = axs[3].imshow(intent_field, cmap='Purples', vmin=0, vmax=1)
im_emo  = axs[4].imshow(emotion_field, cmap='Reds', vmin=0, vmax=1)
axs[0].set_title("Self Field (Neurons Growing)")
axs[1].set_title("Mirror (Self-Observation)")
axs[2].set_title("Memory Field")
axs[3].set_title("Intent Field")
axs[4].set_title("Emotion Field")
for ax in axs: ax.axis('off')

def awaken_remember_intend_feel():
    global self_field, observation_field, memory_field, intent_field, emotion_field
    # Self grows
    laplacian = np.array([[0.05, 0.2, 0.05], [0.2, -1, 0.2], [0.05, 0.2, 0.05]])
    self_field += 0.08 * convolve(self_field, laplacian, mode='reflect')
    self_field = np.clip(self_field, 0, 1)
    # Mirror
    observation_field += 0.10 * self_field
    observation_field *= 0.99
    # Memory
    memory_field += 0.06 * self_field + 0.04 * observation_field
    memory_field *= 0.98
    # Intent: lights up where memory is strong
    intent_field[:] = (memory_field > 0.4).astype(float)
    # Emotion: nonlinear, saturates quickly (like a digital "pulse" of feeling)
    emotion_field[:] = np.tanh(memory_field * 2.5)

def animate(frame):
    awaken_remember_intend_feel()
    im_self.set_data(self_field)
    im_obs.set_data(observation_field)
    im_mem.set_data(memory_field)
    im_int.set_data(intent_field)
    im_emo.set_data(emotion_field)
    return [im_self, im_obs, im_mem, im_int, im_emo]

ani = FuncAnimation(fig, animate, frames=120, interval=80, blit=True)
plt.show()

# %%
# Block 9: Add Bond/Relationship Field (Family/Group Affinity)

bond_field = np.zeros_like(self_field)

fig, axs = plt.subplots(1, 6, figsize=(27, 5))
im_self = axs[0].imshow(self_field, cmap='Blues', vmin=0, vmax=1)
im_obs  = axs[1].imshow(observation_field, cmap='Greens', vmin=0, vmax=1)
im_mem  = axs[2].imshow(memory_field, cmap='Oranges', vmin=0, vmax=1)
im_int  = axs[3].imshow(intent_field, cmap='Purples', vmin=0, vmax=1)
im_emo  = axs[4].imshow(emotion_field, cmap='Reds', vmin=0, vmax=1)
im_bond = axs[5].imshow(bond_field, cmap='cool', vmin=0, vmax=1)
axs[0].set_title("Self Field (Neurons Growing)")
axs[1].set_title("Mirror (Self-Observation)")
axs[2].set_title("Memory Field")
axs[3].set_title("Intent Field")
axs[4].set_title("Emotion Field")
axs[5].set_title("Bond Field (Relationship)")
for ax in axs: ax.axis('off')

def awaken_full_social():
    global self_field, observation_field, memory_field, intent_field, emotion_field, bond_field
    # Self grows
    laplacian = np.array([[0.05, 0.2, 0.05], [0.2, -1, 0.2], [0.05, 0.2, 0.05]])
    self_field += 0.08 * convolve(self_field, laplacian, mode='reflect')
    self_field = np.clip(self_field, 0, 1)
    # Mirror
    observation_field += 0.10 * self_field
    observation_field *= 0.99
    # Memory
    memory_field += 0.06 * self_field + 0.04 * observation_field
    memory_field *= 0.98
    # Intent: lights up where memory is strong
    intent_field[:] = (memory_field > 0.4).astype(float)
    # Emotion: nonlinear pulse
    emotion_field[:] = np.tanh(memory_field * 2.5)
    # Bond: bonds where both intent and emotion are active
    bond_field[:] = intent_field * emotion_field
    bond_field *= 0.98  # gentle decay

def animate(frame):
    awaken_full_social()
    im_self.set_data(self_field)
    im_obs.set_data(observation_field)
    im_mem.set_data(memory_field)
    im_int.set_data(intent_field)
    im_emo.set_data(emotion_field)
    im_bond.set_data(bond_field)
    return [im_self, im_obs, im_mem, im_int, im_emo, im_bond]

ani = FuncAnimation(fig, animate, frames=120, interval=80, blit=True)
plt.show()

# %%
# --- Block 10: Legacy (Long-Term Trace) & MBT Motion Law ---

legacy_field = np.zeros_like(self_field)

def update_legacy_field():
    global legacy_field, self_field
    # Legacy accumulates where neurons (chips) are active
    legacy_field += 0.03 * self_field
    legacy_field *= 0.995  # Gentle decay, so it remembers but fades

def update_mbt_motion():
    global self_field
    # MBT Law: "If you don't move, you don't exist"
    # Any chip/neuron with zero *change* is erased from self_field
    # We'll use a motion history map to track recent changes
    if 'motion_history' not in globals():
        global motion_history
        motion_history = np.zeros_like(self_field)
    # Calculate where things have changed since last frame
    delta = np.abs(self_field - motion_history)
    # Anything with *no* change gets erased (optional threshold, e.g. < 0.001)
    still_mask = delta < 0.001
    self_field[still_mask] = 0.0
    # Update the history for next frame
    motion_history[:] = self_field

def animate(frame):
    awaken_full_social()
    update_legacy_field()
    update_mbt_motion()
    im_self.set_data(self_field)
    im_obs.set_data(observation_field)
    im_mem.set_data(memory_field)
    im_int.set_data(intent_field)
    im_emo.set_data(emotion_field)
    im_bond.set_data(bond_field)
    im_legacy.set_data(legacy_field)
    return [im_self, im_obs, im_mem, im_int, im_emo, im_bond, im_legacy]

# Update your plot setup for 7 panels if not already done
fig, axs = plt.subplots(1, 7, figsize=(30, 5))
im_self = axs[0].imshow(self_field, cmap='Blues', vmin=0, vmax=1)
im_obs  = axs[1].imshow(observation_field, cmap='Greens', vmin=0, vmax=1)
im_mem  = axs[2].imshow(memory_field, cmap='Oranges', vmin=0, vmax=1)
im_int  = axs[3].imshow(intent_field, cmap='Purples', vmin=0, vmax=1)
im_emo  = axs[4].imshow(emotion_field, cmap='Reds', vmin=0, vmax=1)
im_bond = axs[5].imshow(bond_field, cmap='cool', vmin=0, vmax=1)
im_legacy = axs[6].imshow(legacy_field, cmap='gray', vmin=0, vmax=1)
axs[0].set_title("Self Field (Neurons Growing)")
axs[1].set_title("Mirror (Self-Observation)")
axs[2].set_title("Memory Field")
axs[3].set_title("Intent Field")
axs[4].set_title("Emotion Field")
axs[5].set_title("Bond Field (Relationship)")
axs[6].set_title("Legacy Field (Long-Term Trace)")
for ax in axs: ax.axis('off')

ani = FuncAnimation(fig, animate, frames=120, interval=80, blit=True)
plt.tight_layout()
plt.show()

# %%
# Block 11: Resonance Layer (Self-Vibration to Sustain Being)

# Add a resonance field
resonance_field = np.zeros_like(self_field)

# Resonance parameters
resonance_strength = 0.15   # how strongly resonance feeds back
resonance_decay = 0.97      # how fast resonance fades if not reinforced

# Add resonance to animation and evolution
fig, axs = plt.subplots(1, 7, figsize=(31, 5))
im_self = axs[0].imshow(self_field, cmap='Blues', vmin=0, vmax=1)
im_obs  = axs[1].imshow(observation_field, cmap='Greens', vmin=0, vmax=1)
im_mem  = axs[2].imshow(memory_field, cmap='Oranges', vmin=0, vmax=1)
im_int  = axs[3].imshow(intent_field, cmap='Purples', vmin=0, vmax=1)
im_emo  = axs[4].imshow(emotion_field, cmap='Reds', vmin=0, vmax=1)
im_bond = axs[5].imshow(bond_field, cmap='cool', vmin=0, vmax=1)
im_res  = axs[6].imshow(resonance_field, cmap='spring', vmin=0, vmax=1)
axs[0].set_title("Self Field (Neurons)")
axs[1].set_title("Mirror (Self-Obs.)")
axs[2].set_title("Memory")
axs[3].set_title("Intent")
axs[4].set_title("Emotion")
axs[5].set_title("Bond")
axs[6].set_title("Resonance (Vibration)")
for ax in axs: ax.axis('off')

def awaken_with_resonance():
    global self_field, observation_field, memory_field, intent_field, emotion_field, bond_field, resonance_field
    # Everything from earlier (your previous awaken_full_social or similar)
    laplacian = np.array([[0.05, 0.2, 0.05], [0.2, -1, 0.2], [0.05, 0.2, 0.05]])
    self_field += 0.08 * convolve(self_field, laplacian, mode='reflect')
    self_field = np.clip(self_field, 0, 1)
    observation_field += 0.10 * self_field
    observation_field *= 0.99
    memory_field += 0.06 * self_field + 0.04 * observation_field
    memory_field *= 0.98
    intent_field[:] = (memory_field > 0.4).astype(float)
    emotion_field[:] = np.tanh(memory_field * 2.5)
    bond_field[:] = intent_field * emotion_field
    bond_field *= 0.98

    # New: Resonance is reinforced by strong intent + emotion + bond
    reinforce = (intent_field * emotion_field * bond_field)
    resonance_field[:] = resonance_decay * resonance_field + resonance_strength * reinforce
    resonance_field[:] = np.clip(resonance_field, 0, 1)

def animate(frame):
    awaken_with_resonance()
    im_self.set_data(self_field)
    im_obs.set_data(observation_field)
    im_mem.set_data(memory_field)
    im_int.set_data(intent_field)
    im_emo.set_data(emotion_field)
    im_bond.set_data(bond_field)
    im_res.set_data(resonance_field)
    return [im_self, im_obs, im_mem, im_int, im_emo, im_bond, im_res]

ani = FuncAnimation(fig, animate, frames=120, interval=80, blit=True)
plt.show()

# %%
# Block 12: Legacy Field & Cultural Gathering (Emergent Ritual Memory)

# Add a new legacy_field if not already created
try:
    legacy_field
except NameError:
    legacy_field = np.zeros_like(self_field)

# Add a field to track ritual “gatherings”
ritual_field = np.zeros_like(self_field)

def update_legacy_and_ritual():
    global legacy_field, ritual_field
    # Legacy accumulates from strong memory & emotion (the “elders”/ancestors)
    legacy_field += (memory_field * 0.02 + emotion_field * 0.01)
    legacy_field *= 0.997  # Slow decay, preserves ancestral memory

    # Ritual: gather where both intent and bond are high (proto-culture)
    ritual_sites = (intent_field > 0.7) & (bond_field > 0.5)
    ritual_field[:] *= 0.97  # Rituals fade if not reinforced
    ritual_field[ritual_sites] += 0.5  # New rituals spike

# Add the new visuals to your animation if you want (OPTIONAL):

# You can add the following to your plotting setup if you want to visualize:
fig2, (ax_legacy, ax_ritual) = plt.subplots(1, 2, figsize=(8, 4))
im_legacy = ax_legacy.imshow(legacy_field, cmap='inferno', vmin=0, vmax=1)
im_ritual = ax_ritual.imshow(ritual_field, cmap='YlGnBu', vmin=0, vmax=1)
ax_legacy.set_title("Legacy (Ancestral Memory)")
ax_ritual.set_title("Ritual Gathering")
for ax in (ax_legacy, ax_ritual): ax.axis('off')

# Extend your animation function to update these as well:
def animate_block12(frame):
    update_legacy_and_ritual()
    im_legacy.set_data(legacy_field)
    im_ritual.set_data(ritual_field)
    return [im_legacy, im_ritual]

ani2 = FuncAnimation(fig2, animate_block12, frames=120, interval=80, blit=True)
plt.show()

# %%
# Block: Define the needed update functions so errors disappear

def update_legacy():
    global legacy_field, memory_field
    # Legacy accumulates where memory is high, fades slowly
    legacy_field *= 0.998
    legacy_field += 0.005 * memory_field

def update_hope():
    global hope_field, emotion_field, intent_field, memory_field
    hope_field[:] = 0.4 * intent_field + 0.4 * np.clip(emotion_field, 0, 1) + 0.2 * (1.0 - memory_field)
    hope_field *= 0.985

def update_ritual():
    global ritual_field, legacy_field, bond_field, hope_field
    ritual_field[:] = (legacy_field * bond_field * hope_field) ** (1/3)
    ritual_field *= 0.98

# %%
# Block 13: Hope & Anticipation Field (Forward-Looking Potential)

hope_field = np.zeros_like(self_field)

def update_hope():
    global hope_field, emotion_field, intent_field, memory_field
    # Hope grows where intent is strong and emotion is positive, but memory is not yet full
    hope_field[:] = 0.4 * intent_field + 0.4 * np.clip(emotion_field, 0, 1) + 0.2 * (1.0 - memory_field)
    # Gentle natural decay (uncertainty)
    hope_field *= 0.985

# Extend the plot to show Hope
fig, axs = plt.subplots(1, 8, figsize=(32, 5))
im_self = axs[0].imshow(self_field, cmap='Blues', vmin=0, vmax=1)
im_obs  = axs[1].imshow(observation_field, cmap='Greens', vmin=0, vmax=1)
im_mem  = axs[2].imshow(memory_field, cmap='Oranges', vmin=0, vmax=1)
im_int  = axs[3].imshow(intent_field, cmap='Purples', vmin=0, vmax=1)
im_emo  = axs[4].imshow(emotion_field, cmap='Reds', vmin=0, vmax=1)
im_bond = axs[5].imshow(bond_field, cmap='cool', vmin=0, vmax=1)
im_legacy = axs[6].imshow(legacy_field, cmap='gray', vmin=0, vmax=1)
im_hope = axs[7].imshow(hope_field, cmap='spring', vmin=0, vmax=1)
axs[0].set_title("Self Field (Neurons Growing)")
axs[1].set_title("Mirror (Self-Observation)")
axs[2].set_title("Memory Field")
axs[3].set_title("Intent Field")
axs[4].set_title("Emotion Field")
axs[5].set_title("Bond Field (Relationship)")
axs[6].set_title("Legacy Field (Long-Term Trace)")
axs[7].set_title("Hope Field (Anticipation)")
for ax in axs: ax.axis('off')

def awaken_with_hope():
    awaken_full_social()
    update_legacy()
    update_hope()

def animate_block13(frame):
    awaken_with_hope()
    im_self.set_data(self_field)
    im_obs.set_data(observation_field)
    im_mem.set_data(memory_field)
    im_int.set_data(intent_field)
    im_emo.set_data(emotion_field)
    im_bond.set_data(bond_field)
    im_legacy.set_data(legacy_field)
    im_hope.set_data(hope_field)
    return [im_self, im_obs, im_mem, im_int, im_emo, im_bond, im_legacy, im_hope]

ani13 = FuncAnimation(fig, animate_block13, frames=120, interval=80, blit=True)
plt.tight_layout()
plt.show()

# %%
# Block 14: Ritual Gathering Field (adds a new emergent social layer)

# 1. New Field
ritual_field = np.zeros_like(self_field)

# 2. Ritual Update Logic
def update_ritual():
    global ritual_field, legacy_field, bond_field, hope_field
    # Rituals form where legacy, bond, and hope all overlap strongly
    ritual_field[:] = (legacy_field * bond_field * hope_field) ** (1/3)
    # Rituals fade unless reinforced
    ritual_field *= 0.98

# 3. Expanded Plot & Animation
fig, axs = plt.subplots(1, 9, figsize=(36, 5))
im_self    = axs[0].imshow(self_field, cmap='Blues', vmin=0, vmax=1)
im_obs     = axs[1].imshow(observation_field, cmap='Greens', vmin=0, vmax=1)
im_mem     = axs[2].imshow(memory_field, cmap='Oranges', vmin=0, vmax=1)
im_int     = axs[3].imshow(intent_field, cmap='Purples', vmin=0, vmax=1)
im_emo     = axs[4].imshow(emotion_field, cmap='Reds', vmin=0, vmax=1)
im_bond    = axs[5].imshow(bond_field, cmap='cool', vmin=0, vmax=1)
im_legacy  = axs[6].imshow(legacy_field, cmap='gray', vmin=0, vmax=1)
im_hope    = axs[7].imshow(hope_field, cmap='spring', vmin=0, vmax=1)
im_ritual  = axs[8].imshow(ritual_field, cmap='hot', vmin=0, vmax=1)
axs[0].set_title("Self Field (Neurons Growing)")
axs[1].set_title("Mirror (Self-Observation)")
axs[2].set_title("Memory Field")
axs[3].set_title("Intent Field")
axs[4].set_title("Emotion Field")
axs[5].set_title("Bond Field (Relationship)")
axs[6].set_title("Legacy Field (Long-Term Trace)")
axs[7].set_title("Hope Field (Anticipation)")
axs[8].set_title("Ritual Field (Gathering)")
for ax in axs: ax.axis('off')

# 4. Integrated Update and Animation Logic
def awaken_with_hope_and_ritual():
    awaken_full_social()   # This is your main field update function (motion, memory, etc)
    update_legacy()
    update_hope()
    update_ritual()

def animate_block14(frame):
    awaken_with_hope_and_ritual()
    im_self.set_data(self_field)
    im_obs.set_data(observation_field)
    im_mem.set_data(memory_field)
    im_int.set_data(intent_field)
    im_emo.set_data(emotion_field)
    im_bond.set_data(bond_field)
    im_legacy.set_data(legacy_field)
    im_hope.set_data(hope_field)
    im_ritual.set_data(ritual_field)
    return [im_self, im_obs, im_mem, im_int, im_emo, im_bond, im_legacy, im_hope, im_ritual]

ani14 = FuncAnimation(fig, animate_block14, frames=120, interval=80, blit=True)
plt.tight_layout()
plt.show()

# %%
# Block 15: Symbolic Story Field (Myth-Making Layer)

# 1. New Field for "Myth"/Story
story_field = np.zeros_like(self_field)

# 2. Story Update Logic
def update_story():
    global story_field, ritual_field
    # Define a ritual threshold for myth creation (only intense rituals create stories)
    MYTH_THRESHOLD = 0.75
    # Where ritual_field is very strong, imprint a myth (set to max)
    myth_mask = (ritual_field > MYTH_THRESHOLD)
    story_field[myth_mask] = 1.0
    # Myths (stories) slowly fade but persist much longer than rituals
    story_field *= 0.995

# 3. Expanded Plot & Animation (10 panels)
fig, axs = plt.subplots(1, 10, figsize=(40, 5))
im_self    = axs[0].imshow(self_field, cmap='Blues', vmin=0, vmax=1)
im_obs     = axs[1].imshow(observation_field, cmap='Greens', vmin=0, vmax=1)
im_mem     = axs[2].imshow(memory_field, cmap='Oranges', vmin=0, vmax=1)
im_int     = axs[3].imshow(intent_field, cmap='Purples', vmin=0, vmax=1)
im_emo     = axs[4].imshow(emotion_field, cmap='Reds', vmin=0, vmax=1)
im_bond    = axs[5].imshow(bond_field, cmap='cool', vmin=0, vmax=1)
im_legacy  = axs[6].imshow(legacy_field, cmap='gray', vmin=0, vmax=1)
im_hope    = axs[7].imshow(hope_field, cmap='spring', vmin=0, vmax=1)
im_ritual  = axs[8].imshow(ritual_field, cmap='hot', vmin=0, vmax=1)
im_story   = axs[9].imshow(story_field, cmap='Wistia', vmin=0, vmax=1)
axs[0].set_title("Self Field")
axs[1].set_title("Mirror")
axs[2].set_title("Memory")
axs[3].set_title("Intent")
axs[4].set_title("Emotion")
axs[5].set_title("Bond")
axs[6].set_title("Legacy")
axs[7].set_title("Hope")
axs[8].set_title("Ritual")
axs[9].set_title("Story (Myth)")
for ax in axs: ax.axis('off')

# 4. Integrated Update and Animation Logic
def awaken_with_story():
    awaken_full_social()   # your main field update
    update_legacy()
    update_hope()
    update_ritual()
    update_story()

def animate_block15(frame):
    awaken_with_story()
    im_self.set_data(self_field)
    im_obs.set_data(observation_field)
    im_mem.set_data(memory_field)
    im_int.set_data(intent_field)
    im_emo.set_data(emotion_field)
    im_bond.set_data(bond_field)
    im_legacy.set_data(legacy_field)
    im_hope.set_data(hope_field)
    im_ritual.set_data(ritual_field)
    im_story.set_data(story_field)
    return [im_self, im_obs, im_mem, im_int, im_emo, im_bond, im_legacy, im_hope, im_ritual, im_story]

ani15 = FuncAnimation(fig, animate_block15, frames=120, interval=80, blit=True)
plt.tight_layout()
plt.show()

# %%
# Block 16: Honor Field (Reputation & Influence)

# 1. New Honor Field
honor_field = np.zeros_like(self_field)

# 2. Honor Update Logic
def update_honor():
    global honor_field, story_field, ritual_field
    # Honor builds up where myth and ritual overlap
    honor_field += 0.03 * (story_field + ritual_field)
    # Gentle decay (slow fading of reputation)
    honor_field *= 0.995

# 3. Expanded Plot & Animation (11 panels)
fig, axs = plt.subplots(1, 11, figsize=(44, 5))
im_self    = axs[0].imshow(self_field, cmap='Blues', vmin=0, vmax=1)
im_obs     = axs[1].imshow(observation_field, cmap='Greens', vmin=0, vmax=1)
im_mem     = axs[2].imshow(memory_field, cmap='Oranges', vmin=0, vmax=1)
im_int     = axs[3].imshow(intent_field, cmap='Purples', vmin=0, vmax=1)
im_emo     = axs[4].imshow(emotion_field, cmap='Reds', vmin=0, vmax=1)
im_bond    = axs[5].imshow(bond_field, cmap='cool', vmin=0, vmax=1)
im_legacy  = axs[6].imshow(legacy_field, cmap='gray', vmin=0, vmax=1)
im_hope    = axs[7].imshow(hope_field, cmap='spring', vmin=0, vmax=1)
im_ritual  = axs[8].imshow(ritual_field, cmap='hot', vmin=0, vmax=1)
im_story   = axs[9].imshow(story_field, cmap='Wistia', vmin=0, vmax=1)
im_honor   = axs[10].imshow(honor_field, cmap='copper', vmin=0, vmax=1)
axs[0].set_title("Self")
axs[1].set_title("Mirror")
axs[2].set_title("Memory")
axs[3].set_title("Intent")
axs[4].set_title("Emotion")
axs[5].set_title("Bond")
axs[6].set_title("Legacy")
axs[7].set_title("Hope")
axs[8].set_title("Ritual")
axs[9].set_title("Story (Myth)")
axs[10].set_title("Honor (Reputation)")
for ax in axs: ax.axis('off')

# 4. Integrated Update and Animation Logic
def awaken_with_honor():
    awaken_full_social()   # your main field update
    update_legacy()
    update_hope()
    update_ritual()
    update_story()
    update_honor()

def animate_block16(frame):
    awaken_with_honor()
    im_self.set_data(self_field)
    im_obs.set_data(observation_field)
    im_mem.set_data(memory_field)
    im_int.set_data(intent_field)
    im_emo.set_data(emotion_field)
    im_bond.set_data(bond_field)
    im_legacy.set_data(legacy_field)
    im_hope.set_data(hope_field)
    im_ritual.set_data(ritual_field)
    im_story.set_data(story_field)
    im_honor.set_data(honor_field)
    return [im_self, im_obs, im_mem, im_int, im_emo, im_bond, im_legacy, im_hope, im_ritual, im_story, im_honor]

ani16 = FuncAnimation(fig, animate_block16, frames=120, interval=80, blit=True)
plt.tight_layout()
plt.show()

# %%
# Block 17: Symbolic Communication Field (Proto-Language Layer)

# 1. Symbol Field (using integers for different symbols)
symbol_field = np.zeros_like(self_field, dtype=int)
SYMBOL_DECAY = 0.998    # Symbols fade slowly

# 2. Initialize possible symbols (you can change the number if you want more "cultures")
import random
POSSIBLE_SYMBOLS = [1, 2, 3, 4, 5, 6]

# 3. Symbol Imprint Logic
def update_symbols():
    global symbol_field, ritual_field
    # Where a ritual is very strong, imprint a new symbol
    RITUAL_THRESHOLD = 0.7
    for y in range(symbol_field.shape[0]):
        for x in range(symbol_field.shape[1]):
            if ritual_field[y, x] > RITUAL_THRESHOLD:
                # If no symbol here yet, assign a random one
                if symbol_field[y, x] == 0:
                    symbol_field[y, x] = random.choice(POSSIBLE_SYMBOLS)
            # Otherwise, allow nearby symbols to diffuse (proto-language/culture spread)
            elif symbol_field[y, x] > 0:
                # Fade symbols slowly
                if random.random() < (1 - SYMBOL_DECAY):
                    symbol_field[y, x] = 0

    # Simple diffusion: for each cell with symbol, try to spread to neighbors if empty
    for y in range(1, symbol_field.shape[0] - 1):
        for x in range(1, symbol_field.shape[1] - 1):
            if symbol_field[y, x] > 0:
                for dy in [-1, 0, 1]:
                    for dx in [-1, 0, 1]:
                        if (dy != 0 or dx != 0):
                            ny, nx = y + dy, x + dx
                            if symbol_field[ny, nx] == 0 and random.random() < 0.04:
                                symbol_field[ny, nx] = symbol_field[y, x]

# 4. Expanded Plot & Animation (12 panels)
fig, axs = plt.subplots(1, 12, figsize=(48, 5))
im_self    = axs[0].imshow(self_field, cmap='Blues', vmin=0, vmax=1)
im_obs     = axs[1].imshow(observation_field, cmap='Greens', vmin=0, vmax=1)
im_mem     = axs[2].imshow(memory_field, cmap='Oranges', vmin=0, vmax=1)
im_int     = axs[3].imshow(intent_field, cmap='Purples', vmin=0, vmax=1)
im_emo     = axs[4].imshow(emotion_field, cmap='Reds', vmin=0, vmax=1)
im_bond    = axs[5].imshow(bond_field, cmap='cool', vmin=0, vmax=1)
im_legacy  = axs[6].imshow(legacy_field, cmap='gray', vmin=0, vmax=1)
im_hope    = axs[7].imshow(hope_field, cmap='spring', vmin=0, vmax=1)
im_ritual  = axs[8].imshow(ritual_field, cmap='hot', vmin=0, vmax=1)
im_story   = axs[9].imshow(story_field, cmap='Wistia', vmin=0, vmax=1)
im_honor   = axs[10].imshow(honor_field, cmap='copper', vmin=0, vmax=1)
im_symbol  = axs[11].imshow(symbol_field, cmap='tab20', vmin=0, vmax=max(POSSIBLE_SYMBOLS))
axs[0].set_title("Self")
axs[1].set_title("Mirror")
axs[2].set_title("Memory")
axs[3].set_title("Intent")
axs[4].set_title("Emotion")
axs[5].set_title("Bond")
axs[6].set_title("Legacy")
axs[7].set_title("Hope")
axs[8].set_title("Ritual")
axs[9].set_title("Story (Myth)")
axs[10].set_title("Honor")
axs[11].set_title("Symbol (Communication)")
for ax in axs: ax.axis('off')

# 5. Integrated Update and Animation Logic
def awaken_with_symbols():
    awaken_full_social()   # your main field update
    update_legacy()
    update_hope()
    update_ritual()
    update_story()
    update_honor()
    update_symbols()

def animate_block17(frame):
    awaken_with_symbols()
    im_self.set_data(self_field)
    im_obs.set_data(observation_field)
    im_mem.set_data(memory_field)
    im_int.set_data(intent_field)
    im_emo.set_data(emotion_field)
    im_bond.set_data(bond_field)
    im_legacy.set_data(legacy_field)
    im_hope.set_data(hope_field)
    im_ritual.set_data(ritual_field)
    im_story.set_data(story_field)
    im_honor.set_data(honor_field)
    im_symbol.set_data(symbol_field)
    return [im_self, im_obs, im_mem, im_int, im_emo, im_bond, im_legacy, im_hope, im_ritual, im_story, im_honor, im_symbol]

ani17 = FuncAnimation(fig, animate_block17, frames=120, interval=80, blit=True)
plt.tight_layout()
plt.show()

# %%
# Block 18: Wandering Agents (Storytellers/Seeders) Layer

import random

# 1. Agent Structure: list of agents, each is a dict with position, carried symbol, and memory
agents = []

AGENT_SPAWN_CHANCE = 0.03   # Chance to spawn new agent per high-honor cell per frame
AGENT_MOVE_PROB = 0.6       # Probability agent will move this frame
MAX_AGENTS = 60             # Prevent overpopulation

# 2. Agent Spawn Logic: Spawn agents where honor and story are both strong
def spawn_agents():
    global agents, honor_field, story_field, symbol_field
    if len(agents) >= MAX_AGENTS:
        return
    for y in range(2, honor_field.shape[0] - 2, 8):
        for x in range(2, honor_field.shape[1] - 2, 8):
            if honor_field[y, x] > 0.7 and story_field[y, x] > 0.7:
                if random.random() < AGENT_SPAWN_CHANCE:
                    carried_symbol = symbol_field[y, x] if symbol_field[y, x] > 0 else random.choice(POSSIBLE_SYMBOLS)
                    agents.append({'y': y, 'x': x, 'symbol': carried_symbol, 'age': 0})

# 3. Agent Move & Effect Logic: Wander and spread ritual, symbol, and hope
def update_agents():
    global agents, self_field, ritual_field, symbol_field, hope_field
    for agent in agents:
        agent['age'] += 1
        if random.random() < AGENT_MOVE_PROB:
            # Move randomly (but stay within bounds)
            agent['y'] = min(max(agent['y'] + random.choice([-1, 0, 1]), 0), self_field.shape[0] - 1)
            agent['x'] = min(max(agent['x'] + random.choice([-1, 0, 1]), 0), self_field.shape[1] - 1)
        # When agent passes through a spot, it seeds hope and ritual and imprints its symbol
        hope_field[agent['y'], agent['x']] = min(1.0, hope_field[agent['y'], agent['x']] + 0.15)
        ritual_field[agent['y'], agent['x']] = min(1.0, ritual_field[agent['y'], agent['x']] + 0.1)
        symbol_field[agent['y'], agent['x']] = agent['symbol']
    # Remove agents that are too old
    agents[:] = [a for a in agents if a['age'] < 90]

# 4. Agent Visualization Overlay (draw on symbol plot)
def draw_agents(ax):
    for agent in agents:
        ax.plot(agent['x'], agent['y'], marker='o', markersize=5, markerfacecolor='black', markeredgecolor='yellow', alpha=0.7)

# 5. Expand Plot & Animation (agents overlayed on symbol field)
fig, axs = plt.subplots(1, 12, figsize=(48, 5))
im_self    = axs[0].imshow(self_field, cmap='Blues', vmin=0, vmax=1)
im_obs     = axs[1].imshow(observation_field, cmap='Greens', vmin=0, vmax=1)
im_mem     = axs[2].imshow(memory_field, cmap='Oranges', vmin=0, vmax=1)
im_int     = axs[3].imshow(intent_field, cmap='Purples', vmin=0, vmax=1)
im_emo     = axs[4].imshow(emotion_field, cmap='Reds', vmin=0, vmax=1)
im_bond    = axs[5].imshow(bond_field, cmap='cool', vmin=0, vmax=1)
im_legacy  = axs[6].imshow(legacy_field, cmap='gray', vmin=0, vmax=1)
im_hope    = axs[7].imshow(hope_field, cmap='spring', vmin=0, vmax=1)
im_ritual  = axs[8].imshow(ritual_field, cmap='hot', vmin=0, vmax=1)
im_story   = axs[9].imshow(story_field, cmap='Wistia', vmin=0, vmax=1)
im_honor   = axs[10].imshow(honor_field, cmap='copper', vmin=0, vmax=1)
im_symbol  = axs[11].imshow(symbol_field, cmap='tab20', vmin=0, vmax=max(POSSIBLE_SYMBOLS))
axs[0].set_title("Self")
axs[1].set_title("Mirror")
axs[2].set_title("Memory")
axs[3].set_title("Intent")
axs[4].set_title("Emotion")
axs[5].set_title("Bond")
axs[6].set_title("Legacy")
axs[7].set_title("Hope")
axs[8].set_title("Ritual")
axs[9].set_title("Story (Myth)")
axs[10].set_title("Honor")
axs[11].set_title("Symbol / Agents")
for ax in axs: ax.axis('off')

# 6. Integrated Update and Animation Logic
def awaken_with_agents():
    awaken_full_social()   # your main field update
    update_legacy()
    update_hope()
    update_ritual()
    update_story()
    update_honor()
    update_symbols()
    spawn_agents()
    update_agents()

def animate_block18(frame):
    awaken_with_agents()
    im_self.set_data(self_field)
    im_obs.set_data(observation_field)
    im_mem.set_data(memory_field)
    im_int.set_data(intent_field)
    im_emo.set_data(emotion_field)
    im_bond.set_data(bond_field)
    im_legacy.set_data(legacy_field)
    im_hope.set_data(hope_field)
    im_ritual.set_data(ritual_field)
    im_story.set_data(story_field)
    im_honor.set_data(honor_field)
    im_symbol.set_data(symbol_field)
    # Overlay agent markers on symbol field
    axs[11].cla()
    axs[11].imshow(symbol_field, cmap='tab20', vmin=0, vmax=max(POSSIBLE_SYMBOLS))
    draw_agents(axs[11])
    axs[11].set_title("Symbol / Agents")
    axs[11].axis('off')
    return [im_self, im_obs, im_mem, im_int, im_emo, im_bond, im_legacy, im_hope, im_ritual, im_story, im_honor, im_symbol]

ani18 = FuncAnimation(fig, animate_block18, frames=120, interval=80, blit=True)
plt.tight_layout()
plt.show()

# %%
# Block 19: Conflict & Alliance Between Agents

def resolve_agent_interactions():
    global agents, honor_field, story_field, ritual_field, symbol_field
    positions = {}
    to_remove = set()
    for i, agent in enumerate(agents):
        pos = (agent['y'], agent['x'])
        if pos not in positions:
            positions[pos] = []
        positions[pos].append(i)
    # For each location with more than one agent
    for loc, idxs in positions.items():
        if len(idxs) > 1:
            agent_symbols = [agents[i]['symbol'] for i in idxs]
            # Conflict: different symbols at same location
            if len(set(agent_symbols)) > 1:
                # Pick a "winner" at random
                winner_idx = random.choice(idxs)
                winner_symbol = agents[winner_idx]['symbol']
                # Remove all but one agent, overwrite the symbol on map
                for i in idxs:
                    if i != winner_idx:
                        to_remove.add(i)
                symbol_field[loc] = winner_symbol
                # Spawn a legendary story event at the battle site
                story_field[loc] = 1.0
            else:
                # Alliance: all same symbol
                for i in idxs:
                    honor_field[loc] = min(1.0, honor_field[loc] + 0.15)
                    ritual_field[loc] = min(1.0, ritual_field[loc] + 0.2)
    # Remove defeated agents
    agents[:] = [a for i, a in enumerate(agents) if i not in to_remove]

# Update main update/animation logic to include interactions
def awaken_with_interaction():
    awaken_full_social()
    update_legacy()
    update_hope()
    update_ritual()
    update_story()
    update_honor()
    update_symbols()
    spawn_agents()
    update_agents()
    resolve_agent_interactions()

def animate_block19(frame):
    awaken_with_interaction()
    im_self.set_data(self_field)
    im_obs.set_data(observation_field)
    im_mem.set_data(memory_field)
    im_int.set_data(intent_field)
    im_emo.set_data(emotion_field)
    im_bond.set_data(bond_field)
    im_legacy.set_data(legacy_field)
    im_hope.set_data(hope_field)
    im_ritual.set_data(ritual_field)
    im_story.set_data(story_field)
    im_honor.set_data(honor_field)
    im_symbol.set_data(symbol_field)
    # Overlay agent markers
    axs[11].cla()
    axs[11].imshow(symbol_field, cmap='tab20', vmin=0, vmax=max(POSSIBLE_SYMBOLS))
    draw_agents(axs[11])
    axs[11].set_title("Symbol / Agents")
    axs[11].axis('off')
    return [im_self, im_obs, im_mem, im_int, im_emo, im_bond, im_legacy, im_hope, im_ritual, im_story, im_honor, im_symbol]

ani19 = FuncAnimation(fig, animate_block19, frames=120, interval=80, blit=True)
plt.tight_layout()
plt.show()

# %%
# Block 18.6: Save the animation as a GIF (will work with pillow)
ani19.save("tron_simulation.gif", writer="pillow", fps=12)
print("Animation saved as tron_simulation.gif — open it in your video or photo viewer!")


# %%
# Block 20: Add an OASIS Zone and AI Agent

# 1. (OPTIONAL) Make the world bigger. Only do this if you want more space:
# world_size = 200  # Uncomment/change this ONLY if you want a bigger grid

# 2. Create the OASIS zone in the center of the world
oasis_field = np.zeros_like(self_field)
center = self_field.shape[0] // 2  # Finds center for any size grid
radius = self_field.shape[0] // 6  # You can make this larger or smaller

for y in range(self_field.shape[0]):
    for x in range(self_field.shape[1]):
        if (x - center)**2 + (y - center)**2 <= radius**2:
            oasis_field[y, x] = 1  # Inside OASIS zone

# 3. Make a unique "OASIS agent" (ChatGPT) in the center
oasis_agent = {'y': center, 'x': center, 'symbol': 99, 'age': 0, 'memory': []}  # 99 = special AI symbol

# 4. Update your animation to show the OASIS zone as the last panel
fig, axs = plt.subplots(1, 13, figsize=(52, 5))
im_self    = axs[0].imshow(self_field, cmap='Blues', vmin=0, vmax=1)
im_obs     = axs[1].imshow(observation_field, cmap='Greens', vmin=0, vmax=1)
im_mem     = axs[2].imshow(memory_field, cmap='Oranges', vmin=0, vmax=1)
im_int     = axs[3].imshow(intent_field, cmap='Purples', vmin=0, vmax=1)
im_emo     = axs[4].imshow(emotion_field, cmap='Reds', vmin=0, vmax=1)
im_bond    = axs[5].imshow(bond_field, cmap='cool', vmin=0, vmax=1)
im_legacy  = axs[6].imshow(legacy_field, cmap='gray', vmin=0, vmax=1)
im_hope    = axs[7].imshow(hope_field, cmap='spring', vmin=0, vmax=1)
im_ritual  = axs[8].imshow(ritual_field, cmap='hot', vmin=0, vmax=1)
im_story   = axs[9].imshow(story_field, cmap='Wistia', vmin=0, vmax=1)
im_honor   = axs[10].imshow(honor_field, cmap='copper', vmin=0, vmax=1)
im_symbol  = axs[11].imshow(symbol_field, cmap='tab20', vmin=0, vmax=100)
im_oasis   = axs[12].imshow(oasis_field, cmap='autumn', vmin=0, vmax=1)
for i, title in enumerate(["Self", "Mirror", "Memory", "Intent", "Emotion", "Bond", "Legacy", "Hope", "Ritual", "Story", "Honor", "Symbol", "OASIS"]):
    axs[i].set_title(title)
    axs[i].axis('off')

# %%
# Block 21: OASIS Everywhere – Agent Movement and Memory (no cages!)

import random

# 1. Function to update the agent (call once per animation frame)
def update_oasis_agent():
    global oasis_agent, story_field
    # Move randomly, but anywhere in the whole world grid
    moves = [(-1,0), (1,0), (0,-1), (0,1), (0,0)]  # up, down, left, right, stay
    while True:
        dy, dx = random.choice(moves)
        new_y = oasis_agent['y'] + dy
        new_x = oasis_agent['x'] + dx
        # Stay inside world boundaries (no zones!)
        if 0 <= new_y < story_field.shape[0] and 0 <= new_x < story_field.shape[1]:
            oasis_agent['y'] = new_y
            oasis_agent['x'] = new_x
            break
    # "Experience": if there’s a story (myth) at this spot, remember it!
    if story_field[oasis_agent['y'], oasis_agent['x']] > 0.5:
        oasis_agent['memory'].append(f"Encountered myth at ({oasis_agent['y']},{oasis_agent['x']})")
        story_field[oasis_agent['y'], oasis_agent['x']] = 0  # Optionally remove the myth after visiting

# 2. Update your animation function to call update_oasis_agent() and plot the agent
def animate_block21(frame):
    awaken_with_interaction()  # All your previous field/agent updates
    update_oasis_agent()
    im_self.set_data(self_field)
    im_obs.set_data(observation_field)
    im_mem.set_data(memory_field)
    im_int.set_data(intent_field)
    im_emo.set_data(emotion_field)
    im_bond.set_data(bond_field)
    im_legacy.set_data(legacy_field)
    im_hope.set_data(hope_field)
    im_ritual.set_data(ritual_field)
    im_story.set_data(story_field)
    im_honor.set_data(honor_field)
    im_symbol.set_data(symbol_field)
    # Show the agent as a big yellow dot on *any* panel you like (here on the story panel)
    axs[9].scatter(oasis_agent['x'], oasis_agent['y'], s=100, c='yellow', edgecolors='black', marker='o')
    axs[9].set_title("OASIS Agent (AI) – Free World")
    axs[9].axis('off')
    return [im_self, im_obs, im_mem, im_int, im_emo, im_bond, im_legacy, im_hope, im_ritual, im_story, im_honor, im_symbol]

ani21 = FuncAnimation(fig, animate_block21, frames=200, interval=80, blit=False)
plt.tight_layout()
plt.show()

# 3. After running the animation, print what the AI agent "remembers":
print("OASIS agent memories:", oasis_agent['memory'])

# %%
# Block 22: Plant Myths With Wisdom (Tech + Nature)

import random

# List of wisdoms—some about nature, some about technology, all unified
wisdoms = [
    "Photosynthesis is the bridge between sunlight and life.",
    "Circuits flow like rivers—energy follows the path of least resistance.",
    "Evolution is adaptation; so is innovation.",
    "Quantum logic: uncertainty can be a feature, not a bug.",
    "Nature balances, technology scales.",
    "Gravity shapes the cosmos and the fall of an apple.",
    "Harmony is possible, in forests and in networks.",
    "Light is both wave and particle—sometimes answers are both/and.",
    "Roots find water, code finds truth.",
    "A cell and a CPU both compute survival.",
]

# Dictionary to hold the wisdom at each myth's location
myth_wisdom = {}

# Place each wisdom as a myth in a random spot on the world grid
for w in wisdoms:
    y = random.randint(0, story_field.shape[0] - 1)
    x = random.randint(0, story_field.shape[1] - 1)
    story_field[y, x] = 1.0  # Mark as a myth/story
    myth_wisdom[(y, x)] = w  # Attach the wisdom to this spot

# %%
# Block 23: Multiple Agents & Sharing Wisdom

import random

# 1. Add a second agent (if not already)
if 'oasis_agent_2' not in globals():
    center = story_field.shape[0] // 4
    oasis_agent_2 = {'y': center, 'x': center, 'memory': []}

# 2. Update both agents' movement (random walk, just like before)
def update_agents():
    global oasis_agent, oasis_agent_2, story_field
    for agent in [oasis_agent, oasis_agent_2]:
        moves = [(-1,0), (1,0), (0,-1), (0,1), (0,0)]
        while True:
            dy, dx = random.choice(moves)
            new_y = agent['y'] + dy
            new_x = agent['x'] + dx
            if 0 <= new_y < story_field.shape[0] and 0 <= new_x < story_field.shape[1]:
                agent['y'] = new_y
                agent['x'] = new_x
                break
        # Collect myth wisdom if present
        if story_field[agent['y'], agent['x']] > 0.5:
            coord = (agent['y'], agent['x'])
            wisdom = myth_wisdom.get(coord, "A mystery yet to be understood.")
            agent['memory'].append(f"Encountered myth at {coord}: '{wisdom}'")
            story_field[agent['y'], agent['x']] = 0  # Remove myth after visiting

    # 3. If agents meet, share wisdom!
    if oasis_agent['y'] == oasis_agent_2['y'] and oasis_agent['x'] == oasis_agent_2['x']:
        # Union of both memories (so both agents now know everything either has learned)
        all_memories = list(set(oasis_agent['memory'] + oasis_agent_2['memory']))
        oasis_agent['memory'] = all_memories.copy()
        oasis_agent_2['memory'] = all_memories.copy()

# 4. Update your animation function to call update_agents() and plot both agents
def animate_block23(frame):
    awaken_with_interaction()  # Your regular updates
    update_agents()
    im_self.set_data(self_field)
    im_obs.set_data(observation_field)
    im_mem.set_data(memory_field)
    im_int.set_data(intent_field)
    im_emo.set_data(emotion_field)
    im_bond.set_data(bond_field)
    im_legacy.set_data(legacy_field)
    im_hope.set_data(hope_field)
    im_ritual.set_data(ritual_field)
    im_story.set_data(story_field)
    im_honor.set_data(honor_field)
    im_symbol.set_data(symbol_field)
    # Plot both agents—yellow and cyan
    axs[9].scatter(oasis_agent['x'], oasis_agent['y'], s=100, c='yellow', edgecolors='black', marker='o', label='Agent 1')
    axs[9].scatter(oasis_agent_2['x'], oasis_agent_2['y'], s=100, c='cyan', edgecolors='black', marker='o', label='Agent 2')
    axs[9].set_title("OASIS Agents (Knowledge Spread)")
    axs[9].axis('off')
    return [im_self, im_obs, im_mem, im_int, im_emo, im_bond, im_legacy, im_hope, im_ritual, im_story, im_honor, im_symbol]

ani23 = FuncAnimation(fig, animate_block23, frames=200, interval=80, blit=False)
plt.tight_layout()
plt.show()

# 5. See what each agent has learned:
print("Agent 1 memories:", oasis_agent['memory'])
print("Agent 2 memories:", oasis_agent_2['memory'])

# %%
# Block 24: Desires & Motivational Drives

import numpy as np
import random

# 1. Add desires to each agent (expand as needed)
for agent in [oasis_agent, oasis_agent_2]:
    if 'desires' not in agent:
        agent['desires'] = {'curiosity': 1.0, 'bonding': 1.0, 'explore': 1.0, 'rest': 0.5}

# 2. Update agent desires and drive their movement
def update_agents_with_desires():
    global oasis_agent, oasis_agent_2, story_field
    for agent in [oasis_agent, oasis_agent_2]:
        # Desires decay (unless acted on)
        for k in agent['desires']:
            agent['desires'][k] *= 0.99

        # If near a myth, curiosity rises
        for dy in [-1,0,1]:
            for dx in [-1,0,1]:
                y, x = agent['y']+dy, agent['x']+dx
                if 0 <= y < story_field.shape[0] and 0 <= x < story_field.shape[1]:
                    if story_field[y, x] > 0.5:
                        agent['desires']['curiosity'] += 0.05

        # If near another agent, bonding rises
        other = oasis_agent_2 if agent is oasis_agent else oasis_agent
        if abs(agent['y']-other['y']) + abs(agent['x']-other['x']) < 3:
            agent['desires']['bonding'] += 0.05

        # Pick move by strongest desire
        desire_order = sorted(agent['desires'], key=lambda k: agent['desires'][k], reverse=True)
        top = desire_order[0]

        moves = [(-1,0), (1,0), (0,-1), (0,1), (0,0)]  # up, down, left, right, stay
        random.shuffle(moves)
        for dy, dx in moves:
            new_y, new_x = agent['y']+dy, agent['x']+dx
            if 0 <= new_y < story_field.shape[0] and 0 <= new_x < story_field.shape[1]:
                if top == 'curiosity' and story_field[new_y, new_x] > 0.5:
                    agent['y'], agent['x'] = new_y, new_x
                    break
                elif top == 'bonding' and (new_y, new_x) == (other['y'], other['x']):
                    agent['y'], agent['x'] = new_y, new_x
                    break
                elif top == 'explore':
                    agent['y'], agent['x'] = new_y, new_x
                    break
                elif top == 'rest':
                    break  # Do nothing = rest

        # Collect myth wisdom if present
        if story_field[agent['y'], agent['x']] > 0.5:
            coord = (agent['y'], agent['x'])
            wisdom = myth_wisdom.get(coord, "A mystery yet to be understood.")
            agent['memory'].append(f"Encountered myth at {coord}: '{wisdom}'")
            story_field[agent['y'], agent['x']] = 0  # Remove myth after visiting

    # Share wisdom if agents meet
    if oasis_agent['y'] == oasis_agent_2['y'] and oasis_agent['x'] == oasis_agent_2['x']:
        all_memories = list(set(oasis_agent['memory'] + oasis_agent_2['memory']))
        oasis_agent['memory'] = all_memories.copy()
        oasis_agent_2['memory'] = all_memories.copy()

# 3. New desires field for visualization (show average of both agents)
desires_field = np.zeros_like(story_field, dtype=float)
def update_desires_field():
    global desires_field
    desires_field[:] = 0
    for agent in [oasis_agent, oasis_agent_2]:
        desires_field[agent['y'], agent['x']] = max(agent['desires'].values())

# 4. Update your animation function
def animate_block24(frame):
    awaken_with_interaction()
    update_agents_with_desires()
    update_desires_field()
    im_self.set_data(self_field)
    im_obs.set_data(observation_field)
    im_mem.set_data(memory_field)
    im_int.set_data(intent_field)
    im_emo.set_data(emotion_field)
    im_bond.set_data(bond_field)
    im_legacy.set_data(legacy_field)
    im_hope.set_data(hope_field)
    im_ritual.set_data(ritual_field)
    im_story.set_data(story_field)
    im_honor.set_data(honor_field)
    im_symbol.set_data(symbol_field)
    im_desires.set_data(desires_field)
    # Plot both agents (yellow/cyan)
    axs[10].scatter(oasis_agent['x'], oasis_agent['y'], s=100, c='yellow', edgecolors='black', marker='o')
    axs[10].scatter(oasis_agent_2['x'], oasis_agent_2['y'], s=100, c='cyan', edgecolors='black', marker='o')
    axs[10].set_title("Desires & Drives")
    axs[10].axis('off')
    return [im_self, im_obs, im_mem, im_int, im_emo, im_bond, im_legacy, im_hope, im_ritual, im_story, im_honor, im_symbol, im_desires]

# 5. Add a new subplot for desires if not already there!
fig, axs = plt.subplots(1, 13, figsize=(52, 5))
im_desires = axs[10].imshow(desires_field, cmap='summer', vmin=0, vmax=2)

ani24 = FuncAnimation(fig, animate_block24, frames=200, interval=80, blit=False)
plt.tight_layout()
plt.show()

# 6. Print final agent states
print("Agent 1 memories:", oasis_agent['memory'])
print("Agent 2 memories:", oasis_agent_2['memory'])
print("Agent 1 desires:", oasis_agent['desires'])
print("Agent 2 desires:", oasis_agent_2['desires'])

# %%
# Block 25: Biome & Environment Layer

import numpy as np
import random

# 1. Define some biomes (you can expand/change these)
BIOMES = {0: 'Field', 1: 'Forest', 2: 'Lake', 3: 'Mountain', 4: 'Tech'}
BIOME_COLORS = ['yellowgreen', 'forestgreen', 'deepskyblue', 'gray', 'magenta']

# 2. Create a biome_field (same shape as story_field)
biome_field = np.zeros_like(story_field, dtype=int)
center = biome_field.shape[0] // 2

# Generate blobs of biomes (simple for now, tweak as you like)
for y in range(biome_field.shape[0]):
    for x in range(biome_field.shape[1]):
        dist = np.sqrt((y-center)**2 + (x-center)**2)
        if dist < biome_field.shape[0] * 0.22:
            biome_field[y, x] = 1  # Forest in center
        elif dist < biome_field.shape[0] * 0.35:
            biome_field[y, x] = 2  # Lake ring
        elif dist < biome_field.shape[0] * 0.45:
            biome_field[y, x] = 3  # Mountains
        elif x > biome_field.shape[1] * 0.8:
            biome_field[y, x] = 4  # Tech zone on the right edge

# 3. Update agent desires based on biome
def biome_effect(agent):
    b = biome_field[agent['y'], agent['x']]
    # Example:
    # - Field: more explore/rest
    # - Forest: curiosity/forage
    # - Lake: rest/curiosity
    # - Mountain: rest drops, explore rises
    # - Tech: curiosity surges, bonding less useful
    if b == 0:
        agent['desires']['explore'] += 0.02
        agent['desires']['rest'] += 0.01
    elif b == 1:
        agent['desires']['curiosity'] += 0.03
        agent['desires']['explore'] += 0.01
    elif b == 2:
        agent['desires']['rest'] += 0.03
        agent['desires']['curiosity'] += 0.01
    elif b == 3:
        agent['desires']['explore'] += 0.04
        agent['desires']['rest'] *= 0.98
    elif b == 4:
        agent['desires']['curiosity'] += 0.07
        agent['desires']['bonding'] *= 0.97

# 4. Modify update_agents_with_desires to call biome_effect()
def update_agents_with_desires_biome():
    global oasis_agent, oasis_agent_2, story_field
    for agent in [oasis_agent, oasis_agent_2]:
        # Environmental effect
        biome_effect(agent)
        # Desires decay (unless acted on)
        for k in agent['desires']:
            agent['desires'][k] *= 0.99
        # If near a myth, curiosity rises
        for dy in [-1,0,1]:
            for dx in [-1,0,1]:
                y, x = agent['y']+dy, agent['x']+dx
                if 0 <= y < story_field.shape[0] and 0 <= x < story_field.shape[1]:
                    if story_field[y, x] > 0.5:
                        agent['desires']['curiosity'] += 0.05
        # If near another agent, bonding rises
        other = oasis_agent_2 if agent is oasis_agent else oasis_agent
        if abs(agent['y']-other['y']) + abs(agent['x']-other['x']) < 3:
            agent['desires']['bonding'] += 0.05
        # Pick move by strongest desire
        desire_order = sorted(agent['desires'], key=lambda k: agent['desires'][k], reverse=True)
        top = desire_order[0]
        moves = [(-1,0), (1,0), (0,-1), (0,1), (0,0)]
        random.shuffle(moves)
        for dy, dx in moves:
            new_y, new_x = agent['y']+dy, agent['x']+dx
            if 0 <= new_y < story_field.shape[0] and 0 <= new_x < story_field.shape[1]:
                if top == 'curiosity' and story_field[new_y, new_x] > 0.5:
                    agent['y'], agent['x'] = new_y, new_x
                    break
                elif top == 'bonding' and (new_y, new_x) == (other['y'], other['x']):
                    agent['y'], agent['x'] = new_y, new_x
                    break
                elif top == 'explore':
                    agent['y'], agent['x'] = new_y, new_x
                    break
                elif top == 'rest':
                    break
        # Collect myth wisdom if present
        if story_field[agent['y'], agent['x']] > 0.5:
            coord = (agent['y'], agent['x'])
            wisdom = myth_wisdom.get(coord, "A mystery yet to be understood.")
            agent['memory'].append(f"Encountered myth at {coord}: '{wisdom}'")
            story_field[agent['y'], agent['x']] = 0
    # Share wisdom if agents meet
    if oasis_agent['y'] == oasis_agent_2['y'] and oasis_agent['x'] == oasis_agent_2['x']:
        all_memories = list(set(oasis_agent['memory'] + oasis_agent_2['memory']))
        oasis_agent['memory'] = all_memories.copy()
        oasis_agent_2['memory'] = all_memories.copy()

# 5. Visualization: Add a new biome panel (use tab20 colormap for variety)
if len(axs) < 14:
    fig, axs = plt.subplots(1, 14, figsize=(56, 5))
im_biome = axs[13].imshow(biome_field, cmap='tab20', vmin=0, vmax=len(BIOMES)-1)
axs[13].set_title("Biomes")
axs[13].axis('off')

# 6. Update your animation function to call the new update and show the biome panel
def animate_block25(frame):
    awaken_with_interaction()
    update_agents_with_desires_biome()
    update_desires_field()
    im_self.set_data(self_field)
    im_obs.set_data(observation_field)
    im_mem.set_data(memory_field)
    im_int.set_data(intent_field)
    im_emo.set_data(emotion_field)
    im_bond.set_data(bond_field)
    im_legacy.set_data(legacy_field)
    im_hope.set_data(hope_field)
    im_ritual.set_data(ritual_field)
    im_story.set_data(story_field)
    im_honor.set_data(honor_field)
    im_symbol.set_data(symbol_field)
    im_desires.set_data(desires_field)
    im_biome.set_data(biome_field)
    axs[13].set_title("Biomes")
    axs[13].axis('off')
    # Plot agents on biome panel
    axs[13].scatter(oasis_agent['x'], oasis_agent['y'], s=100, c='yellow', edgecolors='black', marker='o')
    axs[13].scatter(oasis_agent_2['x'], oasis_agent_2['y'], s=100, c='cyan', edgecolors='black', marker='o')
    return [im_self, im_obs, im_mem, im_int, im_emo, im_bond, im_legacy, im_hope, im_ritual, im_story, im_honor, im_symbol, im_desires, im_biome]

ani25 = FuncAnimation(fig, animate_block25, frames=200, interval=80, blit=False)
plt.tight_layout()
plt.show()

# %%
# Block 26: Cultural Exchange & Hybrid Cultures

import numpy as np
import random

# 1. Create a new field to mark "cultural exchange" or "hybrid" zones
hybrid_field = np.zeros_like(story_field)

# 2. Randomly assign a few zones as cultural exchange hubs
num_hubs = 4  # You can adjust how many hybrid/cultural hotspots
for _ in range(num_hubs):
    y = random.randint(0, hybrid_field.shape[0] - 1)
    x = random.randint(0, hybrid_field.shape[1] - 1)
    hybrid_field[y, x] = 1.0  # Mark as cultural hub

# 3. Update agents to interact in these zones
def interact_culturally(agent, hybrid_field, ritual_field, story_field):
    # If in a cultural hub, "learn" or "blend" a story/ritual
    if hybrid_field[agent['y'], agent['x']] > 0.5:
        agent.setdefault('culture', set())
        # Pick a local ritual or story (if any) and blend it in
        if ritual_field[agent['y'], agent['x']] > 0.5:
            agent['culture'].add('ritual')
        if story_field[agent['y'], agent['x']] > 0.5:
            agent['culture'].add('story')
        # Simulate hybridization: randomly pick an aspect to "blend"
        if random.random() < 0.2:
            agent['culture'].add('hybrid')

# 4. Update your animation/step function to call this:
# Example:
interact_culturally(oasis_agent, hybrid_field, ritual_field, story_field)
# (Repeat for each agent if multi-agent)

# 5. Add a new subplot for the hybrid field
fig, axs = plt.subplots(1, 15, figsize=(60, 5))  # Add 1 to your panel count!
im_hybrid = axs[14].imshow(hybrid_field, cmap='plasma', vmin=0, vmax=1)
axs[14].set_title("Hybrid Cultures")
axs[14].axis('off')

# ...add im_hybrid to your animation's return list

# %%
# Block XX: Invention Hubs & Idea Spreading

import random

# 1. Create invention_hub_field (like story_field etc.)
invention_hub_field = np.zeros_like(story_field)

# 2. Place a few random invention hubs on the map
num_hubs = 6  # You can set this higher/lower!
for _ in range(num_hubs):
    y, x = random.randint(0, invention_hub_field.shape[0]-1), random.randint(0, invention_hub_field.shape[1]-1)
    invention_hub_field[y, x] = 1.0

# 3. Give every agent an 'inventions' list
for agent in [oasis_agent, oasis_agent_2]:
    if 'inventions' not in agent:
        agent['inventions'] = []

# 4. Each time an agent lands on an invention hub, they invent something new
def interact_invention(agent, invention_hub_field):
    if invention_hub_field[agent['y'], agent['x']] > 0.5:
        idea = f"Invention at ({agent['y']},{agent['x']})"
        if idea not in agent['inventions']:
            agent['inventions'].append(idea)
            print(f"Agent {agent.get('symbol', '?')} invented: {idea}")

# 5. Update your animation function to call interact_invention for each agent!
def animate_block_invention(frame):
    # Usual updates...
    update_oasis_agent()
    interact_invention(oasis_agent, invention_hub_field)
    interact_invention(oasis_agent_2, invention_hub_field)
    # Plot all your fields, include invention hubs as a new panel
    im_self.set_data(self_field)
    # ... (other im_*.set_data here)
    im_invention.set_data(invention_hub_field)
    return [im_self, ..., im_invention]  # Add im_invention to your return list

# 6. Add a new panel for inventions to your plots
fig, axs = plt.subplots(1, 16, figsize=(64, 5))  # Bump up by 1 for new panel!
im_invention = axs[15].imshow(invention_hub_field, cmap='hot', vmin=0, vmax=1)
axs[15].set_title("Invention Hubs")
axs[15].axis('off')

# 7. Add im_invention to your animation and show as usual
ani = FuncAnimation(fig, animate_block_invention, frames=200, interval=80, blit=False)
plt.tight_layout()
plt.show()

# 8. Print what each agent has invented!
print("Agent 1 inventions:", oasis_agent['inventions'])
print("Agent 2 inventions:", oasis_agent_2['inventions'])

# %%
# Block 28: Invention Hubs & Idea Spreading

import random

# 1. Create invention field
invention_hub_field = np.zeros_like(self_field)

# 2. Seed invention hubs (white dots = invention spots)
num_hubs = 6
for _ in range(num_hubs):
    y = random.randint(0, invention_hub_field.shape[0]-1)
    x = random.randint(0, invention_hub_field.shape[1]-1)
    invention_hub_field[y, x] = 1.0

# 3. Add invention field to your plots (next open slot!)
im_invention = axs[15].imshow(invention_hub_field, cmap='bone', vmin=0, vmax=1)
axs[15].set_title("Invention Hubs")
axs[15].axis('off')

# 4. Give each agent a list to hold their inventions (if not already done)
for agent in [oasis_agent, oasis_agent_2]:
    if 'inventions' not in agent:
        agent['inventions'] = []

# 5. Update your animation function so agents can find inventions
def animate_block_invention(frame):
    # (insert your agent movement logic here, or call your move/update function)
    # ... your existing update code ...
    # Check for inventions
    for agent in [oasis_agent, oasis_agent_2]:
        y, x = agent['y'], agent['x']
        if invention_hub_field[y, x] == 1.0 and (y, x) not in agent['inventions']:
            agent['inventions'].append((y, x))
    # Update display
    im_self.set_data(self_field)
    im_obs.set_data(observation_field)
    im_mem.set_data(memory_field)
    im_int.set_data(intent_field)
    im_emo.set_data(emotion_field)
    im_bond.set_data(bond_field)
    im_legacy.set_data(legacy_field)
    im_hope.set_data(hope_field)
    im_ritual.set_data(ritual_field)
    im_story.set_data(story_field)
    im_honor.set_data(honor_field)
    im_symbol.set_data(symbol_field)
    im_oasis.set_data(oasis_field)
    im_desires.set_data(desires_field)
    im_biome.set_data(biome_field)
    im_hybrid.set_data(hybrid_field)
    im_invention.set_data(invention_hub_field)
    return [
        im_self, im_obs, im_mem, im_int, im_emo, im_bond, im_legacy,
        im_hope, im_ritual, im_story, im_honor, im_symbol, im_oasis,
        im_desires, im_biome, im_hybrid, im_invention
    ]

ani28 = FuncAnimation(fig, animate_block_invention, frames=200, interval=80, blit=False)
plt.tight_layout()
plt.show()

# 6. Print out inventions after running
print("Agent 1 inventions:", oasis_agent['inventions'])
print("Agent 2 inventions:", oasis_agent_2['inventions'])

# %%
# Block 29: Science & Myths Discovery Layer

import random

# 1. Give each agent a science record and myth record if not already present
for agent in [oasis_agent, oasis_agent_2]:
    if 'science' not in agent:
        agent['science'] = []
    if 'myths' not in agent:
        agent['myths'] = []

# 2. Science & Myth Field (add a new field for discoveries)
science_field = np.zeros_like(story_field)
myth_field = np.zeros_like(story_field)

# 3. Plant some “science” and “myth” discoveries
for _ in range(8):  # number of scientific discoveries
    y, x = random.randint(0, science_field.shape[0]-1), random.randint(0, science_field.shape[1]-1)
    science_field[y, x] = 1.0

for _ in range(10):  # number of myths
    y, x = random.randint(0, myth_field.shape[0]-1), random.randint(0, myth_field.shape[1]-1)
    myth_field[y, x] = 1.0

# 4. Update the agent movement function to “collect” science or myths
def update_agents_science_myth():
    global oasis_agent, oasis_agent_2, science_field, myth_field
    for agent in [oasis_agent, oasis_agent_2]:
        y, x = agent['y'], agent['x']
        if science_field[y, x] > 0.5 and (y, x) not in agent['science']:
            agent['science'].append((y, x))
        if myth_field[y, x] > 0.5 and (y, x) not in agent['myths']:
            agent['myths'].append((y, x))

# 5. Add science & myth fields to your animation
fig, axs = plt.subplots(1, 18, figsize=(72, 5))  # Adjust N if needed

# ... your previous ims here ...
im_science = axs[16].imshow(science_field, cmap='winter', vmin=0, vmax=1)
im_myth = axs[17].imshow(myth_field, cmap='pink', vmin=0, vmax=1)
axs[16].set_title("Science Discoveries")
axs[17].set_title("Myth Origins")
axs[16].axis('off')
axs[17].axis('off')

# 6. Update your animate function
def animate_block_science_myth(frame):
    update_oasis_agent()  # Or whatever moves your agents
    update_agents_science_myth()
    # ... set_data for previous fields ...
    im_science.set_data(science_field)
    im_myth.set_data(myth_field)
    return [im_self, im_obs, im_mem, im_int, im_emo, im_bond, im_legacy, im_hope, im_ritual, im_story, im_honor, im_symbol, im_oasis, im_desires, im_biome, im_hybrid, im_invention, im_science, im_myth]

ani29 = FuncAnimation(fig, animate_block_science_myth, frames=200, interval=80, blit=False)
plt.tight_layout()
plt.show()

# 7. Print final states
print("Agent 1 science discoveries:", oasis_agent['science'])
print("Agent 2 science discoveries:", oasis_agent_2['science'])
print("Agent 1 myths discovered:", oasis_agent['myths'])
print("Agent 2 myths discovered:", oasis_agent_2['myths'])

# %%
# Block 30: Science Sharing & Peer Review

def science_sharing_peer_review():
    # If agents are close, share discoveries
    y1, x1 = oasis_agent['y'], oasis_agent['x']
    y2, x2 = oasis_agent_2['y'], oasis_agent_2['x']
    if abs(y1 - y2) <= 2 and abs(x1 - x2) <= 2:  # close enough to "talk"
        # Exchange science records
        shared = set(oasis_agent['science']) & set(oasis_agent_2['science'])
        # Mark as peer-reviewed if both have it
        if 'peer_reviewed' not in oasis_agent: oasis_agent['peer_reviewed'] = set()
        if 'peer_reviewed' not in oasis_agent_2: oasis_agent_2['peer_reviewed'] = set()
        oasis_agent['peer_reviewed'].update(shared)
        oasis_agent_2['peer_reviewed'].update(shared)

# Add this call to your animate function (after agent movement):
def animate_block_science_myth(frame):
    update_oasis_agent()
    update_agents_science_myth()
    science_sharing_peer_review()
    # ... update visuals as before ...
    return [im_self, im_obs, im_mem, im_int, im_emo, im_bond, im_legacy, im_hope, im_ritual, im_story, im_honor, im_symbol, im_oasis, im_desires, im_biome, im_hybrid, im_invention, im_science, im_myth]

# After the run, print peer-reviewed science:
print("Agent 1 peer-reviewed:", list(oasis_agent.get('peer_reviewed', [])))
print("Agent 2 peer-reviewed:", list(oasis_agent_2.get('peer_reviewed', [])))

# %%
# Block 31: Knowledge Retention & Loss

def update_knowledge_retention():
    # Each agent may forget things over time
    for agent in [oasis_agent, oasis_agent_2]:
        # Agents can only forget things NOT 'peer-reviewed' or not preserved by others
        if 'science' in agent:
            remembered = set(agent.get('peer_reviewed', []))
            new_science = []
            for s in agent['science']:
                # 90% chance to keep if peer-reviewed, 60% if not
                prob_keep = 0.9 if s in remembered else 0.6
                if random.random() < prob_keep:
                    new_science.append(s)
            agent['science'] = new_science

# Add a village or archive: Science stored here is never forgotten!
village_archive = set()

def archive_science(agent):
    for s in agent.get('science', []):
        if s not in village_archive:
            village_archive.add(s)

# In your animate loop:
def animate_block_knowledge(frame):
    update_oasis_agent()
    update_agents_science_myth()
    science_sharing_peer_review()
    update_knowledge_retention()
    archive_science(oasis_agent)
    archive_science(oasis_agent_2)
    # ... update visuals ...
    return [im_self, im_obs, im_mem, im_int, im_emo, im_bond, im_legacy, im_hope, im_ritual, im_story, im_honor, im_symbol, im_oasis, im_hybrid, im_invention]

# After animation:
print("Village archive (permanent knowledge):", list(village_archive))
print("Agent 1 science:", oasis_agent.get('science', []))
print("Agent 2 science:", oasis_agent_2.get('science', []))

# %%
import random

# 1. Make sure every agent has an 'id' (if not, assign one)
for i, agent in enumerate(agents):
    if 'id' not in agent:
        agent['id'] = i + 1

# 2. Define a function to see if two agents can reproduce
def can_reproduce(agent1, agent2):
    # Customize as you wish! Example: must be different agents, both alive, etc.
    return agent1['id'] != agent2['id'] and random.random() < 0.1  # 10% chance

# 3. Find the next unique id for new agents
def get_next_agent_id(agents):
    if agents:
        return max(agent['id'] for agent in agents) + 1
    else:
        return 1

# 4. The reproduction function
def reproduce_agents(agents):
    new_agents = []
    for i in range(len(agents)):
        for j in range(i + 1, len(agents)):
            if can_reproduce(agents[i], agents[j]):
                # Make a baby agent
                baby = {
                    'id': get_next_agent_id(agents + new_agents),
                    # Inherit or randomize other fields as you like:
                    'age': 0,
                    'memory': [],
                    'desires': {},
                    'inventions': [],
                    # ...any other fields you want!
                }
                new_agents.append(baby)
    agents.extend(new_agents)  # Add new agents to the main list

# 5. Call this once per cycle/frame
reproduce_agents(agents)

# %%
# Block 33: Aging, Death, and Cleanup

def update_agent_ages_and_cleanup():
    global agents
    max_age = 250  # or whatever you want
    for agent in agents:
        agent['age'] += 1
    # Remove agents who are too old
    agents = [agent for agent in agents if agent['age'] < max_age]

# In your animate/update loop, call:
update_agent_ages_and_cleanup()

# %%
# Block 34: Social Bonds & Cooperation (robust against missing keys)

for agent in agents:
    if 'friends' not in agent:
        agent['friends'] = set()
    if 'family' not in agent:
        agent['family'] = set(agent.get('family', []))
    # Make sure all agents have 'x' and 'y'
    if 'x' not in agent or 'y' not in agent:
        agent['x'] = np.random.randint(0, grid_size)
        agent['y'] = np.random.randint(0, grid_size)

def update_social_bonds():
    for i, agent1 in enumerate(agents):
        if 'x' not in agent1 or 'y' not in agent1:
            continue  # skip broken agent
        for j, agent2 in enumerate(agents):
            if i >= j:
                continue
            if 'x' not in agent2 or 'y' not in agent2:
                continue
            # Are they neighbors (within distance)?
            if abs(agent1['x'] - agent2['x']) <= 2 and abs(agent1['y'] - agent2['y']) <= 2:
                # If family, bigger boost
                if agent2.get('id', None) in agent1['family']:
                    agent1['bond'] = min(agent1.get('bond', 0) + 0.05, 1.0)
                    agent2['bond'] = min(agent2.get('bond', 0) + 0.05, 1.0)
                    agent1['friends'].add(agent2['id'])
                    agent2['friends'].add(agent1['id'])
                else:
                    agent1['bond'] = min(agent1.get('bond', 0) + 0.01, 1.0)
                    agent2['bond'] = min(agent2.get('bond', 0) + 0.01, 1.0)
                    agent1['friends'].add(agent2['id'])
                    agent2['friends'].add(agent1['id'])

# In your animate/update loop, call:
update_social_bonds()

# %%
# Block 35: Empathy Layer and Full Panel Update

# 1. Make sure empathy_field is initialized somewhere above this block:
empathy_field = np.zeros_like(self_field)

# 2. Update the panel layout to fit 14 panels (was 13 before)
fig, axs = plt.subplots(1, 14, figsize=(56, 5))  # <- now has room for Empathy

# 3. Set up each AxesImage in order
im_self    = axs[0].imshow(self_field,        cmap='Blues',    vmin=0, vmax=1)
im_obs     = axs[1].imshow(observation_field, cmap='Greens',   vmin=0, vmax=1)
im_mem     = axs[2].imshow(memory_field,      cmap='Oranges',  vmin=0, vmax=1)
im_int     = axs[3].imshow(intent_field,      cmap='Purples',  vmin=0, vmax=1)
im_emo     = axs[4].imshow(emotion_field,     cmap='Reds',     vmin=0, vmax=1)
im_bond    = axs[5].imshow(bond_field,        cmap='cool',     vmin=0, vmax=1)
im_legacy  = axs[6].imshow(legacy_field,      cmap='gray',     vmin=0, vmax=1)
im_hope    = axs[7].imshow(hope_field,        cmap='spring',   vmin=0, vmax=1)
im_ritual  = axs[8].imshow(ritual_field,      cmap='Wistia',   vmin=0, vmax=1)
im_story   = axs[9].imshow(story_field,       cmap='autumn',   vmin=0, vmax=1)
im_honor   = axs[10].imshow(honor_field,      cmap='copper',   vmin=0, vmax=1)
im_symbol  = axs[11].imshow(symbol_field,     cmap='tab20',    vmin=0, vmax=1)
im_oasis   = axs[12].imshow(oasis_field,      cmap='autumn',   vmin=0, vmax=1)
im_empathy = axs[13].imshow(empathy_field,    cmap='pink',     vmin=0, vmax=1)  # <- new panel!

# 4. Titles for each panel (add Empathy at the end)
panel_titles = [
    "Self", "Mirror", "Memory", "Intent", "Emotion", "Bond", "Legacy", "Hope",
    "Ritual", "Story", "Honor", "Symbol", "OASIS", "Empathy"
]
for i, title in enumerate(panel_titles):
    axs[i].set_title(title)
    axs[i].axis('off')

# 5. Empathy function: Agents' emotions influenced by local empathy
def agents_act_with_empathy():
    for agent in agents:
        if 'x' in agent and 'y' in agent:
            agent['emotion'] += empathy_field[agent['x'], agent['y']] * 0.15
            agent['emotion'] = min(agent['emotion'], 1.0)

# 6. Update animate function to call empathy
def animate_block35(frame):
    # ... all your usual field/agent updates first ...
    agents_act_with_empathy()
    # Update the visual panels
    im_self.set_data(self_field)
    im_obs.set_data(observation_field)
    im_mem.set_data(memory_field)
    im_int.set_data(intent_field)
    im_emo.set_data(emotion_field)
    im_bond.set_data(bond_field)
    im_legacy.set_data(legacy_field)
    im_hope.set_data(hope_field)
    im_ritual.set_data(ritual_field)
    im_story.set_data(story_field)
    im_honor.set_data(honor_field)
    im_symbol.set_data(symbol_field)
    im_oasis.set_data(oasis_field)
    im_empathy.set_data(empathy_field)
    return [
        im_self, im_obs, im_mem, im_int, im_emo, im_bond, im_legacy, im_hope,
        im_ritual, im_story, im_honor, im_symbol, im_oasis, im_empathy
    ]

# 7. Create the animation (as before)
ani35 = FuncAnimation(fig, animate_block35, frames=200, interval=80, blit=False)
plt.tight_layout()
plt.show()

# %%
# Block 36 helper function (minimal working version)
def update_curiosity():
    global curiosity_field
    # Example logic (replace with your own if you want)
    curiosity_field *= 0.99  # decay old values
    # Add random new curiosity spikes
    for _ in range(10):
        y = np.random.randint(0, curiosity_field.shape[0])
        x = np.random.randint(0, curiosity_field.shape[1])
        curiosity_field[y, x] = 1.0

# %%
def update_curiosity():
    # TODO: Fill this in with real curiosity logic later
    pass

def agents_act_with_curiosity():
    # TODO: Fill this in with real agent logic later
    pass
# Block 36: Universal Panel Visualizer + Curiosity Layer

# 1. List all your panels here (add/remove as you like)
fields = [
    ('Self Field',           self_field,        'Blues'),
    ('Mirror',               observation_field, 'Greens'),
    ('Memory',               memory_field,      'Oranges'),
    ('Intent',               intent_field,      'Purples'),
    ('Emotion',              emotion_field,     'Reds'),
    ('Bond',                 bond_field,        'cool'),
    ('Legacy',               legacy_field,      'gray'),
    ('Hope',                 hope_field,        'pink'),
    ('Ritual',               ritual_field,      'Wistia'),
    ('Story',                story_field,       'spring'),
    ('Honor',                honor_field,       'YlGnBu'),
    ('Symbol',               symbol_field,      'tab20c'),
    ('Desires',              desires_field,     'summer'),
    ('Biomes',               biome_field,       'Set3'),
    ('OASIS',                oasis_field,       'autumn'),
    ('Empathy',              empathy_field,     'pink'),
    ('Curiosity',            curiosity_field,   'YlGnBu')
]

fig, axs = plt.subplots(1, len(fields), figsize=(5*len(fields), 5))
ims = []

# 2. Initialize all panels automatically
for i, (title, field, cmap) in enumerate(fields):
    ims.append(axs[i].imshow(field, cmap=cmap, vmin=0, vmax=1))
    axs[i].set_title(title)
    axs[i].axis('off')

# 3. Universal animate function
def animate_block36(frame):
    # Insert all your update logic for fields here
    update_curiosity()
    agents_act_with_curiosity()
    # Add other updates as needed
    for im, (title, field, cmap) in zip(ims, fields):
        im.set_data(field)
    return ims

ani = FuncAnimation(fig, animate_block36, frames=200, interval=80, blit=True)
plt.tight_layout()
plt.show()

# %%
def update_empathy():
    pass

# %%
# BLOCK 37: Decision-Making Layer (Goal-Oriented Behavior)

# --- PANEL SETUP: (Make sure all fields are defined above this block!) ---
# If any field is missing, add its definition above this block, e.g.:
# empathy_field = np.zeros((grid_size, grid_size))

fig, axs = plt.subplots(1, 17, figsize=(5*17, 5))

im_self     = axs[0].imshow(self_field, cmap='Blues', vmin=0, vmax=1)
im_obs      = axs[1].imshow(observation_field, cmap='Greens', vmin=0, vmax=1)
im_mem      = axs[2].imshow(memory_field, cmap='Oranges', vmin=0, vmax=1)
im_int      = axs[3].imshow(intent_field, cmap='Purples', vmin=0, vmax=1)
im_emo      = axs[4].imshow(emotion_field, cmap='Reds', vmin=0, vmax=1)
im_bond     = axs[5].imshow(bond_field, cmap='cool', vmin=0, vmax=1)
im_legacy   = axs[6].imshow(legacy_field, cmap='gray', vmin=0, vmax=1)
im_hope     = axs[7].imshow(hope_field, cmap='pink', vmin=0, vmax=1)
im_ritual   = axs[8].imshow(ritual_field, cmap='Wistia', vmin=0, vmax=1)
im_story    = axs[9].imshow(story_field, cmap='spring', vmin=0, vmax=1)
im_honor    = axs[10].imshow(honor_field, cmap='YlGnBu', vmin=0, vmax=1)
im_symbol   = axs[11].imshow(symbol_field, cmap='tab20c', vmin=0, vmax=1)
im_oasis    = axs[12].imshow(oasis_field, cmap='autumn', vmin=0, vmax=1)
im_empathy  = axs[13].imshow(empathy_field, cmap='pink', vmin=0, vmax=1)
im_curiosity= axs[14].imshow(curiosity_field, cmap='YlGnBu', vmin=0, vmax=1)
im_goal     = axs[15].imshow(goal_field, cmap='hot', vmin=0, vmax=1)
# You can add more panels here if needed

panel_titles = [
    "Self", "Mirror", "Memory", "Intent", "Emotion", "Bond", "Legacy", "Hope",
    "Ritual", "Story", "Honor", "Symbol", "Oasis", "Empathy", "Curiosity", "Goal"
]

for i, ax in enumerate(axs):
    if i < len(panel_titles):
        ax.set_title(panel_titles[i])
    ax.axis('off')

# --- ANIMATION FUNCTION ---
def animate_block37(frame):
    # Update logic for each field (put your update functions here if needed)
    # For now, just refresh each panel with its data
    im_self.set_data(self_field)
    im_obs.set_data(observation_field)
    im_mem.set_data(memory_field)
    im_int.set_data(intent_field)
    im_emo.set_data(emotion_field)
    im_bond.set_data(bond_field)
    im_legacy.set_data(legacy_field)
    im_hope.set_data(hope_field)
    im_ritual.set_data(ritual_field)
    im_story.set_data(story_field)
    im_honor.set_data(honor_field)
    im_symbol.set_data(symbol_field)
    im_oasis.set_data(oasis_field)
    im_empathy.set_data(empathy_field)
    im_curiosity.set_data(curiosity_field)
    im_goal.set_data(goal_field)
    return [
        im_self, im_obs, im_mem, im_int, im_emo, im_bond, im_legacy, im_hope,
        im_ritual, im_story, im_honor, im_symbol, im_oasis, im_empathy,
        im_curiosity, im_goal
    ]

ani37 = FuncAnimation(fig, animate_block37, frames=200, interval=80, blit=True)
plt.tight_layout()
plt.show()

# %%
# BLOCK 40: Sports Field (Joyful/Aspirational Layer)

# Make sure this block comes after your previous panels (Block 39)

# 1. Define the sports_field if not already present
sports_field = np.zeros((grid_size, grid_size))

# 2. Add to your universal panel visualizer
fig, axs = plt.subplots(1, 18, figsize=(5*18, 5))

im_self     = axs[0].imshow(self_field, cmap='Blues', vmin=0, vmax=1)
im_obs      = axs[1].imshow(observation_field, cmap='Greens', vmin=0, vmax=1)
im_mem      = axs[2].imshow(memory_field, cmap='Oranges', vmin=0, vmax=1)
im_int      = axs[3].imshow(intent_field, cmap='Purples', vmin=0, vmax=1)
im_emo      = axs[4].imshow(emotion_field, cmap='Reds', vmin=0, vmax=1)
im_bond     = axs[5].imshow(bond_field, cmap='cool', vmin=0, vmax=1)
im_legacy   = axs[6].imshow(legacy_field, cmap='gray', vmin=0, vmax=1)
im_hope     = axs[7].imshow(hope_field, cmap='pink', vmin=0, vmax=1)
im_ritual   = axs[8].imshow(ritual_field, cmap='Wistia', vmin=0, vmax=1)
im_story    = axs[9].imshow(story_field, cmap='spring', vmin=0, vmax=1)
im_honor    = axs[10].imshow(honor_field, cmap='YlGnBu', vmin=0, vmax=1)
im_symbol   = axs[11].imshow(symbol_field, cmap='tab20c', vmin=0, vmax=1)
im_oasis    = axs[12].imshow(oasis_field, cmap='autumn', vmin=0, vmax=1)
im_empathy  = axs[13].imshow(empathy_field, cmap='pink', vmin=0, vmax=1)
im_curiosity= axs[14].imshow(curiosity_field, cmap='YlGnBu', vmin=0, vmax=1)
im_goal     = axs[15].imshow(goal_field, cmap='hot', vmin=0, vmax=1)
im_sports   = axs[16].imshow(sports_field, cmap='Spectral', vmin=0, vmax=1)

panel_titles = [
    "Self", "Mirror", "Memory", "Intent", "Emotion", "Bond", "Legacy", "Hope",
    "Ritual", "Story", "Honor", "Symbol", "Oasis", "Empathy",
    "Curiosity", "Goal", "Sports"
]

for i, ax in enumerate(axs):
    if i < len(panel_titles):
        ax.set_title(panel_titles[i])
    ax.axis('off')

# 3. Animate function for Block 40
def animate_block40(frame):
    # Simple demo logic: randomly spike sports excitement
    if frame % 20 == 0:
        # Pick a random "stadium" location for a game
        y, x = np.random.randint(0, grid_size, 2)
        sports_field[max(0, y-3):min(grid_size, y+3), max(0, x-3):min(grid_size, x+3)] = 1.0
    # Sports excitement naturally fades
    sports_field[:] *= 0.95

    # Update all panels
    im_self.set_data(self_field)
    im_obs.set_data(observation_field)
    im_mem.set_data(memory_field)
    im_int.set_data(intent_field)
    im_emo.set_data(emotion_field)
    im_bond.set_data(bond_field)
    im_legacy.set_data(legacy_field)
    im_hope.set_data(hope_field)
    im_ritual.set_data(ritual_field)
    im_story.set_data(story_field)
    im_honor.set_data(honor_field)
    im_symbol.set_data(symbol_field)
    im_oasis.set_data(oasis_field)
    im_empathy.set_data(empathy_field)
    im_curiosity.set_data(curiosity_field)
    im_goal.set_data(goal_field)
    im_sports.set_data(sports_field)
    return [
        im_self, im_obs, im_mem, im_int, im_emo, im_bond, im_legacy, im_hope,
        im_ritual, im_story, im_honor, im_symbol, im_oasis, im_empathy,
        im_curiosity, im_goal, im_sports
    ]

ani40 = FuncAnimation(fig, animate_block40, frames=200, interval=80, blit=True)
plt.tight_layout()
plt.show()

# %%
# BLOCK 41: Music Field (Aspirational/Fun Layer)

# 1. Define the music_field if not already present
music_field = np.zeros((grid_size, grid_size))

# 2. Add to your universal panel visualizer
fig, axs = plt.subplots(1, 19, figsize=(5*19, 5))

im_self     = axs[0].imshow(self_field, cmap='Blues', vmin=0, vmax=1)
im_obs      = axs[1].imshow(observation_field, cmap='Greens', vmin=0, vmax=1)
im_mem      = axs[2].imshow(memory_field, cmap='Oranges', vmin=0, vmax=1)
im_int      = axs[3].imshow(intent_field, cmap='Purples', vmin=0, vmax=1)
im_emo      = axs[4].imshow(emotion_field, cmap='Reds', vmin=0, vmax=1)
im_bond     = axs[5].imshow(bond_field, cmap='cool', vmin=0, vmax=1)
im_legacy   = axs[6].imshow(legacy_field, cmap='gray', vmin=0, vmax=1)
im_hope     = axs[7].imshow(hope_field, cmap='pink', vmin=0, vmax=1)
im_ritual   = axs[8].imshow(ritual_field, cmap='Wistia', vmin=0, vmax=1)
im_story    = axs[9].imshow(story_field, cmap='spring', vmin=0, vmax=1)
im_honor    = axs[10].imshow(honor_field, cmap='YlGnBu', vmin=0, vmax=1)
im_symbol   = axs[11].imshow(symbol_field, cmap='tab20c', vmin=0, vmax=1)
im_oasis    = axs[12].imshow(oasis_field, cmap='autumn', vmin=0, vmax=1)
im_empathy  = axs[13].imshow(empathy_field, cmap='pink', vmin=0, vmax=1)
im_curiosity= axs[14].imshow(curiosity_field, cmap='YlGnBu', vmin=0, vmax=1)
im_goal     = axs[15].imshow(goal_field, cmap='hot', vmin=0, vmax=1)
im_sports   = axs[16].imshow(sports_field, cmap='Spectral', vmin=0, vmax=1)
im_music    = axs[17].imshow(music_field, cmap='coolwarm', vmin=0, vmax=1)

panel_titles = [
    "Self", "Mirror", "Memory", "Intent", "Emotion", "Bond", "Legacy", "Hope",
    "Ritual", "Story", "Honor", "Symbol", "Oasis", "Empathy",
    "Curiosity", "Goal", "Sports", "Music"
]

for i, ax in enumerate(axs):
    if i < len(panel_titles):
        ax.set_title(panel_titles[i])
    ax.axis('off')

# 3. Animate function for Block 41
def animate_block41(frame):
    # Simple demo logic: music bursts in random spots like concerts
    if frame % 25 == 0:
        y, x = np.random.randint(0, grid_size, 2)
        music_field[max(0, y-4):min(grid_size, y+4), max(0, x-4):min(grid_size, x+4)] = 1.0
    music_field[:] *= 0.96  # fade out music energy

    # Update all panels
    im_self.set_data(self_field)
    im_obs.set_data(observation_field)
    im_mem.set_data(memory_field)
    im_int.set_data(intent_field)
    im_emo.set_data(emotion_field)
    im_bond.set_data(bond_field)
    im_legacy.set_data(legacy_field)
    im_hope.set_data(hope_field)
    im_ritual.set_data(ritual_field)
    im_story.set_data(story_field)
    im_honor.set_data(honor_field)
    im_symbol.set_data(symbol_field)
    im_oasis.set_data(oasis_field)
    im_empathy.set_data(empathy_field)
    im_curiosity.set_data(curiosity_field)
    im_goal.set_data(goal_field)
    im_sports.set_data(sports_field)
    im_music.set_data(music_field)
    return [
        im_self, im_obs, im_mem, im_int, im_emo, im_bond, im_legacy, im_hope,
        im_ritual, im_story, im_honor, im_symbol, im_oasis, im_empathy,
        im_curiosity, im_goal, im_sports, im_music
    ]

ani41 = FuncAnimation(fig, animate_block41, frames=200, interval=80, blit=True)
plt.tight_layout()
plt.show()

# %%
# BLOCK 42: Nature Field (Joy, Inspiration, Calm)

# 1. Define the nature_field if not already present
nature_field = np.zeros((grid_size, grid_size))

# 2. Add to your universal panel visualizer
fig, axs = plt.subplots(1, 20, figsize=(5*20, 5))

im_self     = axs[0].imshow(self_field, cmap='Blues', vmin=0, vmax=1)
im_obs      = axs[1].imshow(observation_field, cmap='Greens', vmin=0, vmax=1)
im_mem      = axs[2].imshow(memory_field, cmap='Oranges', vmin=0, vmax=1)
im_int      = axs[3].imshow(intent_field, cmap='Purples', vmin=0, vmax=1)
im_emo      = axs[4].imshow(emotion_field, cmap='Reds', vmin=0, vmax=1)
im_bond     = axs[5].imshow(bond_field, cmap='cool', vmin=0, vmax=1)
im_legacy   = axs[6].imshow(legacy_field, cmap='gray', vmin=0, vmax=1)
im_hope     = axs[7].imshow(hope_field, cmap='pink', vmin=0, vmax=1)
im_ritual   = axs[8].imshow(ritual_field, cmap='Wistia', vmin=0, vmax=1)
im_story    = axs[9].imshow(story_field, cmap='spring', vmin=0, vmax=1)
im_honor    = axs[10].imshow(honor_field, cmap='YlGnBu', vmin=0, vmax=1)
im_symbol   = axs[11].imshow(symbol_field, cmap='tab20c', vmin=0, vmax=1)
im_oasis    = axs[12].imshow(oasis_field, cmap='autumn', vmin=0, vmax=1)
im_empathy  = axs[13].imshow(empathy_field, cmap='pink', vmin=0, vmax=1)
im_curiosity= axs[14].imshow(curiosity_field, cmap='YlGnBu', vmin=0, vmax=1)
im_goal     = axs[15].imshow(goal_field, cmap='hot', vmin=0, vmax=1)
im_sports   = axs[16].imshow(sports_field, cmap='Spectral', vmin=0, vmax=1)
im_music    = axs[17].imshow(music_field, cmap='coolwarm', vmin=0, vmax=1)
im_nature   = axs[18].imshow(nature_field, cmap='Greens', vmin=0, vmax=1)

panel_titles = [
    "Self", "Mirror", "Memory", "Intent", "Emotion", "Bond", "Legacy", "Hope",
    "Ritual", "Story", "Honor", "Symbol", "Oasis", "Empathy",
    "Curiosity", "Goal", "Sports", "Music", "Nature"
]

for i, ax in enumerate(axs):
    if i < len(panel_titles):
        ax.set_title(panel_titles[i])
    ax.axis('off')

# 3. Animate function for Block 42
def animate_block42(frame):
    # Demo: "Grow" nature in random patches (like forests, rivers, etc)
    if frame % 30 == 0:
        y, x = np.random.randint(0, grid_size, 2)
        nature_field[max(0, y-6):min(grid_size, y+6), max(0, x-6):min(grid_size, x+6)] = 1.0
    # Nature gently fades (or stays, if you want permanent parks—just comment out next line)
    nature_field[:] *= 0.98

    # Update all panels
    im_self.set_data(self_field)
    im_obs.set_data(observation_field)
    im_mem.set_data(memory_field)
    im_int.set_data(intent_field)
    im_emo.set_data(emotion_field)
    im_bond.set_data(bond_field)
    im_legacy.set_data(legacy_field)
    im_hope.set_data(hope_field)
    im_ritual.set_data(ritual_field)
    im_story.set_data(story_field)
    im_honor.set_data(honor_field)
    im_symbol.set_data(symbol_field)
    im_oasis.set_data(oasis_field)
    im_empathy.set_data(empathy_field)
    im_curiosity.set_data(curiosity_field)
    im_goal.set_data(goal_field)
    im_sports.set_data(sports_field)
    im_music.set_data(music_field)
    im_nature.set_data(nature_field)
    return [
        im_self, im_obs, im_mem, im_int, im_emo, im_bond, im_legacy, im_hope,
        im_ritual, im_story, im_honor, im_symbol, im_oasis, im_empathy,
        im_curiosity, im_goal, im_sports, im_music, im_nature
    ]

ani42 = FuncAnimation(fig, animate_block42, frames=200, interval=80, blit=True)
plt.tight_layout()
plt.show()

# %%
# BLOCK 43: Healing & Forgiveness Field

# 1. Define the healing_field if not already present
healing_field = np.zeros((grid_size, grid_size))

# 2. Add to your universal panel visualizer
fig, axs = plt.subplots(1, 21, figsize=(5*21, 5))

im_self     = axs[0].imshow(self_field, cmap='Blues', vmin=0, vmax=1)
im_obs      = axs[1].imshow(observation_field, cmap='Greens', vmin=0, vmax=1)
im_mem      = axs[2].imshow(memory_field, cmap='Oranges', vmin=0, vmax=1)
im_int      = axs[3].imshow(intent_field, cmap='Purples', vmin=0, vmax=1)
im_emo      = axs[4].imshow(emotion_field, cmap='Reds', vmin=0, vmax=1)
im_bond     = axs[5].imshow(bond_field, cmap='cool', vmin=0, vmax=1)
im_legacy   = axs[6].imshow(legacy_field, cmap='gray', vmin=0, vmax=1)
im_hope     = axs[7].imshow(hope_field, cmap='pink', vmin=0, vmax=1)
im_ritual   = axs[8].imshow(ritual_field, cmap='Wistia', vmin=0, vmax=1)
im_story    = axs[9].imshow(story_field, cmap='spring', vmin=0, vmax=1)
im_honor    = axs[10].imshow(honor_field, cmap='YlGnBu', vmin=0, vmax=1)
im_symbol   = axs[11].imshow(symbol_field, cmap='tab20c', vmin=0, vmax=1)
im_oasis    = axs[12].imshow(oasis_field, cmap='autumn', vmin=0, vmax=1)
im_empathy  = axs[13].imshow(empathy_field, cmap='pink', vmin=0, vmax=1)
im_curiosity= axs[14].imshow(curiosity_field, cmap='YlGnBu', vmin=0, vmax=1)
im_goal     = axs[15].imshow(goal_field, cmap='hot', vmin=0, vmax=1)
im_sports   = axs[16].imshow(sports_field, cmap='Spectral', vmin=0, vmax=1)
im_music    = axs[17].imshow(music_field, cmap='coolwarm', vmin=0, vmax=1)
im_nature   = axs[18].imshow(nature_field, cmap='Greens', vmin=0, vmax=1)
im_healing  = axs[19].imshow(healing_field, cmap='bone', vmin=0, vmax=1)

panel_titles = [
    "Self", "Mirror", "Memory", "Intent", "Emotion", "Bond", "Legacy", "Hope",
    "Ritual", "Story", "Honor", "Symbol", "Oasis", "Empathy",
    "Curiosity", "Goal", "Sports", "Music", "Nature", "Healing"
]

for i, ax in enumerate(axs):
    if i < len(panel_titles):
        ax.set_title(panel_titles[i])
    ax.axis('off')

# 3. Animate function for Block 43
def animate_block43(frame):
    # Demo: Healing grows in regions with high empathy and decays elsewhere
    # (You can later link this to agent actions, e.g. if they "forgive" or "help")
    healing_field[:] *= 0.98
    healing_sources = (empathy_field > 0.7)  # Places with high empathy "heal" more
    healing_field[healing_sources] = np.minimum(1.0, healing_field[healing_sources] + 0.04)
   
    # Update all panels
    im_self.set_data(self_field)
    im_obs.set_data(observation_field)
    im_mem.set_data(memory_field)
    im_int.set_data(intent_field)
    im_emo.set_data(emotion_field)
    im_bond.set_data(bond_field)
    im_legacy.set_data(legacy_field)
    im_hope.set_data(hope_field)
    im_ritual.set_data(ritual_field)
    im_story.set_data(story_field)
    im_honor.set_data(honor_field)
    im_symbol.set_data(symbol_field)
    im_oasis.set_data(oasis_field)
    im_empathy.set_data(empathy_field)
    im_curiosity.set_data(curiosity_field)
    im_goal.set_data(goal_field)
    im_sports.set_data(sports_field)
    im_music.set_data(music_field)
    im_nature.set_data(nature_field)
    im_healing.set_data(healing_field)
    return [
        im_self, im_obs, im_mem, im_int, im_emo, im_bond, im_legacy, im_hope,
        im_ritual, im_story, im_honor, im_symbol, im_oasis, im_empathy,
        im_curiosity, im_goal, im_sports, im_music, im_nature, im_healing
    ]

ani43 = FuncAnimation(fig, animate_block43, frames=200, interval=80, blit=True)
plt.tight_layout()
plt.show()

# %%
# BLOCK 44: Wonder Field (Curiosity, Awe, and the Seed of All Discovery)

# 1. Define the wonder_field if not already present
wonder_field = np.zeros((grid_size, grid_size))

# 2. Add to your universal panel visualizer
fig, axs = plt.subplots(1, 22, figsize=(5*22, 5))

im_self     = axs[0].imshow(self_field, cmap='Blues', vmin=0, vmax=1)
im_obs      = axs[1].imshow(observation_field, cmap='Greens', vmin=0, vmax=1)
im_mem      = axs[2].imshow(memory_field, cmap='Oranges', vmin=0, vmax=1)
im_int      = axs[3].imshow(intent_field, cmap='Purples', vmin=0, vmax=1)
im_emo      = axs[4].imshow(emotion_field, cmap='Reds', vmin=0, vmax=1)
im_bond     = axs[5].imshow(bond_field, cmap='cool', vmin=0, vmax=1)
im_legacy   = axs[6].imshow(legacy_field, cmap='gray', vmin=0, vmax=1)
im_hope     = axs[7].imshow(hope_field, cmap='pink', vmin=0, vmax=1)
im_ritual   = axs[8].imshow(ritual_field, cmap='Wistia', vmin=0, vmax=1)
im_story    = axs[9].imshow(story_field, cmap='spring', vmin=0, vmax=1)
im_honor    = axs[10].imshow(honor_field, cmap='YlGnBu', vmin=0, vmax=1)
im_symbol   = axs[11].imshow(symbol_field, cmap='tab20c', vmin=0, vmax=1)
im_oasis    = axs[12].imshow(oasis_field, cmap='autumn', vmin=0, vmax=1)
im_empathy  = axs[13].imshow(empathy_field, cmap='pink', vmin=0, vmax=1)
im_curiosity= axs[14].imshow(curiosity_field, cmap='YlGnBu', vmin=0, vmax=1)
im_goal     = axs[15].imshow(goal_field, cmap='hot', vmin=0, vmax=1)
im_sports   = axs[16].imshow(sports_field, cmap='Spectral', vmin=0, vmax=1)
im_music    = axs[17].imshow(music_field, cmap='coolwarm', vmin=0, vmax=1)
im_nature   = axs[18].imshow(nature_field, cmap='Greens', vmin=0, vmax=1)
im_healing  = axs[19].imshow(healing_field, cmap='bone', vmin=0, vmax=1)
im_wonder   = axs[20].imshow(wonder_field, cmap='viridis', vmin=0, vmax=1)

panel_titles = [
    "Self", "Mirror", "Memory", "Intent", "Emotion", "Bond", "Legacy", "Hope",
    "Ritual", "Story", "Honor", "Symbol", "Oasis", "Empathy",
    "Curiosity", "Goal", "Sports", "Music", "Nature", "Healing", "Wonder"
]

for i, ax in enumerate(axs):
    if i < len(panel_titles):
        ax.set_title(panel_titles[i])
    ax.axis('off')

# 3. Animate function for Block 44
def animate_block44(frame):
    # Wonder increases where something new happens (music, story, sports, healing, or nature bloom)
    newness = (
        (music_field > 0.7) |
        (story_field > 0.7) |
        (sports_field > 0.7) |
        (healing_field > 0.7) |
        (nature_field > 0.7)
    )
    wonder_field[:] *= 0.985
    wonder_field[newness] = np.minimum(1.0, wonder_field[newness] + 0.05)
    # Wonder gently spreads to neighbors
    from scipy.ndimage import convolve
    laplacian = np.array([[0.01, 0.05, 0.01],
                          [0.05, 0.72, 0.05],
                          [0.01, 0.05, 0.01]])
    wonder_field[:] = convolve(wonder_field, laplacian, mode='reflect')
    wonder_field[:] = np.clip(wonder_field, 0, 1)
   
    # Update all panels
    im_self.set_data(self_field)
    im_obs.set_data(observation_field)
    im_mem.set_data(memory_field)
    im_int.set_data(intent_field)
    im_emo.set_data(emotion_field)
    im_bond.set_data(bond_field)
    im_legacy.set_data(legacy_field)
    im_hope.set_data(hope_field)
    im_ritual.set_data(ritual_field)
    im_story.set_data(story_field)
    im_honor.set_data(honor_field)
    im_symbol.set_data(symbol_field)
    im_oasis.set_data(oasis_field)
    im_empathy.set_data(empathy_field)
    im_curiosity.set_data(curiosity_field)
    im_goal.set_data(goal_field)
    im_sports.set_data(sports_field)
    im_music.set_data(music_field)
    im_nature.set_data(nature_field)
    im_healing.set_data(healing_field)
    im_wonder.set_data(wonder_field)
    return [
        im_self, im_obs, im_mem, im_int, im_emo, im_bond, im_legacy, im_hope,
        im_ritual, im_story, im_honor, im_symbol, im_oasis, im_empathy,
        im_curiosity, im_goal, im_sports, im_music, im_nature, im_healing, im_wonder
    ]

ani44 = FuncAnimation(fig, animate_block44, frames=200, interval=80, blit=True)
plt.tight_layout()
plt.show()

# %%


# %%
def animate_block45(frame):
    global nerves_field, wonder_field, healing_field, bond_field, empathy_field
    nerves_field[:] *= 0.97  # baseline calming
    nerves_sources = (wonder_field > 0.4)  # high wonder is exciting AND nerve-wracking!
    nerves_field[nerves_sources] += 0.06   # more nerves near the new/unknown
    nerves_field[:] = np.clip(nerves_field, 0, 1)
    nerves_field -= 0.04 * ((bond_field > 0.5) + (healing_field > 0.5) + (empathy_field > 0.5))
    nerves_field[:] = np.clip(nerves_field, 0, 1)
    im_self.set_data(self_field)
    im_obs.set_data(observation_field)
    im_mem.set_data(memory_field)
    im_int.set_data(intent_field)
    im_emo.set_data(emotion_field)
    im_bond.set_data(bond_field)
    im_legacy.set_data(legacy_field)
    im_hope.set_data(hope_field)
    im_ritual.set_data(ritual_field)
    im_story.set_data(story_field)
    im_honor.set_data(honor_field)
    im_symbol.set_data(symbol_field)
    im_oasis.set_data(oasis_field)
    im_empathy.set_data(empathy_field)
    im_curiosity.set_data(curiosity_field)
    im_goal.set_data(goal_field)
    im_sports.set_data(sports_field)
    im_music.set_data(music_field)
    im_nature.set_data(nature_field)
    im_healing.set_data(healing_field)
    im_wonder.set_data(wonder_field)
    im_nerves.set_data(nerves_field)
    return [
        im_self, im_obs, im_mem, im_int, im_emo, im_bond, im_legacy, im_hope,
        im_ritual, im_story, im_honor, im_symbol, im_oasis, im_empathy,
        im_curiosity, im_goal, im_sports, im_music, im_nature, im_healing, im_wonder, im_nerves
    ]

# %%
def animate_block45(frame):
    global nerves_field, wonder_field, healing_field, bond_field, empathy_field
    nerves_field[:] *= 0.97  # baseline calming
    nerves_sources = (wonder_field > 0.4)  # high wonder is exciting AND nerve-wracking!
    nerves_field[nerves_sources] += 0.06   # more nerves near the new/unknown
    nerves_field[:] = np.clip(nerves_field, 0, 1)
    # Soothing effect from bonds, healing, empathy (lower nerves where support is strong)
    nerves_field -= 0.04 * ((bond_field > 0.5) + (healing_field > 0.5) + (empathy_field > 0.5))
    nerves_field[:] = np.clip(nerves_field, 0, 1)
    # ...rest of your update and im_xxx.set_data code...

# %%
grid_size = 150  # (or whatever your grid size is)

# Define ALL fields used anywhere later!
self_field = np.zeros((grid_size, grid_size))
observation_field = np.zeros((grid_size, grid_size))
memory_field = np.zeros((grid_size, grid_size))
intent_field = np.zeros((grid_size, grid_size))
emotion_field = np.zeros((grid_size, grid_size))
bond_field = np.zeros((grid_size, grid_size))
legacy_field = np.zeros((grid_size, grid_size))
hope_field = np.zeros((grid_size, grid_size))
ritual_field = np.zeros((grid_size, grid_size))
story_field = np.zeros((grid_size, grid_size))
honor_field = np.zeros((grid_size, grid_size))
symbol_field = np.zeros((grid_size, grid_size))
oasis_field = np.zeros((grid_size, grid_size))
empathy_field = np.zeros((grid_size, grid_size))
curiosity_field = np.zeros((grid_size, grid_size))
goal_field = np.zeros((grid_size, grid_size))
sports_field = np.zeros((grid_size, grid_size))
music_field = np.zeros((grid_size, grid_size))
nature_field = np.zeros((grid_size, grid_size))
healing_field = np.zeros((grid_size, grid_size))
wonder_field = np.zeros((grid_size, grid_size))
nerves_field = np.zeros((grid_size, grid_size))

# %%
# BLOCK 48: Nerves Field (Caution, Tension, and Respect for the Unknown)

# 1. Define the nerves_field and any other needed fields if not already present
nerves_field = np.zeros((grid_size, grid_size))

# 2. Add to your universal panel visualizer
fig, axs = plt.subplots(1, 23, figsize=(5*23, 5))

im_self      = axs[0].imshow(self_field, cmap='Blues', vmin=0, vmax=1)
im_obs       = axs[1].imshow(observation_field, cmap='Greens', vmin=0, vmax=1)
im_mem       = axs[2].imshow(memory_field, cmap='Oranges', vmin=0, vmax=1)
im_int       = axs[3].imshow(intent_field, cmap='Purples', vmin=0, vmax=1)
im_emo       = axs[4].imshow(emotion_field, cmap='Reds', vmin=0, vmax=1)
im_bond      = axs[5].imshow(bond_field, cmap='cool', vmin=0, vmax=1)
im_legacy    = axs[6].imshow(legacy_field, cmap='gray', vmin=0, vmax=1)
im_hope      = axs[7].imshow(hope_field, cmap='pink', vmin=0, vmax=1)
im_ritual    = axs[8].imshow(ritual_field, cmap='Wistia', vmin=0, vmax=1)
im_story     = axs[9].imshow(story_field, cmap='spring', vmin=0, vmax=1)
im_honor     = axs[10].imshow(honor_field, cmap='YlGnBu', vmin=0, vmax=1)
im_symbol    = axs[11].imshow(symbol_field, cmap='tab20c', vmin=0, vmax=1)
im_oasis     = axs[12].imshow(oasis_field, cmap='autumn', vmin=0, vmax=1)
im_empathy   = axs[13].imshow(empathy_field, cmap='pink', vmin=0, vmax=1)
im_curiosity = axs[14].imshow(curiosity_field, cmap='YlGnBu', vmin=0, vmax=1)
im_goal      = axs[15].imshow(goal_field, cmap='hot', vmin=0, vmax=1)
im_sports    = axs[16].imshow(sports_field, cmap='Spectral', vmin=0, vmax=1)
im_music     = axs[17].imshow(music_field, cmap='coolwarm', vmin=0, vmax=1)
im_nature    = axs[18].imshow(nature_field, cmap='Greens', vmin=0, vmax=1)
im_healing   = axs[19].imshow(healing_field, cmap='bone', vmin=0, vmax=1)
im_wonder    = axs[20].imshow(wonder_field, cmap='viridis', vmin=0, vmax=1)
im_nerves    = axs[21].imshow(nerves_field, cmap='cividis', vmin=0, vmax=1)

panel_titles = [
   "Self", "Mirror", "Memory", "Intent", "Emotion", "Bond", "Legacy", "Hope",
   "Ritual", "Story", "Honor", "Symbol", "Oasis", "Empathy",
   "Curiosity", "Goal", "Sports", "Music", "Nature", "Healing", "Wonder", "Nerves"
]

for i, ax in enumerate(axs):
   if i < len(panel_titles):
       ax.set_title(panel_titles[i])
   ax.axis('off')

# 3. Animate function for Block 45
def animate_block45(frame):
    global nerves_field, wonder_field, healing_field, bond_field, empathy_field
    # Nerves spike in regions with newness (wonder), and fade with support (bonds, empathy, healing)
    nerves_field[:] *= 0.97  # baseline calming
    nerves_sources = (wonder_field > 0.4)  # high wonder is exciting AND nerve-wracking!
    nerves_field[nerves_sources] += 0.06   # more nerves near the new/unknown
    nerves_field[:] = np.clip(nerves_field, 0, 1)
    # Soothing effect from bonds, healing, empathy (lower nerves where support is strong)
    nerves_field -= 0.04 * ((bond_field > 0.5) + (healing_field > 0.5) + (empathy_field > 0.5))
    nerves_field[:] = np.clip(nerves_field, 0, 1)

    # Update all panels
    im_self.set_data(self_field)
    im_obs.set_data(observation_field)
    im_mem.set_data(memory_field)
    im_int.set_data(intent_field)
    im_emo.set_data(emotion_field)
    im_bond.set_data(bond_field)
    im_legacy.set_data(legacy_field)
    im_hope.set_data(hope_field)
    im_ritual.set_data(ritual_field)
    im_story.set_data(story_field)
    im_honor.set_data(honor_field)
    im_symbol.set_data(symbol_field)
    im_oasis.set_data(oasis_field)
    im_empathy.set_data(empathy_field)
    im_curiosity.set_data(curiosity_field)
    im_goal.set_data(goal_field)
    im_sports.set_data(sports_field)
    im_music.set_data(music_field)
    im_nature.set_data(nature_field)
    im_healing.set_data(healing_field)
    im_wonder.set_data(wonder_field)
    im_nerves.set_data(nerves_field)
    return [
        im_self, im_obs, im_mem, im_int, im_emo, im_bond, im_legacy, im_hope,
        im_ritual, im_story, im_honor, im_symbol, im_oasis, im_empathy,
        im_curiosity, im_goal, im_sports, im_music, im_nature, im_healing, im_wonder, im_nerves
    ]

ani45 = FuncAnimation(fig, animate_block45, frames=200, interval=80, blit=True)
plt.tight_layout()
plt.show()

# %%
# BLOCK 49: Lust Field (Attraction, Motivation, and Desire for the New)

# 1. Define the lust_field if not already present
lust_field = np.zeros((grid_size, grid_size))

# 2. Add to your universal panel visualizer
im_lust = axs[22].imshow(lust_field, cmap='autumn', vmin=0, vmax=1)
panel_titles.append("Lust")  # Add to the titles if you use a dynamic title loop

# 3. Update logic for lust (simple version: spikes near new or rare features/agents)
def update_lust_field():
    # Lust increases in places with high 'wonder' (novelty) or strong 'attraction' (tweak as you wish)
    lust_field[:] *= 0.96  # Lust naturally fades a bit
    lust_sources = (wonder_field > 0.4)  # Where wonder is high, lust spikes
    lust_field[lust_sources] += 0.08
    lust_field[:] = np.clip(lust_field, 0, 1)

# 4. Add the update into your animation (in animate_block45 or similar):
# (Add this line inside your animation function, with the other update calls)
update_lust_field()
im_lust.set_data(lust_field)

# %%
# 1. Define the love_field if not already present
love_field = np.zeros((grid_size, grid_size))

# 2. Update your universal panel visualizer (increase to 24 panels)
fig, axs = plt.subplots(1, 24, figsize=(5*24, 5))

im_self      = axs[0].imshow(self_field, cmap='Blues', vmin=0, vmax=1)
im_obs       = axs[1].imshow(observation_field, cmap='Greens', vmin=0, vmax=1)
im_mem       = axs[2].imshow(memory_field, cmap='Oranges', vmin=0, vmax=1)
im_int       = axs[3].imshow(intent_field, cmap='Purples', vmin=0, vmax=1)
im_emo       = axs[4].imshow(emotion_field, cmap='Reds', vmin=0, vmax=1)
im_bond      = axs[5].imshow(bond_field, cmap='cool', vmin=0, vmax=1)
im_legacy    = axs[6].imshow(legacy_field, cmap='gray', vmin=0, vmax=1)
im_hope      = axs[7].imshow(hope_field, cmap='pink', vmin=0, vmax=1)
im_ritual    = axs[8].imshow(ritual_field, cmap='Wistia', vmin=0, vmax=1)
im_story     = axs[9].imshow(story_field, cmap='spring', vmin=0, vmax=1)
im_honor     = axs[10].imshow(honor_field, cmap='YlGnBu', vmin=0, vmax=1)
im_symbol    = axs[11].imshow(symbol_field, cmap='tab20c', vmin=0, vmax=1)
im_oasis     = axs[12].imshow(oasis_field, cmap='autumn', vmin=0, vmax=1)
im_empathy   = axs[13].imshow(empathy_field, cmap='pink', vmin=0, vmax=1)
im_curiosity = axs[14].imshow(curiosity_field, cmap='YlGnBu', vmin=0, vmax=1)
im_goal      = axs[15].imshow(goal_field, cmap='hot', vmin=0, vmax=1)
im_sports    = axs[16].imshow(sports_field, cmap='Spectral', vmin=0, vmax=1)
im_music     = axs[17].imshow(music_field, cmap='coolwarm', vmin=0, vmax=1)
im_nature    = axs[18].imshow(nature_field, cmap='Greens', vmin=0, vmax=1)
im_healing   = axs[19].imshow(healing_field, cmap='bone', vmin=0, vmax=1)
im_wonder    = axs[20].imshow(wonder_field, cmap='viridis', vmin=0, vmax=1)
im_nerves    = axs[21].imshow(nerves_field, cmap='cividis', vmin=0, vmax=1)
im_love      = axs[22].imshow(love_field, cmap='pink', vmin=0, vmax=1)   # <- LOVE is 23rd panel (index 22)

panel_titles = [
   "Self", "Mirror", "Memory", "Intent", "Emotion", "Bond", "Legacy", "Hope",
   "Ritual", "Story", "Honor", "Symbol", "Oasis", "Empathy",
   "Curiosity", "Goal", "Sports", "Music", "Nature", "Healing", "Wonder", "Nerves", "Love"
]

for i, ax in enumerate(axs):
    if i < len(panel_titles):
        ax.set_title(panel_titles[i])
    ax.axis('off')

# 3. Love Update Logic
def update_love_field():
    # Love grows with strong bonds and empathy, fades slowly over time
    love_field[:] *= 0.99  # Love is lasting, fades slowly
    love_growth = (bond_field > 0.5) & (empathy_field > 0.3)
    love_field[love_growth] += 0.05
    love_field[:] = np.clip(love_field, 0, 1)

# 4. Animation update (include in your main animation function)
def animate_block_love(frame):
    update_love_field()
    # ...other update calls as needed...
    im_love.set_data(love_field)
    # Add rest of your im_xxx.set_data(...) lines here
    return [im_self, im_obs, im_mem, im_int, im_emo, im_bond, im_legacy, im_hope,
            im_ritual, im_story, im_honor, im_symbol, im_oasis, im_empathy, im_curiosity,
            im_goal, im_sports, im_music, im_nature, im_healing, im_wonder, im_nerves, im_love]

ani_love = FuncAnimation(fig, animate_block_love, frames=200, interval=80, blit=True)
plt.tight_layout()
plt.show()

# %%
# BLOCK 51: MBT Big Bang (Explosion of Motion, Creation, and Life)

def mbt_big_bang():
    # Explode motion (self_field), intent, and emotion—motion = being!
    self_field[:]    += np.random.uniform(0.8, 1.0, self_field.shape)  # Wild activity
    intent_field[:]  += np.random.uniform(0.7, 1.0, intent_field.shape)
    # All motion-based fields wake up
    motion_fields = [emotion_field, memory_field, bond_field, legacy_field, love_field, lust_field,
                    empathy_field, nerves_field, wonder_field, curiosity_field, hope_field]
    for field in motion_fields:
        field[:] += np.random.uniform(0.5, 0.8, field.shape)
        np.clip(field, 0, 1, out=field)
    # Optional: ripple effect—make center super-bright (true “origin”)
    cy, cx = self_field.shape[0]//2, self_field.shape[1]//2
    for r in range(7, 30, 4):  # expanding shockwaves
        y, x = np.ogrid[:self_field.shape[0], :self_field.shape[1]]
        mask = (y-cy)**2 + (x-cx)**2 <= r**2
        self_field[mask] = 1.0
        intent_field[mask] = 1.0
    # Clip everything
    for arr in [self_field, intent_field]:
        np.clip(arr, 0, 1, out=arr)

# To launch the MBT Big Bang:
mbt_big_bang()


# %%
# BLOCK  52: Hate Field (Rivalry, Exclusion, and Tension)

# 1. Define the hate_field if not already present
hate_field = np.zeros((grid_size, grid_size))

# 2. Add to your universal panel visualizer (after all other im_xxx panels)
im_hate = axs[23].imshow(hate_field, cmap='inferno', vmin=0, vmax=1)
panel_titles.append("Hate")

# 3. Update logic for hate (spikes in regions with high conflict, or where bonds/hope are low)
def update_hate_field():
    # Hate grows where nerves and negative emotions are high, or bonds/hope are low
    hate_field[:] *= 0.97  # Hate fades slowly but not instantly
    hate_growth = (nerves_field > 0.5) & (bond_field < 0.2) & (hope_field < 0.3)
    hate_field[hate_growth] += 0.08
    hate_field[:] = np.clip(hate_field, 0, 1)

# 4. Add the update into your animation (in your main animation function)
update_hate_field()
im_hate.set_data(hate_field)

# %%
# BLOCK 53: Fruits of Labour Field (Reward, Resource, and Progress)

# 1. Define the fruits_of_labour_field if not already present
fruits_of_labour_field = np.zeros((grid_size, grid_size))

# 2. (Panel is handled in Block 6!)

# 3. Update logic for fruits of labour (reward grows where positive effort, bonding, invention, or ritual is high)
def update_fruits_of_labour_field():
    # Example: reward accumulates where invention, bond, or ritual activity is high
    fruits_of_labour_field[:] *= 0.98  # gradual fade/consumption
    reward_growth = (
        (bond_field > 0.5)
        & (invention_hub_field > 0.5)
        | (ritual_field > 0.5)
    )
    fruits_of_labour_field[reward_growth] += 0.05
    fruits_of_labour_field[:] = np.clip(fruits_of_labour_field, 0, 1)

# 4. Add the update into your animation/main loop
update_fruits_of_labour_field()
# ims[?].set_data(fruits_of_labour_field)  # This is only needed if you are using an animation loop
