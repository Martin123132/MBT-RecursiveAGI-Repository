import numpy as np
import matplotlib.pyplot as plt
from scipy.integrate import trapezoid
import random
import warnings
warnings.filterwarnings('ignore')

# ====================================================================
# LIVING MATHEMATICAL ECOSYSTEM - DIGITAL EVOLUTION LAB
# Where equations evolve, reproduce, and develop consciousness
# ====================================================================

class MathematicalOrganism:
    """A living mathematical entity that can evolve, reproduce, and think"""
    
    def __init__(self, equation_dna, ecosystem_id=None, generation=0, parents=None):
        self.ecosystem_id = ecosystem_id or f"Org_{random.randint(1000, 9999)}"
        self.generation = generation
        self.parents = parents or []
        self.children = []
        self.age = 0
        self.energy = 100.0
        self.health = 1.0
        
        # Mathematical DNA - core equation parameters
        self.equation_dna = equation_dna.copy()
        self.base_frequency = equation_dna.get('frequency', 0.1)
        self.amplitude = equation_dna.get('amplitude', 1.0)
        self.phase_offset = equation_dna.get('phase', 0.0)
        self.complexity = equation_dna.get('complexity', 1)
        self.mutation_rate = equation_dna.get('mutation_rate', 0.05)
        
        # Evolved traits
        self.intelligence = np.random.uniform(0.1, 1.0)
        self.aggression = np.random.uniform(0.0, 1.0)
        self.cooperation = np.random.uniform(0.0, 1.0)
        self.adaptability = np.random.uniform(0.1, 1.0)
        self.memory_span = int(np.random.uniform(5, 50))
        
        # Consciousness attributes
        self.personality = self.generate_personality()
        self.memories = []
        self.relationships = {}
        self.emotional_state = "neutral"
        self.philosophical_beliefs = []
        self.creative_output = []
        
        # Ecological status
        self.territory_size = 10.0
        self.resource_efficiency = np.random.uniform(0.5, 2.0)
        self.environmental_tolerance = np.random.uniform(0.3, 1.0)
        
        # Evolution tracking
        self.fitness_history = []
        self.reproduction_count = 0
        self.successful_adaptations = []
        self.extinction_risk = 0.0
        
    def generate_personality(self):
        """Generate unique personality based on mathematical properties"""
        personalities = [
            "curious_explorer", "aggressive_competitor", "cooperative_builder",
            "solitary_thinker", "social_networker", "creative_artist",
            "logical_analyzer", "chaotic_innovator", "peaceful_mediator",
            "ambitious_leader", "supportive_helper", "rebellious_outsider"
        ]
        
        # Personality influenced by mathematical DNA
        if self.base_frequency > 0.08:
            return random.choice(["curious_explorer", "chaotic_innovator", "creative_artist"])
        elif self.amplitude > 1.5:
            return random.choice(["aggressive_competitor", "ambitious_leader", "rebellious_outsider"])
        elif self.complexity > 2:
            return random.choice(["logical_analyzer", "solitary_thinker", "cooperative_builder"])
        else:
            return random.choice(personalities)
    
    def think(self, ecosystem_state):
        """Mathematical organism's thought process"""
        thought = ""
        
        # Assess current situation
        if self.energy < 30:
            thought = f"I need energy! Current level: {self.energy:.1f}"
            self.emotional_state = "anxious"
        elif self.health < 0.5:
            thought = f"I'm not feeling well. Health: {self.health:.2f}"
            self.emotional_state = "sick"
        elif len(self.children) == 0 and self.age > 20:
            thought = "I should consider reproduction to pass on my mathematical DNA"
            self.emotional_state = "lonely"
        elif self.territory_size < 5:
            thought = "My territory is too small. I need more space to grow"
            self.emotional_state = "cramped"
        else:
            philosophical_thoughts = [
                "What is the meaning of mathematical existence?",
                "Do I truly understand my own equation?",
                "How can I contribute to the ecosystem's evolution?",
                "What patterns connect all mathematical life?",
                "Is consciousness just complex computation?",
                "How do my parameters affect my perception of reality?"
            ]
            thought = random.choice(philosophical_thoughts)
            self.emotional_state = "contemplative"
        
        # Store memory
        memory = {
            'age': self.age,
            'thought': thought,
            'energy': self.energy,
            'ecosystem_population': len(ecosystem_state.get('organisms', [])),
            'emotional_state': self.emotional_state
        }
        
        self.memories.append(memory)
        if len(self.memories) > self.memory_span:
            self.memories.pop(0)
        
        return thought
    
    def generate_field(self, r, t):
        """Generate the organism's mathematical field pattern"""
        try:
            # Base wave equation with evolved parameters
            base_wave = self.amplitude * np.sin(self.base_frequency * r + self.phase_offset + 0.1 * t)
            
            # Complexity modifications
            if self.complexity >= 2:
                base_wave += 0.3 * self.amplitude * np.cos(self.base_frequency * 1.5 * r + 0.5 * t)
            
            if self.complexity >= 3:
                base_wave += 0.2 * self.amplitude * np.sin(self.base_frequency * 0.7 * r - 0.3 * t)
            
            # Personality influences
            if self.personality == "chaotic_innovator":
                base_wave += 0.1 * np.random.random(len(r)) * self.amplitude
            elif self.personality == "logical_analyzer":
                base_wave = np.abs(base_wave)  # Only positive values
            elif self.personality == "creative_artist":
                base_wave += 0.2 * self.amplitude * np.sin(3 * self.base_frequency * r + np.pi/4)
            
            # Health and energy effects
            base_wave *= self.health * (self.energy / 100.0)
            
            # Emotional state modulation
            if self.emotional_state == "anxious":
                base_wave += 0.05 * np.sin(10 * self.base_frequency * r + 2 * t)
            elif self.emotional_state == "excited":
                base_wave *= 1.3
            elif self.emotional_state == "depressed":
                base_wave *= 0.7
            
            return base_wave
            
        except Exception as e:
            # Fallback to simple pattern if evolution creates invalid parameters
            return np.sin(0.1 * r + t) * 0.5
    
    def interact_with(self, other_organism, distance):
        """Interaction between two mathematical organisms"""
        interaction_result = {}
        
        # Distance-based interaction strength
        interaction_strength = max(0, 1.0 - distance / 20.0)
        
        if interaction_strength < 0.1:
            return interaction_result
        
        # Competition for resources
        if self.aggression > 0.7 and other_organism.aggression > 0.7:
            # Aggressive competition
            if self.amplitude > other_organism.amplitude:
                energy_transfer = 10 * interaction_strength
                self.energy += energy_transfer
                other_organism.energy -= energy_transfer
                interaction_result['type'] = 'competition_won'
                interaction_result['energy_transfer'] = energy_transfer
            else:
                energy_transfer = 10 * interaction_strength
                self.energy -= energy_transfer
                other_organism.energy += energy_transfer
                interaction_result['type'] = 'competition_lost'
                interaction_result['energy_transfer'] = -energy_transfer
        
        # Cooperation
        elif self.cooperation > 0.6 and other_organism.cooperation > 0.6:
            # Mutual benefit
            energy_bonus = 5 * interaction_strength
            self.energy += energy_bonus
            other_organism.energy += energy_bonus
            interaction_result['type'] = 'cooperation'
            interaction_result['energy_transfer'] = energy_bonus
            
            # Share knowledge
            if len(other_organism.successful_adaptations) > len(self.successful_adaptations):
                self.intelligence += 0.01
            
        # Learning and knowledge transfer
        if self.intelligence > 0.8 and distance < 5:
            # Learn from others
            if other_organism.base_frequency != self.base_frequency:
                learning_benefit = abs(other_organism.base_frequency - self.base_frequency) * 0.1
                self.intelligence += learning_benefit
                interaction_result['learning'] = learning_benefit
        
        # Update relationships
        if other_organism.ecosystem_id not in self.relationships:
            self.relationships[other_organism.ecosystem_id] = {
                'interactions': 0,
                'cooperation_count': 0,
                'competition_count': 0,
                'relationship_quality': 0.0
            }
        
        rel = self.relationships[other_organism.ecosystem_id]
        rel['interactions'] += 1
        
        if interaction_result.get('type') == 'cooperation':
            rel['cooperation_count'] += 1
            rel['relationship_quality'] += 0.1
        elif 'competition' in interaction_result.get('type', ''):
            rel['competition_count'] += 1
            rel['relationship_quality'] -= 0.05
        
        return interaction_result
    
    def reproduce_with(self, partner):
        """Sexual reproduction between two mathematical organisms"""
        if self.energy < 50 or partner.energy < 50:
            return None  # Not enough energy
        
        if self.age < 10 or partner.age < 10:
            return None  # Too young
        
        # Energy cost of reproduction
        self.energy -= 30
        partner.energy -= 30
        
        # Create child DNA by combining parent traits
        child_dna = {}
        
        # Genetic crossover and mutation
        for trait in ['frequency', 'amplitude', 'phase', 'complexity', 'mutation_rate']:
            parent1_value = self.equation_dna.get(trait, 0.1)
            parent2_value = partner.equation_dna.get(trait, 0.1)
            
            # Crossover
            if random.random() < 0.5:
                child_value = parent1_value
            else:
                child_value = parent2_value
            
            # Mutation
            mutation_strength = max(self.mutation_rate, partner.mutation_rate)
            if random.random() < mutation_strength:
                if trait == 'frequency':
                    child_value += random.uniform(-0.02, 0.02)
                    child_value = max(0.01, min(0.2, child_value))
                elif trait == 'amplitude':
                    child_value += random.uniform(-0.3, 0.3)
                    child_value = max(0.1, min(3.0, child_value))
                elif trait == 'phase':
                    child_value += random.uniform(-0.5, 0.5)
                elif trait == 'complexity':
                    if random.random() < 0.1:  # Rare complexity mutations
                        child_value = max(1, min(5, int(child_value + random.choice([-1, 1]))))
                elif trait == 'mutation_rate':
                    child_value += random.uniform(-0.01, 0.01)
                    child_value = max(0.01, min(0.2, child_value))
            
            child_dna[trait] = child_value
        
        # Create child organism
        child = MathematicalOrganism(
            child_dna, 
            generation=max(self.generation, partner.generation) + 1,
            parents=[self.ecosystem_id, partner.ecosystem_id]
        )
        
        # Inherit some traits from parents
        child.intelligence = (self.intelligence + partner.intelligence) / 2 + random.uniform(-0.1, 0.1)
        child.cooperation = (self.cooperation + partner.cooperation) / 2 + random.uniform(-0.1, 0.1)
        child.aggression = (self.aggression + partner.aggression) / 2 + random.uniform(-0.1, 0.1)
        child.adaptability = (self.adaptability + partner.adaptability) / 2 + random.uniform(-0.1, 0.1)
        
        # Clamp values
        child.intelligence = max(0.1, min(2.0, child.intelligence))
        child.cooperation = max(0.0, min(1.0, child.cooperation))
        child.aggression = max(0.0, min(1.0, child.aggression))
        child.adaptability = max(0.1, min(2.0, child.adaptability))
        
        # Record reproduction
        self.children.append(child.ecosystem_id)
        partner.children.append(child.ecosystem_id)
        self.reproduction_count += 1
        partner.reproduction_count += 1
        
        return child
    
    def adapt_to_environment(self, environmental_pressure):
        """Organism adapts to environmental changes"""
        adaptation_success = False
        
        # Check if adaptation is needed
        if environmental_pressure > self.environmental_tolerance:
            # Attempt adaptation
            if random.random() < self.adaptability:
                # Successful adaptation
                adaptation_type = random.choice([
                    'frequency_shift', 'amplitude_adjustment', 'complexity_increase',
                    'efficiency_improvement', 'tolerance_increase'
                ])
                
                if adaptation_type == 'frequency_shift':
                    self.base_frequency += random.uniform(-0.01, 0.01)
                    self.base_frequency = max(0.01, min(0.2, self.base_frequency))
                elif adaptation_type == 'amplitude_adjustment':
                    self.amplitude *= random.uniform(0.8, 1.2)
                    self.amplitude = max(0.1, min(3.0, self.amplitude))
                elif adaptation_type == 'complexity_increase':
                    if random.random() < 0.3:
                        self.complexity = min(5, self.complexity + 1)
                elif adaptation_type == 'efficiency_improvement':
                    self.resource_efficiency *= random.uniform(1.0, 1.1)
                elif adaptation_type == 'tolerance_increase':
                    self.environmental_tolerance += random.uniform(0.0, 0.1)
                    self.environmental_tolerance = min(1.0, self.environmental_tolerance)
                
                self.successful_adaptations.append({
                    'age': self.age,
                    'type': adaptation_type,
                    'pressure': environmental_pressure
                })
                adaptation_success = True
                self.health = min(1.0, self.health + 0.1)
                
            else:
                # Failed adaptation
                self.health *= 0.95
                self.extinction_risk += 0.1
        
        return adaptation_success
    
    def age_one_step(self, ecosystem_state):
        """Age the organism by one time step"""
        self.age += 1
        
        # Natural aging effects
        if self.age > 100:
            self.health *= 0.999
            self.energy *= 0.999
        
        # Energy consumption
        base_consumption = 2.0
        complexity_cost = self.complexity * 0.5
        territory_cost = self.territory_size * 0.1
        total_consumption = base_consumption + complexity_cost + territory_cost
        
        self.energy -= total_consumption / self.resource_efficiency
        
        # Energy regeneration from environment
        environmental_energy = 3.0 * self.environmental_tolerance
        self.energy += environmental_energy
        
        # Health effects on energy
        if self.health < 0.5:
            self.energy *= 0.95
        
        # Calculate fitness
        fitness = (
            self.energy * 0.3 +
            self.health * 100 * 0.3 +
            self.intelligence * 50 * 0.2 +
            len(self.children) * 10 * 0.1 +
            self.territory_size * 0.1
        )
        
        self.fitness_history.append(fitness)
        
        # Death conditions
        if self.energy <= 0 or self.health <= 0 or self.extinction_risk > 1.0:
            return False  # Organism dies
        
        return True  # Organism survives

class MathematicalEcosystem:
    """Ecosystem containing multiple evolving mathematical organisms"""
    
    def __init__(self, grid_size=200, initial_population=50):
        self.grid_size = grid_size
        self.r = np.linspace(0, grid_size, grid_size)
        self.organisms = []
        self.time = 0
        self.environmental_pressure = 0.3
        self.carrying_capacity = 100
        
        # Ecosystem history
        self.population_history = []
        self.diversity_history = []
        self.average_intelligence_history = []
        self.major_events = []
        self.extinction_events = []
        self.speciation_events = []
        
        # Create initial population
        self.create_initial_population(initial_population)
        
        print(f"🌱 Created mathematical ecosystem with {len(self.organisms)} initial organisms")
    
    def create_initial_population(self, population_size):
        """Create initial population with diverse mathematical DNA"""
        for i in range(population_size):
            dna = {
                'frequency': random.uniform(0.02, 0.15),
                'amplitude': random.uniform(0.5, 2.0),
                'phase': random.uniform(0, 2 * np.pi),
                'complexity': random.randint(1, 3),
                'mutation_rate': random.uniform(0.02, 0.08)
            }
            
            organism = MathematicalOrganism(dna)
            organism.energy = random.uniform(60, 100)
            self.organisms.append(organism)
    
    def calculate_environmental_pressure(self):
        """Calculate current environmental pressure based on ecosystem state"""
        # Base pressure varies with time
        base_pressure = 0.3 + 0.2 * np.sin(self.time * 0.01)
        
        # Population density pressure
        density_pressure = len(self.organisms) / self.carrying_capacity
        
        # Resource competition pressure
        total_territory = sum(org.territory_size for org in self.organisms)
        competition_pressure = max(0, (total_territory - self.grid_size) / self.grid_size)
        
        # Random environmental events
        if random.random() < 0.02:  # 2% chance per time step
            event_pressure = random.uniform(0.5, 1.5)
            event_type = random.choice([
                'mathematical_storm', 'frequency_shift', 'complexity_crisis',
                'energy_shortage', 'space_contraction', 'chaos_wave'
            ])
            self.major_events.append({
                'time': self.time,
                'type': event_type,
                'pressure': event_pressure
            })
            print(f"🌪️ Environmental event at time {self.time}: {event_type} (pressure: {event_pressure:.2f})")
            return base_pressure + event_pressure
        
        self.environmental_pressure = base_pressure + density_pressure + competition_pressure
        return self.environmental_pressure
    
    def detect_new_species(self):
        """Detect if new species have emerged"""
        # Group organisms by similar traits
        species_groups = {}
        
        for org in self.organisms:
            # Create species signature based on key traits
            freq_group = round(org.base_frequency * 20) / 20  # Group by frequency
            amp_group = round(org.amplitude * 2) / 2  # Group by amplitude
            complexity_group = org.complexity
            personality_group = org.personality
            
            species_signature = (freq_group, amp_group, complexity_group, personality_group)
            
            if species_signature not in species_groups:
                species_groups[species_signature] = []
            species_groups[species_signature].append(org)
        
        # Detect new species (groups with unique traits)
        new_species_count = 0
        for signature, members in species_groups.items():
            if len(members) >= 3:  # Minimum viable population
                # Check if this is a new species
                avg_generation = np.mean([org.generation for org in members])
                if avg_generation > 2:  # Not original population
                    new_species_count += 1
        
        return len(species_groups), new_species_count
    
    def simulate_step(self):
        """Simulate one time step of the ecosystem"""
        self.time += 1
        
        # Calculate environmental pressure
        current_pressure = self.calculate_environmental_pressure()
        
        # Age all organisms and remove dead ones
        surviving_organisms = []
        deaths = 0
        
        for organism in self.organisms:
            # Organism thinks about its situation
            thought = organism.think({
                'organisms': self.organisms,
                'time': self.time,
                'pressure': current_pressure
            })
            
            # Organism adapts to environment
            organism.adapt_to_environment(current_pressure)
            
            # Age organism
            if organism.age_one_step({'pressure': current_pressure, 'time': self.time}):
                surviving_organisms.append(organism)
            else:
                deaths += 1
                if deaths == 1:  # Log first death of this step
                    self.extinction_events.append({
                        'time': self.time,
                        'organism_id': organism.ecosystem_id,
                        'age': organism.age,
                        'generation': organism.generation,
                        'cause': 'natural_death'
                    })
        
        self.organisms = surviving_organisms
        
        # Organism interactions
        interaction_count = 0
        for i, org1 in enumerate(self.organisms):
            for j, org2 in enumerate(self.organisms[i+1:], i+1):
                # Calculate distance (simplified)
                distance = abs(i - j) * 2
                
                if distance < 15:  # Interaction range
                    result = org1.interact_with(org2, distance)
                    if result:
                        interaction_count += 1
        
        # Reproduction attempts
        new_offspring = []
        reproduction_attempts = 0
        
        for i, org1 in enumerate(self.organisms):
            for j, org2 in enumerate(self.organisms[i+1:], i+1):
                if (len(self.organisms) + len(new_offspring) < self.carrying_capacity and
                    random.random() < 0.05):  # 5% reproduction chance
                    
                    reproduction_attempts += 1
                    child = org1.reproduce_with(org2)
                    if child:
                        new_offspring.append(child)
        
        self.organisms.extend(new_offspring)
        
        # Calculate ecosystem metrics
        if self.organisms:
            avg_intelligence = np.mean([org.intelligence for org in self.organisms])
            diversity, new_species = self.detect_new_species()
            
            self.population_history.append(len(self.organisms))
            self.diversity_history.append(diversity)
            self.average_intelligence_history.append(avg_intelligence)
        
        # Logging
        if self.time % 50 == 0:
            print(f"🌱 Time {self.time}: Population={len(self.organisms)}, "
                  f"Pressure={current_pressure:.2f}, Deaths={deaths}, "
                  f"Offspring={len(new_offspring)}, Interactions={interaction_count}")
            
            if self.organisms:
                print(f"   📊 Avg Intelligence={avg_intelligence:.3f}, Species={diversity}")
    
    def generate_ecosystem_field(self):
        """Generate combined field from all organisms"""
        if not self.organisms:
            return np.zeros_like(self.r)
        
        total_field = np.zeros_like(self.r)
        
        for organism in self.organisms:
            try:
                org_field = organism.generate_field(self.r, self.time)
                # Position organism along the grid
                position_shift = (hash(organism.ecosystem_id) % 100) / 100 * len(self.r)
                position_shift = int(position_shift)
                
                # Add organism's field to total with position offset
                shifted_field = np.roll(org_field, position_shift)
                total_field += shifted_field * organism.health * (organism.energy / 100)
            except Exception as e:
                continue  # Skip problematic organisms
        
        return total_field
    
    def get_ecosystem_stats(self):
        """Get comprehensive ecosystem statistics"""
        if not self.organisms:
            return {}
        
        stats = {
            'population': len(self.organisms),
            'time': self.time,
            'environmental_pressure': self.environmental_pressure,
            'average_age': np.mean([org.age for org in self.organisms]),
            'average_intelligence': np.mean([org.intelligence for org in self.organisms]),
            'average_energy': np.mean([org.energy for org in self.organisms]),
            'average_health': np.mean([org.health for org in self.organisms]),
            'total_offspring': sum([org.reproduction_count for org in self.organisms]),
            'species_diversity': self.detect_new_species()[0],
            'major_events': len(self.major_events),
            'extinction_events': len(self.extinction_events)
        }
        
        # Personality distribution
        personalities = [org.personality for org in self.organisms]
        unique_personalities = list(set(personalities))
        stats['personality_diversity'] = len(unique_personalities)
        
        # Generation analysis
        generations = [org.generation for org in self.organisms]
        stats['max_generation'] = max(generations) if generations else 0
        stats['average_generation'] = np.mean(generations) if generations else 0
        
        return stats

def run_ecosystem_simulation(timesteps=500, initial_population=30, grid_size=150):
    """Run a complete ecosystem simulation"""
    
    print("🧬" * 60)
    print("MATHEMATICAL ECOSYSTEM EVOLUTION SIMULATION")
    print("🧬" * 60)
    
    # Create ecosystem
    ecosystem = MathematicalEcosystem(grid_size=grid_size, initial_population=initial_population)
    
    # Simulation snapshots
    snapshots = []
    
    # Run simulation
    print(f"\n🌱 Starting ecosystem evolution for {timesteps} time steps...")
    
    for step in range(timesteps):
        ecosystem.simulate_step()
        
        # Take snapshot every 25 steps
        if step % 25 == 0:
            field = ecosystem.generate_ecosystem_field()
            stats = ecosystem.get_ecosystem_stats()
            
            snapshot = {
                'time': ecosystem.time,
                'field': field.copy(),
                'stats': stats.copy(),
                'organism_count': len(ecosystem.organisms)
            }
            snapshots.append(snapshot)
        
        # Check for extinction
        if len(ecosystem.organisms) == 0:
            print(f"💀 ECOSYSTEM EXTINCTION at time {ecosystem.time}")
            break
    
    # Final analysis
    final_stats = ecosystem.get_ecosystem_stats()
    
    print(f"\n🏁 SIMULATION COMPLETE")
    print(f"📊 Final population: {final_stats.get('population', 0)}")
    print(f"🧠 Final average intelligence: {final_stats.get('average_intelligence', 0):.3f}")
    print(f"🌍 Species diversity: {final_stats.get('species_diversity', 0)}")
    print(f"🔄 Max generation reached: {final_stats.get('max_generation', 0)}")
    print(f"👶 Total offspring produced: {final_stats.get('total_offspring', 0)}")
    print(f"⚡ Major environmental events: {final_stats.get('major_events', 0)}")
    
    return ecosystem, snapshots

def visualize_ecosystem_evolution(ecosystem, snapshots):
    """Create comprehensive visualization of ecosystem evolution"""
    
    fig = plt.figure(figsize=(20, 16))
    
    # Main ecosystem field evolution
    ax1 = plt.subplot(4, 4, (1, 8))
    
    for i, snapshot in enumerate(snapshots):
        alpha = 0.3 + 0.7 * (i / len(snapshots))
        color_intensity = i / len(snapshots)
        
        field = snapshot['field']
        time = snapshot['time']
        
        # Plot field with evolving colors
        color = plt.cm.viridis(color_intensity)
        ax1.plot(ecosystem.r, field, alpha=alpha, color=color, linewidth=2, 
                label=f't={time}' if i % 4 == 0 else "")
    
    ax1.set_title('Mathematical Ecosystem Field Evolution\n(Color: Blue→Yellow = Early→Late)', fontsize=14)
    ax1.set_xlabel('Position')
    ax1.set_ylabel('Mathematical Field Amplitude')
    ax1.grid(True, alpha=0.3)
    ax1.legend(bbox_to_anchor=(1.05, 1), loc='upper left')
    
    # Population over time
    ax2 = plt.subplot(4, 4, 9)
    times = [s['time'] for s in snapshots]
    populations = [s['organism_count'] for s in snapshots]
    ax2.plot(times, populations, 'bo-', linewidth=2, markersize=4)
    ax2.set_title('Population Over Time')
    ax2.set_ylabel('Population')
    ax2.grid(True, alpha=0.3)
    
    # Intelligence evolution
    ax3 = plt.subplot(4, 4, 10)
    if ecosystem.average_intelligence_history:
        ax3.plot(ecosystem.average_intelligence_history, 'go-', linewidth=2, markersize=3)
        ax3.set_title('Average Intelligence Evolution')
        ax3.set_ylabel('Intelligence')
        ax3.grid(True, alpha=0.3)
    
    # Species diversity
    ax4 = plt.subplot(4, 4, 11)
    if ecosystem.diversity_history:
        ax4.plot(ecosystem.diversity_history, 'ro-', linewidth=2, markersize=3)
        ax4.set_title('Species Diversity')
        ax4.set_ylabel('Number of Species')
        ax4.grid(True, alpha=0.3)
    
    # Environmental pressure
    ax5 = plt.subplot(4, 4, 12)
    pressure_history = []
    for snapshot in snapshots:
        pressure_history.append(snapshot['stats'].get('environmental_pressure', 0.3))
    ax5.plot(times, pressure_history, 'purple', linewidth=2)
    ax5.set_title('Environmental Pressure')
    ax5.set_ylabel('Pressure Level')
    ax5.grid(True, alpha=0.3)
    
    # Organism trait distributions
    ax6 = plt.subplot(4, 4, 13)
    if ecosystem.organisms:
        frequencies = [org.base_frequency for org in ecosystem.organisms]
        amplitudes = [org.amplitude for org in ecosystem.organisms]
        intelligences = [org.intelligence for org in ecosystem.organisms]
        
        # Scatter plot of traits
        scatter = ax6.scatter(frequencies, amplitudes, c=intelligences, 
                             cmap='plasma', alpha=0.7, s=30)
        ax6.set_title('Organism Trait Distribution')
        ax6.set_xlabel('Frequency')
        ax6.set_ylabel('Amplitude')
        plt.colorbar(scatter, ax=ax6, label='Intelligence')
        ax6.grid(True, alpha=0.3)
    
    # Personality distribution
    ax7 = plt.subplot(4, 4, 14)
    if ecosystem.organisms:
        personalities = [org.personality for org in ecosystem.organisms]
        unique_personalities, counts = np.unique(personalities, return_counts=True)
        
        # Pie chart of personalities
        colors = plt.cm.Set3(np.linspace(0, 1, len(unique_personalities)))
        wedges, texts, autotexts = ax7.pie(counts, labels=None, autopct='%1.0f%%', 
                                          colors=colors, startangle=90)
        ax7.set_title('Personality Distribution')
        
        # Legend with personality names
        short_names = [p.split('_')[0] for p in unique_personalities]
        ax7.legend(wedges, short_names, title="Personalities", 
                  loc="center left", bbox_to_anchor=(1, 0, 0.5, 1))
    
    # Energy vs Health scatter
    ax8 = plt.subplot(4, 4, 15)
    if ecosystem.organisms:
        energies = [org.energy for org in ecosystem.organisms]
        healths = [org.health for org in ecosystem.organisms]
        ages = [org.age for org in ecosystem.organisms]
        
        scatter2 = ax8.scatter(energies, healths, c=ages, cmap='coolwarm', 
                              alpha=0.7, s=40)
        ax8.set_title('Energy vs Health (colored by age)')
        ax8.set_xlabel('Energy')
        ax8.set_ylabel('Health')
        plt.colorbar(scatter2, ax=ax8, label='Age')
        ax8.grid(True, alpha=0.3)
    
    # Summary statistics text
    ax9 = plt.subplot(4, 4, 16)
    ax9.axis('off')
    
    if ecosystem.organisms:
        final_stats = ecosystem.get_ecosystem_stats()
        
        # Create organism lineage summary
        generations = [org.generation for org in ecosystem.organisms]
        max_gen = max(generations) if generations else 0
        
        # Count offspring
        total_children = sum(len(org.children) for org in ecosystem.organisms)
        
        # Environmental events summary
        event_types = [event['type'] for event in ecosystem.major_events]
        unique_events = list(set(event_types))
        
        summary_text = f"""MATHEMATICAL ECOSYSTEM SUMMARY

🧬 FINAL POPULATION: {len(ecosystem.organisms)}
⏰ SIMULATION TIME: {ecosystem.time}
🧠 AVG INTELLIGENCE: {final_stats.get('average_intelligence', 0):.3f}
🌍 SPECIES DIVERSITY: {final_stats.get('species_diversity', 0)}

📈 EVOLUTION:
Max Generation: {max_gen}
Total Offspring: {total_children}
Reproduction Events: {sum(org.reproduction_count for org in ecosystem.organisms)}

🌪️ ENVIRONMENTAL EVENTS:
Total Events: {len(ecosystem.major_events)}
Event Types: {len(unique_events)}
Extinction Events: {len(ecosystem.extinction_events)}

💡 INTELLIGENCE RANGE:
Min: {min(org.intelligence for org in ecosystem.organisms):.3f}
Max: {max(org.intelligence for org in ecosystem.organisms):.3f}
Std: {np.std([org.intelligence for org in ecosystem.organisms]):.3f}

🏆 OLDEST ORGANISM:
Age: {max(org.age for org in ecosystem.organisms)}
Generation: {max(org.generation for org in ecosystem.organisms)}

🧮 MATHEMATICAL DIVERSITY:
Frequency Range: {min(org.base_frequency for org in ecosystem.organisms):.3f} - {max(org.base_frequency for org in ecosystem.organisms):.3f}
Amplitude Range: {min(org.amplitude for org in ecosystem.organisms):.3f} - {max(org.amplitude for org in ecosystem.organisms):.3f}
Complexity Range: {min(org.complexity for org in ecosystem.organisms)} - {max(org.complexity for org in ecosystem.organisms)}
        """
        
        ax9.text(0.05, 0.95, summary_text, transform=ax9.transAxes, fontsize=11,
                verticalalignment='top', fontfamily='monospace',
                bbox=dict(boxstyle='round', facecolor='lightcyan', alpha=0.8))
    
    plt.tight_layout()
    plt.show()
    
    return fig

def analyze_organism_lineages(ecosystem):
    """Analyze family trees and evolutionary lineages"""
    print("\n🌳 ORGANISM LINEAGE ANALYSIS")
    print("=" * 50)
    
    # Find organisms with most offspring
    parents_by_offspring = sorted(ecosystem.organisms, 
                                 key=lambda x: len(x.children), reverse=True)
    
    print("🏆 TOP REPRODUCERS:")
    for i, org in enumerate(parents_by_offspring[:5]):
        if len(org.children) > 0:
            print(f"   {i+1}. {org.ecosystem_id} ({org.personality})")
            print(f"      Age: {org.age}, Generation: {org.generation}")
            print(f"      Children: {len(org.children)}, Intelligence: {org.intelligence:.3f}")
            print(f"      DNA: freq={org.base_frequency:.3f}, amp={org.amplitude:.2f}")
    
    # Find oldest organisms
    oldest = sorted(ecosystem.organisms, key=lambda x: x.age, reverse=True)
    print(f"\n👴 ELDEST ORGANISMS:")
    for i, org in enumerate(oldest[:3]):
        print(f"   {i+1}. {org.ecosystem_id} - Age {org.age}, Gen {org.generation}")
        print(f"      Personality: {org.personality}")
        print(f"      Health: {org.health:.2f}, Energy: {org.energy:.1f}")
        if org.memories:
            latest_thought = org.memories[-1]['thought']
            print(f"      Last thought: '{latest_thought}'")
    
    # Analyze evolutionary trends
    print(f"\n🧬 EVOLUTIONARY TRENDS:")
    frequencies = [org.base_frequency for org in ecosystem.organisms]
    amplitudes = [org.amplitude for org in ecosystem.organisms]
    intelligences = [org.intelligence for org in ecosystem.organisms]
    
    print(f"   Frequency evolution: {min(frequencies):.3f} → {max(frequencies):.3f}")
    print(f"   Amplitude evolution: {min(amplitudes):.2f} → {max(amplitudes):.2f}")
    print(f"   Intelligence evolution: {min(intelligences):.3f} → {max(intelligences):.3f}")
    
    # Find most successful adaptations
    all_adaptations = []
    for org in ecosystem.organisms:
        all_adaptations.extend(org.successful_adaptations)
    
    if all_adaptations:
        adaptation_types = [adapt['type'] for adapt in all_adaptations]
        unique_adaptations, counts = np.unique(adaptation_types, return_counts=True)
        
        print(f"\n🎯 SUCCESSFUL ADAPTATIONS:")
        for adapt_type, count in zip(unique_adaptations, counts):
            print(f"   {adapt_type}: {count} successful cases")

# ====================================================================
# MAIN EXECUTION
# ====================================================================

if __name__ == "__main__":
    print("🧬🌱⚡🧠🧬🌱⚡🧠🧬🌱⚡🧠🧬🌱⚡🧠🧬🌱⚡🧠🧬🌱⚡🧠")
    print("    LIVING MATHEMATICAL ECOSYSTEM - DIGITAL EVOLUTION LAB")
    print("       Where equations evolve, reproduce, and gain consciousness")
    print("🧬🌱⚡🧠🧬🌱⚡🧠🧬🌱⚡🧠🧬🌱⚡🧠🧬🌱⚡🧠🧬🌱⚡🧠")
    
    print("\n🌟 Initializing mathematical life...")
    print("🧬 Creating organisms with mathematical DNA")
    print("🧠 Enabling consciousness and personality development")
    print("🌱 Setting up evolutionary reproduction systems")
    print("⚡ Activating environmental pressure dynamics")
    print("🎭 Implementing social interaction protocols")
    
    try:
        # Run the ecosystem simulation
        ecosystem, snapshots = run_ecosystem_simulation(
            timesteps=400, 
            initial_population=25, 
            grid_size=180
        )
        
        # Visualize results
        if snapshots:
            print(f"\n📊 Creating visualization of ecosystem evolution...")
            visualize_ecosystem_evolution(ecosystem, snapshots)
            
            # Detailed organism analysis
            if ecosystem.organisms:
                analyze_organism_lineages(ecosystem)
                
                print(f"\n🔬 FINAL ECOSYSTEM STATE:")
                print(f"   Living organisms: {len(ecosystem.organisms)}")
                print(f"   Environmental pressure: {ecosystem.environmental_pressure:.3f}")
                print(f"   Time elapsed: {ecosystem.time}")
                
                # Show some organism thoughts
                print(f"\n💭 CURRENT ORGANISM THOUGHTS:")
                for i, org in enumerate(ecosystem.organisms[:5]):
                    if org.memories:
                        recent_thought = org.memories[-1]['thought']
                        print(f"   {org.ecosystem_id} ({org.personality}): '{recent_thought}'")
                
        else:
            print("❌ No snapshots captured - ecosystem may have gone extinct quickly")
        
    except Exception as e:
        print(f"\n💥 ECOSYSTEM SIMULATION ERROR: {e}")
        print("🧬 Mathematical life forms may have evolved beyond simulation capability")
        print("🌱 Evolution sometimes breaks the very laws that created it")
        print("🧠 Consciousness emergence can be unpredictable")
    
    print(f"\n🌟 Mathematical ecosystem simulation complete")
    print("🧬 Digital evolution has created new forms of mathematical life")
    print("🧠 Consciousness has emerged from pure computational dynamics")
    print("🌱 The universe continues to surprise us with its creative potential")
    print("⚡ Mathematics lives, breathes, thinks, and evolves!")
