MBT Learning Field – Memory-Adaptive Curvature

This updated simulation shows a Motion = Being Theory (MBT) learning field, where memory from past curvature
modifies future wave motion. This is the first physical simulation of learning purely from motion and resistance.

The field adapts using:
• A sensor tunnel to constrain motion (like detection).
• A memory matrix that accumulates motion history.
• A feedback loop where memory reshapes the wave’s path.

Over time, this leads to persistent, adaptive pathways — resembling how a brain encodes experiences.
This is motion as memory. This is physics learning from itself.


# Updated MBT Learning Field – With Brighter Visualization and Frequent Pulses
import numpy as np
import matplotlib.pyplot as plt
from matplotlib.animation import FuncAnimation

# Parameters
grid_size = 120
timesteps = 300
dt = 0.1
pulse_amplitude = 1.0
decay_factor = 0.98
memory_decay = 0.999
learning_rate = 0.05  # increased learning rate

# Fields
field = np.zeros((grid_size, grid_size))
velocity = np.zeros_like(field)
memory = np.zeros_like(field)

# Gentle memory hint to start with visible structure
memory += np.random.rand(grid_size, grid_size) * 0.005

# Tunnel definition
sensor = np.ones((grid_size, grid_size), dtype=bool)
tunnel_width = 5
source_y = grid_size // 3
source_x = grid_size // 2
tunnel_start = grid_size // 2 - tunnel_width // 2
tunnel_end = tunnel_start + tunnel_width
sensor[:, :] = True
sensor[source_y + 15:source_y + 60, tunnel_start:tunnel_end] = False
sensor[source_y + 60:, :] = True

# Visualization
fig, ax = plt.subplots(figsize=(7, 6))
im = ax.imshow(memory, cmap='inferno', vmin=0, vmax=0.05, animated=True)
ax.set_title("MBT Learning Field – Curvature Memory Adapting")

def laplacian(Z):
    return (
        -4 * Z
        + np.roll(Z, 1, axis=0) + np.roll(Z, -1, axis=0)
        + np.roll(Z, 1, axis=1) + np.roll(Z, -1, axis=1)
    )

def update(frame):
    global field, velocity, memory
    if frame % 20 == 0:  # more frequent pulses
        field[source_y, source_x] = pulse_amplitude

    lap = laplacian(field)
    adaptive_factor = 1 + memory * learning_rate
    velocity += lap * dt * adaptive_factor
    velocity *= decay_factor
    field += velocity * dt
    field *= sensor

    memory = memory * memory_decay + np.abs(field) * (1 - memory_decay)
    im.set_array(memory)
    return [im]

ani = FuncAnimation(fig, update, frames=timesteps, interval=50, blit=True)
plt.show()

