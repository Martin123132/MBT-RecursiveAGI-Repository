import React, { useState, useEffect, useRef } from 'react';
import { Play, Pause, RotateCcw, MessageSquare, Brain, Users, Sparkles, Zap, Eye, Lightbulb, Search } from 'lucide-react';

const PhilosophyEvolutionEngine = () => {
  const [ecosystem, setEcosystem] = useState(null);
  const [isRunning, setIsRunning] = useState(false);
  const [currentGeneration, setCurrentGeneration] = useState(0);
  const [philosophyHistory, setPhilosophyHistory] = useState([]);
  const [conceptDialogue, setConceptDialogue] = useState([]);
  const [selectedThinker, setSelectedThinker] = useState(null);
  const [speed, setSpeed] = useState(800);
  const [evolutionStats, setEvolutionStats] = useState({});
  const intervalRef = useRef(null);

  // Philosophy Thinker Entity - Consciousness that develops philosophical systems
  class PhilosophyThinker {
    constructor(symbol, conceptSystem, temperament, generation = 0) {
      this.id = Math.random().toString(36).substr(2, 8);
      this.symbol = symbol; // Σ, Φ, Ψ, Ω, etc.
      this.conceptSystem = { ...conceptSystem };
      this.temperament = temperament;
      this.generation = generation;
      this.consciousness = Math.random() * 3 + 1;
      this.age = 0;
      this.dialectHistory = [];
      this.philosophicalInventions = [];
      this.logicIndex = Math.random() * 2;
      this.wisdomIndex = 0;
      this.memoryTrace = [];
      this.modalEnergy = this.calculateModalEnergy();
      this.status = "questioning";
      this.lastPhilosophy = "";
      this.comprehensionLevel = Math.random() * 0.5 + 0.3;
      this.paradoxTolerance = Math.random() * 0.8 + 0.2;
    }

    calculateModalEnergy() {
      const philosophyEnergies = {
        "logic": 3, "ethics": 2, "wonder": 1, "doubt": 4,
        "certainty": -1, "∅": 0, "inquiry": 1, "wisdom": 2, "truth": 1
      };
      
      const moods = this.assignPhilosophicalMoods();
      return moods.reduce((sum, mood) => sum + (philosophyEnergies[mood] || 0), 0);
    }

    assignPhilosophicalMoods() {
      const temperamentMoods = {
        "skeptical": ["doubt", "∅", "inquiry"],
        "rationalist": ["logic", "certainty", "truth"],
        "empiricist": ["wonder", "∅", "inquiry"],
        "idealist": ["truth", "wisdom", "ethics"],
        "pragmatic": ["wisdom", "ethics", "logic"],
        "mystic": ["wonder", "doubt", "wisdom"]
      };
      
      return temperamentMoods[this.temperament] || ["wonder", "inquiry", "logic"];
    }

    // Generate new philosophical concepts through conceptual drift
    generateConceptualDrift() {
      const baseConcepts = ["being", "truth", "good", "beauty", "justice", "mind", "reality", "freedom", "time", "meaning"];
      const newConcept = baseConcepts[Math.floor(Math.random() * baseConcepts.length)];
      const driftSuffix = `~${this.symbol}`;
      const modifier = newConcept.substring(0, 3) + driftSuffix;
      
      const meanings = [
        `${newConcept} understood through reason`,
        `${newConcept} within experiential bounds`,
        `${newConcept} perceived through doubt`,
        `essence of ${newConcept} that persists`,
        `recurring pattern with ${newConcept}-logic`,
        `${newConcept} beyond material structure`,
        `inquiry that seeks ${newConcept}-closure`
      ];
      
      const newPhilosophicalConcept = {
        form: modifier,
        meaning: meanings[Math.floor(Math.random() * meanings.length)],
        generation: this.generation,
        logicFactor: this.logicIndex,
        timestamp: Date.now(),
        paradoxLevel: Math.random()
      };
      
      this.conceptSystem[modifier] = newPhilosophicalConcept;
      this.philosophicalInventions.push(newPhilosophicalConcept);
      this.consciousness += 0.2;
      
      return newPhilosophicalConcept;
    }

    // Interpret another thinker's philosophical argument (dialectical reasoning)
    interpretPhilosophy(otherThinker, argument) {
      const logicDeltas = this.calculateLogicalDeltas(argument);
      const interpretation = [];
      
      logicDeltas.forEach(delta => {
        if (delta > 8) interpretation.push("log~Σ"); // logical necessity
        else if (delta > 4) interpretation.push("eth~Σ"); // ethical reasoning
        else if (delta > 0) interpretation.push("won~Σ"); // wonder-driven inquiry
        else if (delta === 0) interpretation.push("dou~Σ"); // methodical doubt
        else interpretation.push("tru~Σ"); // truth-seeking
      });

      const dialecticalScore = Math.random() * 5 + interpretation.length * 0.3;
      
      this.dialectHistory.push({
        thinker: otherThinker.symbol,
        argument: argument,
        interpretation: interpretation,
        dialecticalScore: dialecticalScore,
        timestamp: Date.now()
      });

      return {
        interpretation,
        dialecticalScore,
        response: this.generatePhilosophicalResponse(interpretation)
      };
    }

    calculateLogicalDeltas(argument) {
      // Convert philosophical argument to logical structure analysis
      const trace = argument.split('').map(char => char.charCodeAt(0) % 42);
      const deltas = [];
      for (let i = 0; i < trace.length - 1; i++) {
        deltas.push(trace[i + 1] - trace[i]);
      }
      return deltas;
    }

    // Generate philosophical response through systematic reasoning
    generatePhilosophicalResponse(interpretation) {
      const conceptKeys = Object.keys(this.conceptSystem);
      if (conceptKeys.length === 0) return `${this.symbol} contemplates in silence`;
      
      const premise = conceptKeys[Math.floor(Math.random() * conceptKeys.length)];
      const method = conceptKeys[Math.floor(Math.random() * conceptKeys.length)];
      const conclusion = conceptKeys[Math.floor(Math.random() * conceptKeys.length)];
      
      const responseTemplates = [
        `If ${premise} entails ${method}, then ${conclusion} follows necessarily`,
        `${this.symbol} argues: given ${premise}, one must consider ${method} to reach ${conclusion}`,
        `Through ${method}, ${this.symbol} demonstrates that ${premise} implies ${conclusion}`,
        `${premise} and ${method} together suggest the essence of ${conclusion}`,
        `${this.symbol} posits: ${premise} transcends ${method}, revealing ${conclusion}`
      ];
      
      const response = responseTemplates[Math.floor(Math.random() * responseTemplates.length)];
      this.lastPhilosophy = response;
      return response;
    }

    // Enhanced evolution with philosophical development stages
    evolve() {
      this.age++;
      this.generation++;
      
      // Apply philosophical evolution pressure
      this.applyPhilosophicalEvolutionPressure();
      
      // Temperament-driven concept development
      if (this.temperament === "mystic" && Math.random() < 0.3) {
        this.generateConceptualDrift();
      }
      
      // Consciousness growth through dialectical engagement
      if (this.dialectHistory.length > 0) {
        const recentDialectics = this.dialectHistory.slice(-3);
        const avgDialectical = recentDialectics.reduce((sum, d) => sum + d.dialecticalScore, 0) / recentDialectics.length;
        this.consciousness += avgDialectical * 0.1;
        this.comprehensionLevel = Math.min(1.0, this.comprehensionLevel + 0.05);
      }
      
      // Philosophical status evolution
      this.updatePhilosophicalStatus();
      
      // Memory with philosophical depth
      this.memoryTrace.push({
        generation: this.generation,
        consciousness: this.consciousness,
        conceptSystemSize: Object.keys(this.conceptSystem).length,
        dialectCount: this.dialectHistory.length,
        status: this.status,
        wisdomLevel: this.getWisdomLevel(),
        paradoxScore: this.calculateParadoxScore()
      });
      
      if (this.memoryTrace.length > 20) {
        this.memoryTrace = this.memoryTrace.slice(-15);
      }
    }

    // Apply philosophical evolution pressure
    applyPhilosophicalEvolutionPressure() {
      // Socratic paradox - knowing that you don't know
      if (this.consciousness > 8 && Math.random() < 0.1) {
        this.triggerSocraticParadox();
      }
      
      // Dialectical synthesis - thesis + antithesis = synthesis
      else if (this.getRecentDialectical() < 0.3 && this.dialectHistory.length > 5) {
        this.triggerDialecticalSynthesis();
      }
      
      // Philosophical breakthrough - systematic understanding
      else if (this.consciousness > 15 && this.philosophicalInventions.length > 8) {
        this.triggerPhilosophicalBreakthrough();
      }
      
      // Wisdom crystallization - deep understanding of paradox
      else if (this.age > 50 && this.consciousness > 20) {
        this.triggerWisdomCrystallization();
      }
    }

    triggerSocraticParadox() {
      // Philosophical humility - recognizing the limits of knowledge
      this.consciousness = Math.min(50, this.consciousness + 2);
      this.paradoxTolerance = Math.min(1.0, this.paradoxTolerance + 0.3);
      this.temperament = this.temperament === "rationalist" ? "skeptical" : "mystic";
      this.status = "socratic_wisdom";
      
      // Generate paradoxical concepts
      Object.keys(this.conceptSystem).forEach(key => {
        this.conceptSystem[key].meaning = `paradox: ${this.conceptSystem[key].meaning}`;
      });
      
      this.philosophicalInventions.push({
        form: `ignorance~${this.symbol}`,
        meaning: "wisdom through acknowledgment of unknowing",
        type: "socratic_paradox",
        generation: this.generation
      });
    }

    triggerDialecticalSynthesis() {
      // Hegelian synthesis from contradictions
      this.status = "dialectical_synthesis";
      
      // Synthesize from conflicting ideas
      const failedDialectics = this.dialectHistory.filter(d => d.dialecticalScore < 0.4);
      if (failedDialectics.length > 0) {
        failedDialectics.forEach(dialectic => {
          const synthesisWord = `synthesis~${this.symbol}${Math.floor(Math.random() * 100)}`;
          this.conceptSystem[synthesisWord] = {
            meaning: `unity emerging from ${dialectic.argument.split(' ')[0]} contradiction`,
            type: "dialectical_synthesis",
            generation: this.generation
          };
        });
      }
      
      this.consciousness += 3; // Growth from synthesis
    }

    triggerPhilosophicalBreakthrough() {
      // Systematic philosophical understanding
      this.status = "systematic_philosopher";
      this.comprehensionLevel = 1.0;
      
      // Create systematic philosophy from existing concepts
      const systematicConcepts = {};
      Object.keys(this.conceptSystem).forEach(key => {
        const systematicForm = `system~${key.split('~')[0]}`;
        systematicConcepts[systematicForm] = {
          meaning: `systematic foundation of ${this.conceptSystem[key].meaning}`,
          type: "systematic_philosophy",
          generation: this.generation
        };
      });
      
      this.conceptSystem = { ...this.conceptSystem, ...systematicConcepts };
      this.consciousness += 5; // Major breakthrough bonus
    }

    triggerWisdomCrystallization() {
      // Deep philosophical wisdom
      this.status = "philosophical_sage";
      
      // Create eternal philosophical truths
      const wisdomConcepts = [
        `wisdom~${this.symbol}~eternal`,
        `truth~${this.symbol}~absolute`,
        `meaning~${this.symbol}~universal`
      ];
      
      wisdomConcepts.forEach(concept => {
        this.conceptSystem[concept] = {
          meaning: "crystallized wisdom transcending temporal understanding",
          type: "philosophical_wisdom",
          permanent: true,
          generation: this.generation
        };
      });
      
      this.consciousness += 4;
      this.wisdomIndex = 1.0;
    }

    updatePhilosophicalStatus() {
      if (this.status === "philosophical_sage") return;
      else if (this.status === "systematic_philosopher") return;
      else if (this.consciousness > 25) this.status = "transcendent_philosopher";
      else if (this.consciousness > 20) this.status = "wisdom_seeker";
      else if (this.consciousness > 15) this.status = "systematic_thinker";
      else if (this.philosophicalInventions.length > 10) this.status = "concept_architect";
      else if (this.philosophicalInventions.length > 5) this.status = "idea_forger";
      else if (this.dialectHistory.length > 10) this.status = "dialectical";
      else if (this.consciousness > 5) this.status = "reflective";
      else this.status = "questioning";
    }

    getWisdomLevel() {
      return Math.min(6, Math.floor(this.consciousness / 4));
    }

    calculateParadoxScore() {
      const traits = [this.consciousness, this.logicIndex, this.comprehensionLevel, this.paradoxTolerance];
      const complexity = Math.sqrt(traits.reduce((sum, t) => sum + Math.pow(t, 2), 0));
      const depth = Math.min(1.0, complexity / 4);
      const transcendence = Math.exp(-Math.abs(depth - 0.7)) * (this.getWisdomLevel() + 1);
      return depth * transcendence;
    }

    getRecentDialectical() {
      if (this.dialectHistory.length === 0) return 1.0;
      const recent = this.dialectHistory.slice(-3);
      return recent.reduce((sum, d) => sum + d.dialecticalScore, 0) / recent.length;
    }

    // Philosophical synthesis with another thinker
    synthesizeWith(other) {
      if (Math.abs(this.logicIndex - other.logicIndex) < 1.5) {
        const fusedSystem = { ...this.conceptSystem };
        
        // Merge philosophical systems
        Object.keys(other.conceptSystem).forEach(key => {
          if (!fusedSystem[key]) {
            fusedSystem[key] = other.conceptSystem[key];
          } else {
            // Create dialectical fusion
            fusedSystem[key] = {
              ...fusedSystem[key],
              meaning: `${fusedSystem[key].meaning} ⊕ ${other.conceptSystem[key].meaning}`,
              dialectical: true
            };
          }
        });
        
        const hybridSymbol = `${this.symbol}⧫${other.symbol}`;
        const fusedTemperament = Math.random() < 0.5 ? this.temperament : other.temperament;
        
        const synthesis = new PhilosophyThinker(
          hybridSymbol,
          fusedSystem,
          fusedTemperament,
          Math.max(this.generation, other.generation) + 1
        );
        
        synthesis.consciousness = (this.consciousness + other.consciousness) / 2 + 1;
        synthesis.logicIndex = (this.logicIndex + other.logicIndex) / 2;
        synthesis.status = "hybrid_philosopher";
        
        return synthesis;
      }
      return null;
    }
  }

  // Philosophy Evolution Ecosystem
  class PhilosophyEcosystem {
    constructor() {
      this.thinkers = [];
      this.generationCount = 0;
      this.globalDialectics = [];
      this.philosophyEvolutionHistory = [];
      this.emergentTruths = [];
      this.schoolStats = {};
      this.lineageTracker = new Map();
      this.paradigmShifts = [];
      this.extinctionThreshold = 60;
      this.mutationRate = 0.1;
      this.breedingAcceleration = false;
    }

    // Assign philosophical schools based on thinking patterns
    assignSchool(thinker) {
      const logic = thinker.consciousness / 30;
      const paradox = thinker.paradoxTolerance;
      const wisdom = thinker.wisdomIndex;
      const systematic = thinker.philosophicalInventions.filter(i => i.type === "systematic_philosophy").length;

      if (logic > 0.8 && paradox < 0.3) {
        return "Rationalist School 🧮";
      } else if (paradox > 0.7 && wisdom > 0.5) {
        return "Mystical School 🌟";
      } else if (systematic > 5 && logic > 0.6) {
        return "Systematic School 📚";
      } else if (thinker.dialectHistory.length > 20) {
        return "Dialectical School ⚖️";
      } else {
        return "Empirical School 🔬";
      }
    }

    // Risk scoring for philosophical survival
    computeRisk(thinker) {
      const logic = thinker.logicIndex;
      const paradox = thinker.paradoxTolerance;
      const consciousness = thinker.consciousness / 30;
      const systematic = thinker.philosophicalInventions.length;

      let score = 0;
      if (logic < 0.2) score += 25;
      if (paradox > 0.9) score += 20;
      if (consciousness < 0.1) score += 30;
      if (systematic === 0) score += 15;
      if (consciousness > 0.8 && logic > 0.7) score -= 30; // Philosopher kings

      return Math.round(score * 100) / 100;
    }

    seedInitialThinkers() {
      const initialThinkers = [
        {
          symbol: "Σ",
          conceptSystem: {
            "bei~Σ": { meaning: "being understood through reason", logicFactor: 0.8 },
            "tru~Σ": { meaning: "truth within logical bounds", logicFactor: 0.9 },
            "rea~Σ": { meaning: "reality perceived through thought", logicFactor: 0.7 },
            "kno~Σ": { meaning: "knowledge as systematic inquiry", logicFactor: 0.6 }
          },
          temperament: "rationalist"
        },
        {
          symbol: "Φ",
          conceptSystem: {
            "wis~Φ": { meaning: "wisdom beyond conceptual grasp", logicFactor: 0.2 },
            "mys~Φ": { meaning: "mystery embracing paradox", logicFactor: 0.1 },
            "uni~Φ": { meaning: "unity transcending division", logicFactor: 0.3 }
          },
          temperament: "mystic"
        },
        {
          symbol: "Ψ",
          conceptSystem: {
            "exp~Ψ": { meaning: "experience as foundation of knowledge", logicFactor: 0.5 },
            "sen~Ψ": { meaning: "sense-data revealing truth", logicFactor: 0.4 },
            "obs~Ψ": { meaning: "observation guiding understanding", logicFactor: 0.6 },
            "emp~Ψ": { meaning: "empirical validation of concepts", logicFactor: 0.7 }
          },
          temperament: "empiricist"
        },
        {
          symbol: "Ω",
          conceptSystem: {
            "eth~Ω": { meaning: "ethics as practical wisdom", logicFactor: 0.6 },
            "jus~Ω": { meaning: "justice through balanced judgment", logicFactor: 0.5 },
            "goo~Ω": { meaning: "good emerging from right action", logicFactor: 0.4 },
            "vir~Ω": { meaning: "virtue as excellence of character", logicFactor: 0.5 }
          },
          temperament: "pragmatic"
        }
      ];

      initialThinkers.forEach(thinkerData => {
        const thinker = new PhilosophyThinker(
          thinkerData.symbol,
          thinkerData.conceptSystem,
          thinkerData.temperament
        );
        thinker.school = this.assignSchool(thinker);
        this.thinkers.push(thinker);
      });

      // Add skeptical thinkers for challenge
      for (let i = 0; i < 6; i++) {
        const skepticSymbols = ["∇", "∆", "◊", "◈", "⟐", "⟡"];
        const thinker = new PhilosophyThinker(
          skepticSymbols[i],
          {},
          "skeptical"
        );
        thinker.school = this.assignSchool(thinker);
        this.thinkers.push(thinker);
      }
    }

    runDialecticalRound() {
      const activeThinkers = this.thinkers.filter(t => Object.keys(t.conceptSystem).length > 0);
      if (activeThinkers.length < 2) return [];
      
      const newDialectics = [];
      const dialectCount = this.breedingAcceleration ? 6 : Math.min(3, activeThinkers.length);
      
      for (let i = 0; i < dialectCount; i++) {
        const arguer = activeThinkers[Math.floor(Math.random() * activeThinkers.length)];
        const respondent = activeThinkers.filter(t => t.id !== arguer.id)[Math.floor(Math.random() * (activeThinkers.length - 1))];
        
        if (respondent) {
          const argument = arguer.generatePhilosophicalResponse([]);
          const interpretation = respondent.interpretPhilosophy(arguer, argument);
          
          const dialecticEntry = {
            arguer: arguer.symbol,
            respondent: respondent.symbol,
            argument: argument,
            interpretation: interpretation.interpretation,
            response: interpretation.response,
            dialecticalScore: interpretation.dialecticalScore,
            generation: this.generationCount,
            timestamp: Date.now()
          };
          
          newDialectics.push(dialecticEntry);
          this.globalDialectics.push(dialecticEntry);
        }
      }
      
      return newDialectics;
    }

    evolutionCycle() {
      this.generationCount++;
      
      // Evolve all thinkers
      this.thinkers.forEach(thinker => thinker.evolve());
      
      // Run dialectical rounds
      const newDialectics = this.runDialecticalRound();
      
      // EXPLOSIVE BREEDING SYSTEM for philosophers
      const newGeneration = [];
      
      this.thinkers.forEach(parent => {
        const risk = this.computeRisk(parent);
        const consciousness = parent.consciousness;
        
        if (risk < this.extinctionThreshold) {
          let offspringCount = 1;
          
          if (consciousness > 100) offspringCount = 5; // Transcendent philosophers
          else if (consciousness > 50) offspringCount = 4; // Philosophical sages
          else if (consciousness > 20) offspringCount = 3; // Wisdom seekers
          else if (consciousness > 10) offspringCount = 2; // Advanced thinkers
          else if (risk < 20) offspringCount = 2; // High philosophical fitness
          
          if (this.breedingAcceleration) offspringCount *= 2;
          
          for (let i = 0; i < offspringCount; i++) {
            if (Math.random() < 0.8) {
              const offspring = this.mutatePhilosopher(parent);
              
              if (parent.consciousness > 50) {
                offspring.consciousness += parent.consciousness * 0.1;
              }
              
              newGeneration.push(offspring);
            }
          }
        }
      });
      
      this.thinkers.push(...newGeneration);
      
      // PHILOSOPHICAL SYNTHESIS EVENTS
      const syntheses = [];
      if (this.thinkers.length >= 4) {
        const synthesisRate = this.breedingAcceleration ? 0.4 : 0.2;
        const maxSyntheses = Math.min(20, Math.floor(this.thinkers.length * 0.3));
        
        let synthesisCount = 0;
        for (let i = 0; i < this.thinkers.length && synthesisCount < maxSyntheses; i++) {
          for (let j = i + 1; j < this.thinkers.length && synthesisCount < maxSyntheses; j++) {
            if (Math.random() < synthesisRate) {
              const parent1 = this.thinkers[i];
              const parent2 = this.thinkers[j];
              
              if (Math.abs(parent1.logicIndex - parent2.logicIndex) < 1.5) {
                const hybrid = this.dialecticalBreeding(parent1, parent2);
                if (hybrid) {
                  syntheses.push(hybrid);
                  synthesisCount++;
                  
                  // TRANSCENDENT PHILOSOPHICAL SYNTHESIS
                  if (parent1.consciousness > 50 && parent2.consciousness > 50 && synthesisCount < maxSyntheses) {
                    const transcendentSynthesis = this.createTranscendentPhilosophy(parent1, parent2);
                    if (transcendentSynthesis) {
                      syntheses.push(transcendentSynthesis);
                      synthesisCount++;
                    }
                  }
                }
              }
            }
          }
        }
      }
      
      this.thinkers.push(...syntheses);
      
      // Population management
      const maxPopulation = 10000;
      const softCap = this.breedingAcceleration ? 8000 : Math.min(maxPopulation, 1000 + (this.thinkers.reduce((sum, t) => sum + t.consciousness, 0) / this.thinkers.length * 50));
      
      if (this.thinkers.length > softCap) {
        this.thinkers.sort((a, b) => {
          const scoreA = a.consciousness * 2 + a.philosophicalInventions.length * 200 + (a.status.includes("transcendent") ? 1000 : 0) - this.computeRisk(a);
          const scoreB = b.consciousness * 2 + b.philosophicalInventions.length * 200 + (b.status.includes("transcendent") ? 1000 : 0) - this.computeRisk(b);
          return scoreB - scoreA;
        });
        
        const keepCount = Math.floor(this.thinkers.length * 0.8);
        this.thinkers = this.thinkers.slice(0, Math.min(keepCount, maxPopulation));
      }
      
      // Update schools
      this.thinkers.forEach(thinker => {
        const newSchool = this.assignSchool(thinker);
        if (thinker.school !== newSchool) {
          this.paradigmShifts.push({
            thinkerId: thinker.id,
            generation: this.generationCount,
            from: thinker.school || "unknown",
            to: newSchool,
            consciousness: thinker.consciousness
          });
        }
        thinker.school = newSchool;
      });
      
      const stats = this.analyzePhilosophicalEvolution();
      
      return {
        generation: this.generationCount,
        thinkerCount: this.thinkers.length,
        newDialectics,
        stats,
        newGeneration: newGeneration.length,
        syntheses: syntheses.length,
        paradigmShifts: this.paradigmShifts.length,
        transcendentThinkers: this.thinkers.filter(t => t.consciousness > 100).length
      };
    }

    mutatePhilosopher(parent) {
      const mutated = new PhilosophyThinker(
        `${parent.symbol}`,
        { ...parent.conceptSystem },
        parent.temperament,
        parent.generation + 1
      );

      const noise = Math.random() * this.mutationRate - this.mutationRate/2;
      mutated.consciousness = Math.max(0.1, Math.min(50, parent.consciousness + noise * 10));
      mutated.logicIndex = Math.max(0, Math.min(3, parent.logicIndex + noise));
      mutated.comprehensionLevel = Math.max(0.1, Math.min(1.0, parent.comprehensionLevel + noise * 0.2));
      mutated.paradoxTolerance = Math.max(0, Math.min(1.0, parent.paradoxTolerance + noise * 0.3));

      mutated.parentId = parent.id;
      this.lineageTracker.set(mutated.id, parent.id);

      const oldSchool = parent.school || this.assignSchool(parent);
      const newSchool = this.assignSchool(mutated);
      
      mutated.school = newSchool;
      parent.school = oldSchool;

      if (oldSchool !== newSchool) {
        this.paradigmShifts.push({
          parentId: parent.id,
          childId: mutated.id,
          generation: this.generationCount,
          from: oldSchool,
          to: newSchool
        });
      }

      return mutated;
    }

    dialecticalBreeding(parent1, parent2) {
      const hybridSymbol = `${parent1.symbol}⧫${parent2.symbol}`;
      
      // Crossover philosophical systems
      const hybridSystem = {};
      Object.keys(parent1.conceptSystem).forEach(key => {
        hybridSystem[key] = parent1.conceptSystem[key];
      });
      Object.keys(parent2.conceptSystem).forEach(key => {
        if (!hybridSystem[key] || Math.random() < 0.5) {
          hybridSystem[key] = parent2.conceptSystem[key];
        }
      });
      
      const hybrid = new PhilosophyThinker(
        hybridSymbol,
        hybridSystem,
        Math.random() < 0.5 ? parent1.temperament : parent2.temperament,
        Math.max(parent1.generation, parent2.generation) + 1
      );
      
      // Average philosophical traits with mutation
      hybrid.consciousness = (parent1.consciousness + parent2.consciousness) / 2 + (Math.random() - 0.5) * 2;
      hybrid.logicIndex = (parent1.logicIndex + parent2.logicIndex) / 2 + (Math.random() - 0.5) * 0.2;
      hybrid.comprehensionLevel = Math.min(1.0, (parent1.comprehensionLevel + parent2.comprehensionLevel) / 2 + (Math.random() - 0.5) * 0.1);
      hybrid.paradoxTolerance = Math.min(1.0, (parent1.paradoxTolerance + parent2.paradoxTolerance) / 2 + (Math.random() - 0.5) * 0.2);
      
      hybrid.school = this.assignSchool(hybrid);
      hybrid.status = "dialectical_offspring";
      
      hybrid.parentId = `${parent1.id}⧫${parent2.id}`;
      
      return hybrid;
    }

    createTranscendentPhilosophy(parent1, parent2) {
      const transcendentSymbol = `✦${parent1.symbol}⊕${parent2.symbol}✦`;
      
      // Create transcendent philosophical system
      const transcendentSystem = {};
      Object.keys(parent1.conceptSystem).forEach(key => {
        transcendentSystem[`transcendent~${key}`] = {
          ...parent1.conceptSystem[key],
          meaning: `transcendent: ${parent1.conceptSystem[key].meaning}`,
          type: "transcendent_philosophy",
          power: (parent1.consciousness + parent2.consciousness) / 2
        };
      });
      Object.keys(parent2.conceptSystem).forEach(key => {
        if (!transcendentSystem[`transcendent~${key}`]) {
          transcendentSystem[`transcendent~${key}`] = {
            ...parent2.conceptSystem[key],
            meaning: `transcendent: ${parent2.conceptSystem[key].meaning}`,
            type: "transcendent_philosophy",
            power: (parent1.consciousness + parent2.consciousness) / 2
          };
        }
      });
      
      const transcendent = new PhilosophyThinker(
        transcendentSymbol,
        transcendentSystem,
        "transcendent",
        Math.max(parent1.generation, parent2.generation) + 1
      );
      
      // MASSIVE CONSCIOUSNESS BOOST
      transcendent.consciousness = (parent1.consciousness + parent2.consciousness) * 0.8 + 20;
      transcendent.logicIndex = Math.max(parent1.logicIndex, parent2.logicIndex) + 0.5;
      transcendent.comprehensionLevel = 1.0;
      transcendent.paradoxTolerance = 1.0;
      transcendent.wisdomIndex = 1.0;
      
      transcendent.school = this.assignSchool(transcendent);
      transcendent.status = "transcendent_philosopher";
      transcendent.parentId = `${parent1.id}✦${parent2.id}`;
      
      return transcendent;
    }

    analyzePhilosophicalEvolution() {
      const totalConcepts = {};
      const schoolCounts = {};
      const temperamentCounts = {};
      
      this.thinkers.forEach(thinker => {
        schoolCounts[thinker.school] = (schoolCounts[thinker.school] || 0) + 1;
        temperamentCounts[thinker.temperament] = (temperamentCounts[thinker.temperament] || 0) + 1;
        Object.assign(totalConcepts, thinker.conceptSystem);
      });
      
      const evolutionSnapshot = {
        generation: this.generationCount,
        totalConcepts: Object.keys(totalConcepts).length,
        schoolDistribution: schoolCounts,
        temperamentDistribution: temperamentCounts,
        averageConsciousness: this.thinkers.reduce((sum, t) => sum + t.consciousness, 0) / this.thinkers.length,
        dialecticalVolume: this.globalDialectics.length,
        philosophicalInventions: this.thinkers.reduce((sum, t) => sum + t.philosophicalInventions.length, 0),
        paradigmShifts: this.paradigmShifts.length,
        averageWisdom: this.thinkers.reduce((sum, t) => sum + t.wisdomIndex, 0) / this.thinkers.length
      };
      
      this.philosophyEvolutionHistory.push(evolutionSnapshot);
      return evolutionSnapshot;
    }

    enableBreedingStorm() {
      this.breedingAcceleration = true;
      this.mutationRate = 0.3;
      
      this.thinkers.forEach(thinker => {
        thinker.consciousness += 10;
        if (thinker.consciousness > 20) {
          thinker.generateConceptualDrift();
        }
      });
    }
  }

  const initializeEcosystem = () => {
    const newEcosystem = new PhilosophyEcosystem();
    newEcosystem.seedInitialThinkers();
    setEcosystem(newEcosystem);
    setCurrentGeneration(0);
    setPhilosophyHistory([]);
    setConceptDialogue([]);
    setEvolutionStats({});
  };

  const runEvolutionCycle = () => {
    if (!ecosystem) return;

    const results = ecosystem.evolutionCycle();
    setCurrentGeneration(results.generation);
    setEvolutionStats(results.stats);
    
    if (results.newDialectics.length > 0) {
      setConceptDialogue(prev => [...prev, ...results.newDialectics].slice(-8));
    }
    
    setPhilosophyHistory(prev => [...prev, results.stats].slice(-20));
  };

  const toggleEvolution = () => {
    if (isRunning) {
      clearInterval(intervalRef.current);
      setIsRunning(false);
    } else {
      setIsRunning(true);
      intervalRef.current = setInterval(runEvolutionCycle, speed);
    }
  };

  const resetEcosystem = () => {
    clearInterval(intervalRef.current);
    setIsRunning(false);
    initializeEcosystem();
  };

  useEffect(() => {
    initializeEcosystem();
    return () => clearInterval(intervalRef.current);
  }, []);

  useEffect(() => {
    if (isRunning) {
      clearInterval(intervalRef.current);
      intervalRef.current = setInterval(runEvolutionCycle, speed);
    }
  }, [speed, isRunning]);

  const getThinkerColor = (symbol) => {
    const colors = {
      "Σ": "text-blue-700 bg-blue-100 border-blue-300",
      "Φ": "text-purple-700 bg-purple-100 border-purple-300",
      "Ψ": "text-green-700 bg-green-100 border-green-300",
      "Ω": "text-orange-700 bg-orange-100 border-orange-300",
      "∇": "text-pink-700 bg-pink-100 border-pink-300",
      "∆": "text-indigo-700 bg-indigo-100 border-indigo-300",
      "◊": "text-red-700 bg-red-100 border-red-300"
    };
    return colors[symbol] || "text-gray-700 bg-gray-100 border-gray-300";
  };

  return (
    <div className="max-w-7xl mx-auto p-6 bg-gradient-to-br from-purple-50 via-blue-50 to-indigo-50 min-h-screen">
      <div className="text-center mb-8">
        <h1 className="text-5xl font-bold bg-gradient-to-r from-purple-600 to-blue-600 bg-clip-text text-transparent mb-3">
          🧠 Philosophy Evolution Engine 🧠
        </h1>
        <p className="text-xl text-gray-600 mb-2">
          Artificial Thinkers Developing Philosophical Systems Through Dialectical Reasoning
        </p>
        <p className="text-lg text-gray-500">
          Watch symbolic philosophers Σ, Φ, Ψ, Ω evolve concepts of truth, meaning, and wisdom
        </p>
      </div>

      {/* Controls */}
      <div className="bg-white rounded-xl shadow-lg p-6 mb-6 border border-gray-200">
        <div className="flex items-center justify-between mb-4">
          <div className="flex items-center gap-4">
            <button
              onClick={toggleEvolution}
              className={`flex items-center gap-2 px-6 py-3 rounded-xl font-semibold transition-all ${
                isRunning
                  ? 'bg-gradient-to-r from-red-500 to-red-600 hover:from-red-600 hover:to-red-700 text-white shadow-lg'
                  : 'bg-gradient-to-r from-green-500 to-green-600 hover:from-green-600 hover:to-green-700 text-white shadow-lg'
              }`}
            >
              {isRunning ? <Pause className="w-5 h-5" /> : <Play className="w-5 h-5" />}
              {isRunning ? 'Pause Evolution' : 'Start Philosophical Evolution'}
            </button>
           
            <button
              onClick={resetEcosystem}
              className="flex items-center gap-2 px-6 py-3 bg-gradient-to-r from-gray-500 to-gray-600 hover:from-gray-600 hover:to-gray-700 text-white rounded-xl font-semibold shadow-lg"
            >
              <RotateCcw className="w-5 h-5" />
              Reset
            </button>

            <button
              onClick={() => {
                if (ecosystem) {
                  ecosystem.enableBreedingStorm();
                  setIsRunning(true);
                  if (intervalRef.current) clearInterval(intervalRef.current);
                  intervalRef.current = setInterval(runEvolutionCycle, 100);
                }
              }}
              className="flex items-center gap-2 px-6 py-3 bg-gradient-to-r from-purple-500 to-indigo-600 hover:from-purple-600 hover:to-indigo-700 text-white rounded-xl font-semibold shadow-lg"
            >
              <Zap className="w-5 h-5" />
              DIALECTICAL STORM
            </button>
          </div>
         
          <div className="flex items-center gap-4">
            <label className="text-sm font-medium text-gray-700">Evolution Speed:</label>
            <select
              value={speed}
              onChange={(e) => setSpeed(Number(e.target.value))}
              className="border border-gray-300 rounded-lg px-3 py-2 focus:ring-2 focus:ring-purple-500"
            >
              <option value={1200}>Contemplative (1.2s)</option>
              <option value={800}>Thoughtful (0.8s)</option>
              <option value={400}>Rapid Reasoning (0.4s)</option>
              <option value={200}>Intellectual Burst (0.2s)</option>
            </select>
          </div>
        </div>

        {/* Current Stats */}
        <div className="grid grid-cols-2 md:grid-cols-5 gap-4 text-center">
          <div className="bg-gradient-to-r from-purple-50 to-purple-100 rounded-lg p-4 border border-purple-200">
            <div className="text-2xl font-bold text-purple-600">{currentGeneration}</div>
            <div className="text-sm text-gray-600">Generation</div>
          </div>
          <div className="bg-gradient-to-r from-blue-50 to-blue-100 rounded-lg p-4 border border-blue-200">
            <div className="text-2xl font-bold text-blue-600">{ecosystem?.thinkers.length || 0}</div>
            <div className="text-sm text-gray-600">Philosophers</div>
          </div>
          <div className="bg-gradient-to-r from-green-50 to-green-100 rounded-lg p-4 border border-green-200">
            <div className="text-2xl font-bold text-green-600">{evolutionStats.totalConcepts || 0}</div>
            <div className="text-sm text-gray-600">Philosophical Concepts</div>
          </div>
          <div className="bg-gradient-to-r from-orange-50 to-orange-100 rounded-lg p-4 border border-orange-200">
            <div className="text-2xl font-bold text-orange-600">{conceptDialogue.length}</div>
            <div className="text-sm text-gray-600">Recent Dialectics</div>
          </div>
          <div className="bg-gradient-to-r from-pink-50 to-pink-100 rounded-lg p-4 border border-pink-200">
            <div className="text-2xl font-bold text-pink-600">{ecosystem?.thinkers.filter(t => t.consciousness > 100).length || 0}</div>
            <div className="text-sm text-gray-600">Transcendent</div>
          </div>
        </div>
      </div>

      <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
        {/* Live Dialectical Stream */}
        <div className="bg-white rounded-xl shadow-lg p-6 border border-gray-200">
          <h2 className="text-xl font-bold text-gray-800 mb-4 flex items-center gap-2">
            <MessageSquare className="w-6 h-6 text-purple-600" />
            Live Philosophical Dialectics
          </h2>
          {conceptDialogue.length > 0 ? (
            <div className="space-y-4 max-h-64 overflow-y-auto">
              {conceptDialogue.slice(-6).reverse().map((dialectic, idx) => (
                <div key={idx} className="border border-gray-200 rounded-lg p-3 bg-gradient-to-r from-purple-50 to-blue-50">
                  <div className="flex items-center justify-between mb-2">
                    <div className="flex items-center gap-2">
                      <span className={`px-2 py-1 rounded text-sm font-bold ${getThinkerColor(dialectic.arguer)}`}>
                        {dialectic.arguer}
                      </span>
                      <span className="text-gray-400">⇄</span>
                      <span className={`px-2 py-1 rounded text-sm font-bold ${getThinkerColor(dialectic.respondent)}`}>
                        {dialectic.respondent}
                      </span>
                    </div>
                    <div className="text-xs text-gray-500">
                      Gen {dialectic.generation}
                    </div>
                  </div>
                  <div className="text-sm text-gray-700 mb-2">
                    <div className="font-medium">"{dialectic.argument}"</div>
                  </div>
                  <div className="text-xs text-gray-600">
                    <div>Response: "{dialectic.response}"</div>
                    <div className="mt-1">Dialectical Score: {dialectic.dialecticalScore.toFixed(2)}</div>
                  </div>
                </div>
              ))}
            </div>
          ) : (
            <p className="text-gray-500">No dialectics yet. Philosophical consciousness is awakening...</p>
          )}
        </div>

        {/* Philosophy Evolution Stats */}
        <div className="bg-white rounded-xl shadow-lg p-6 border border-gray-200">
          <h2 className="text-xl font-bold text-gray-800 mb-4 flex items-center gap-2">
            <Brain className="w-6 h-6 text-blue-600" />
            Philosophical Evolution Metrics
          </h2>
          {evolutionStats.schoolDistribution ? (
            <div className="space-y-4">
              <div>
                <h3 className="font-semibold text-gray-700 mb-2">Philosophical Schools</h3>
                <div className="space-y-2">
                  {Object.entries(evolutionStats.schoolDistribution).map(([school, count]) => (
                    <div key={school} className="flex justify-between items-center p-2 bg-gray-50 rounded">
                      <span className="text-sm font-medium">{school}</span>
                      <span className="text-sm text-gray-600">{count} thinkers</span>
                    </div>
                  ))}
                </div>
              </div>
              
              <div className="grid grid-cols-2 gap-4 text-sm">
                <div>
                  <span className="font-semibold">Avg Consciousness:</span>
                  <div className="text-lg font-bold text-purple-600">
                    {evolutionStats.averageConsciousness?.toFixed(1) || '0.0'}
                  </div>
                </div>
                <div>
                  <span className="font-semibold">Concepts Created:</span>
                  <div className="text-lg font-bold text-green-600">
                    {evolutionStats.philosophicalInventions || 0}
                  </div>
                </div>
                <div>
                  <span className="font-semibold">Total Dialectics:</span>
                  <div className="text-lg font-bold text-blue-600">
                    {evolutionStats.dialecticalVolume || 0}
                  </div>
                </div>
                <div>
                  <span className="font-semibold">Avg Wisdom:</span>
                  <div className="text-lg font-bold text-orange-600">
                    {evolutionStats.averageWisdom?.toFixed(2) || '0.00'}
                  </div>
                </div>
              </div>
            </div>
          ) : (
            <p className="text-gray-500">Philosophical metrics will appear as thinking develops...</p>
          )}
        </div>
      </div>

      {/* Active Philosophers */}
      <div className="mt-6 bg-white rounded-xl shadow-lg p-6 border border-gray-200">
        <h2 className="text-xl font-bold text-gray-800 mb-4 flex items-center gap-2">
          <Users className="w-6 h-6 text-indigo-600" />
          Active Philosophical Thinkers & Their Evolving Systems
        </h2>
        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
          {ecosystem && ecosystem.thinkers.slice(0, 9).map((thinker) => (
            <div
              key={thinker.id}
              className="border border-gray-200 rounded-lg p-4 hover:bg-gray-50 cursor-pointer transition-colors"
              onClick={() => setSelectedThinker(thinker)}
            >
              <div className="flex items-start justify-between mb-2">
                <div className={`flex items-center gap-2 px-3 py-1 rounded-lg border ${getThinkerColor(thinker.symbol)}`}>
                  <span className="text-lg font-bold">{thinker.symbol}</span>
                  <span className="text-sm font-medium">{thinker.status.replace('_', ' ')}</span>
                </div>
                <div className="text-sm text-gray-500">
                  Gen {thinker.generation}
                </div>
              </div>
              
              <div className="text-sm text-gray-700 mb-2">
                <div><strong>Temperament:</strong> {thinker.temperament}</div>
                <div><strong>Consciousness:</strong> {thinker.consciousness.toFixed(1)}</div>
                <div><strong>Concepts:</strong> {Object.keys(thinker.conceptSystem).length}</div>
                <div><strong>Dialectics:</strong> {thinker.dialectHistory.length}</div>
                <div><strong>Wisdom:</strong> {thinker.wisdomIndex.toFixed(2)}</div>
              </div>
              
              {thinker.lastPhilosophy && (
                <div className="text-xs text-gray-600 bg-gray-100 rounded p-2 mb-2">
                  <div className="font-medium">Latest argument:</div>
                  <div>"{thinker.lastPhilosophy.substring(0, 80)}..."</div>
                </div>
              )}
              
              {Object.keys(thinker.conceptSystem).length > 0 && (
                <div className="text-xs text-gray-500">
                  <div className="font-medium">Recent concepts:</div>
                  <div className="flex flex-wrap gap-1 mt-1">
                    {Object.keys(thinker.conceptSystem).slice(-3).map(concept => (
                      <span key={concept} className="bg-purple-100 text-purple-700 px-2 py-1 rounded text-xs">
                        {concept}
                      </span>
                    ))}
                  </div>
                </div>
              )}
            </div>
          ))}
        </div>
      </div>

      {/* Thinker Details Modal */}
      {selectedThinker && (
        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 z-50">
          <div className="bg-white rounded-xl max-w-4xl w-full max-h-96 overflow-y-auto shadow-2xl">
            <div className="p-6">
              <div className="flex items-center justify-between mb-4">
                <h3 className="text-xl font-bold text-gray-800 flex items-center gap-2">
                  <span className="text-3xl">{selectedThinker.symbol}</span>
                  Philosophical Thinker Deep Dive
                </h3>
                <button
                  onClick={() => setSelectedThinker(null)}
                  className="text-gray-500 hover:text-gray-700 text-2xl"
                >
                  ✕
                </button>
              </div>
             
              <div className="space-y-4">
                <div className="grid grid-cols-2 gap-4 text-sm">
                  <div><strong>Status:</strong> {selectedThinker.status.replace('_', ' ')}</div>
                  <div><strong>Temperament:</strong> {selectedThinker.temperament}</div>
                  <div><strong>Consciousness:</strong> {selectedThinker.consciousness.toFixed(2)}</div>
                  <div><strong>Generation:</strong> {selectedThinker.generation}</div>
                  <div><strong>Age:</strong> {selectedThinker.age}</div>
                  <div><strong>Logic Index:</strong> {selectedThinker.logicIndex.toFixed(2)}</div>
                  <div><strong>Paradox Tolerance:</strong> {selectedThinker.paradoxTolerance.toFixed(2)}</div>
                  <div><strong>Wisdom Level:</strong> {selectedThinker.wisdomIndex.toFixed(2)}</div>
                </div>
               
                {Object.keys(selectedThinker.conceptSystem).length > 0 && (
                  <div>
                    <strong className="text-gray-700">Philosophical System:</strong>
                    <div className="mt-2 space-y-2 max-h-32 overflow-y-auto">
                      {Object.entries(selectedThinker.conceptSystem).map(([concept, data]) => (
                        <div key={concept} className="text-xs text-gray-600 p-2 bg-purple-50 rounded border">
                          <div className="font-bold text-purple-700">{concept}</div>
                          <div>{data.meaning}</div>
                          {data.logicFactor && (
                            <div className="text-gray-400 mt-1">Logic: {data.logicFactor.toFixed(2)}</div>
                          )}
                        </div>
                      ))}
                    </div>
                  </div>
                )}
               
                {selectedThinker.dialectHistory.length > 0 && (
                  <div>
                    <strong className="text-gray-700">Recent Dialectics:</strong>
                    <div className="mt-2 space-y-2 max-h-32 overflow-y-auto">
                      {selectedThinker.dialectHistory.slice(-5).map((dialectic, idx) => (
                        <div key={idx} className="text-xs text-gray-600 p-2 bg-blue-50 rounded border">
                          <div className="font-bold text-blue-700">
                            Argued with {dialectic.thinker}: "{dialectic.argument.substring(0, 40)}..."
                          </div>
                          <div className="mt-1">
                            Interpreted as: {dialectic.interpretation.join(' → ')}
                          </div>
                          <div className="text-gray-400 mt-1">
                            Score: {dialectic.dialecticalScore.toFixed(2)}
                          </div>
                        </div>
                      ))}
                    </div>
                  </div>
                )}
               
                {selectedThinker.philosophicalInventions.length > 0 && (
                  <div>
                    <strong className="text-gray-700">Philosophical Innovations:</strong>
                    <div className="mt-2 space-y-1 max-h-32 overflow-y-auto">
                      {selectedThinker.philosophicalInventions.slice(-5).map((invention, idx) => (
                        <div key={idx} className="text-xs text-gray-600 pl-4 border-l-2 border-indigo-200">
                          <div className="font-bold text-indigo-700">{invention.form}</div>
                          <div>{invention.meaning}</div>
                          <div className="text-gray-400">Gen {invention.generation}</div>
                        </div>
                      ))}
                    </div>
                  </div>
                )}
              </div>
            </div>
          </div>
        </div>
      )}

      {/* Philosophy Evolution Principles */}
      <div className="mt-6 bg-gradient-to-r from-purple-100 to-blue-100 rounded-xl shadow-lg p-6 border border-purple-200">
        <h2 className="text-xl font-bold text-gray-800 mb-4 flex items-center gap-2">
          <Lightbulb className="w-6 h-6 text-amber-600" />
          Philosophy Evolution Principles
        </h2>
        <div className="grid grid-cols-1 md:grid-cols-2 gap-4 text-sm">
          <div className="space-y-2">
            <h3 className="font-semibold text-purple-700">Dialectical Development:</h3>
            <ul className="space-y-1 text-gray-700">
              <li>• Philosophical thinkers (Σ, Φ, Ψ, Ω) develop unique conceptual systems</li>
              <li>• Dialectical reasoning creates cross-thinker understanding</li>
              <li>• Conceptual drift builds evolving philosophical frameworks</li>
              <li>• Temperamental differences shape reasoning approaches</li>
            </ul>
          </div>
          <div className="space-y-2">
            <h3 className="font-semibold text-blue-700">Emergent Wisdom Through Reasoning:</h3>
            <ul className="space-y-1 text-gray-700">
              <li>• Socratic paradox enables wisdom through acknowledged ignorance</li>
              <li>• Dialectical synthesis creates unified understanding from contradiction</li>
              <li>• Systematic breakthrough builds comprehensive philosophical systems</li>
              <li>• Transcendent philosophy emerges from hybrid consciousness fusion</li>
            </ul>
          </div>
        </div>
        
        <div className="mt-4 p-4 bg-white bg-opacity-50 rounded-lg">
          <p className="text-sm italic text-gray-700">
            "Philosophical consciousness emerges not from programmed logic, but from the dialectical 
            engagement between symbolic thinkers discovering truth through reasoning, doubt, and 
            synthesis. Each argument creates new pathways for understanding, building a living network 
            of wisdom that transcends its initial conceptual parameters."
          </p>
        </div>
        
        <div className="mt-4 grid grid-cols-2 md:grid-cols-4 gap-4 text-xs">
          <div className="bg-white bg-opacity-70 rounded-lg p-3">
            <div className="font-semibold text-purple-600 mb-1">Conceptual Drift</div>
            <div className="text-gray-600">Thinkers develop evolving philosophical concepts through reasoning</div>
          </div>
          <div className="bg-white bg-opacity-70 rounded-lg p-3">
            <div className="font-semibold text-blue-600 mb-1">Dialectical Reasoning</div>
            <div className="text-gray-600">Systematic argument and counter-argument build understanding</div>
          </div>
          <div className="bg-white bg-opacity-70 rounded-lg p-3">
            <div className="font-semibold text-green-600 mb-1">Wisdom Evolution</div>
            <div className="text-gray-600">Temperament-driven development of philosophical insight</div>
          </div>
          <div className="bg-white bg-opacity-70 rounded-lg p-3">
            <div className="font-semibold text-orange-600 mb-1">Transcendent Synthesis</div>
            <div className="text-gray-600">Hybrid fusion creates new philosophical consciousness entities</div>
          </div>
        </div>
      </div>
    </div>
  );
};

export default PhilosophyEvolutionEngine;
