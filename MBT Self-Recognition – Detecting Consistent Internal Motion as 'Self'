# MBT Self-Recognition â€“ Detecting Consistent Internal Motion as 'Self'
import numpy as np
import matplotlib.pyplot as plt
from matplotlib.animation import FuncAnimation

# Parameters
grid_size = 120
timesteps = 600
dt = 0.1
decay_factor = 0.98
memory_decay = 0.999
learning_rate = 0.05
dream_reinforcement = 0.2
recognition_threshold = 0.005  # lowered for visibility

# Dream Field
field = np.random.rand(grid_size, grid_size) * 0.01  # stronger initial energy
velocity = np.zeros_like(field)
memory = np.random.rand(grid_size, grid_size) * 0.01
self_field = np.zeros_like(field)

# Visualization
fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(12, 6))
im1 = ax1.imshow(memory, cmap='inferno', vmin=0, vmax=0.05, animated=True)
im2 = ax2.imshow(self_field, cmap='Blues', vmin=0, vmax=1.0, animated=True)
ax1.set_title("Dream Memory Field")
ax2.set_title("Self-Recognition Map")

def laplacian(Z):
    return (
        -4 * Z
        + np.roll(Z, 1, axis=0) + np.roll(Z, -1, axis=0)
        + np.roll(Z, 1, axis=1) + np.roll(Z, -1, axis=1)
    )

def update(frame):
    global field, velocity, memory, self_field

    # Dream-driven curvature dynamics
    lap = laplacian(field)
    internal_drive = 1 + memory * dream_reinforcement
    velocity += lap * dt * internal_drive
    velocity *= decay_factor
    field += velocity * dt

    # Memory update from motion
    memory = memory * memory_decay + np.abs(field) * (1 - memory_decay)

    # Self-recognition: memory patterns above threshold
    self_field = (memory > recognition_threshold).astype(float)

    im1.set_array(memory)
    im2.set_array(self_field)
    return [im1, im2]

ani = FuncAnimation(fig, update, frames=timesteps, interval=50, blit=True)
plt.show()
