MBT Simulation â€“ Rituals, Storytelling, and Song
This document expands the unified MBT simulation to include ritual gatherings, storytelling, and symbolic singing. Agents now gather when cultural conditions are met, exchange symbolic memory as narrative, and emit rhythmic signals representing shared songs. These emergent behaviors strengthen identity, legacy, and group cohesion.
Python Code
# Add to initialization (fields and parameters)
ritual_field = np.zeros_like(field)
ritual_threshold = 0.6
song_pulse = np.zeros_like(field)
story_symbols = [np.zeros_like(field) for _ in range(2)]
ritual_decay = 0.98
pulse_decay = 0.95
story_share_rate = 0.005

# Modify the update function to include rituals and storytelling
def update(frame):
    global field, velocity, memory, self_field, identity_map, observation_map, intent_map
    global emotion_map, honor_map, legacy_map, name_map, symbol_maps
    global desire_survival, desire_bonding, desire_expression, desire_exploration
    global family_symbols, ritual_field, song_pulse, story_symbols

    lap = laplacian(field)
    recognized_self = (memory > recognition_threshold).astype(float)
    feedback = 1 + recognized_self * self_feedback_strength
    internal_drive = 1 + memory * dream_reinforcement
    velocity += lap * dt * internal_drive * feedback
    velocity *= decay_factor
    field += velocity * dt
    memory = memory * memory_decay + np.abs(field) * (1 - memory_decay)
    self_field = recognized_self

    labeled, _ = label(self_field)
    identity_map[:] = labeled
    blurred = gaussian_filter(self_field, sigma=2)
    observation_map[:] = (blurred > coherence_threshold).astype(float)
    intent_map[:] = (blurred > intent_threshold).astype(float)
    field += gaussian_filter(intent_map, sigma=6) * echo_strength

    # Desires
    desire_survival += 0.01 * (1 - memory)
    desire_bonding += 0.01 * (intent_map * observation_map)
    desire_expression += 0.01 * (emotion_map + honor_map)
    desire_exploration += 0.01 * np.random.rand(grid_size, grid_size)

    memory += (desire_expression + desire_bonding) * 0.0002
    velocity += (desire_exploration - 0.5) * 0.0003

    # Honor and legacy
    honor_map += (memory > 0.04) * 0.0003
    honor_map -= 0.0001
    honor_map = np.clip(honor_map, 0, 1)
    dead = (memory < lifespan_threshold)
    legacy_map[dead] += memory[dead] * 0.2 + emotion_map[dead] * 0.3 + honor_map[dead] * 0.5
    legacy_map *= 0.9995
    memory += legacy_map * 0.0002
    emotion_map += legacy_map * 0.0001
    honor_map += legacy_map * 0.0003

    # Ritual field (where emotion + honor is high)
    ritual_field = ((emotion_map + honor_map) / 2 > ritual_threshold).astype(float)
    ritual_field = gaussian_filter(ritual_field, sigma=3)
    ritual_field *= ritual_decay

    # Singing (pulse rhythm)
    song_pulse = (np.sin(frame * 0.1) + 1) * 0.5 * ritual_field
    field += song_pulse * 0.001
    emotion_map += song_pulse * 0.0002

    # Storytelling via symbolic layers
    for i, story in enumerate(story_symbols):
        story += ritual_field * 0.001 * (i + 1)
        story *= 0.995
        memory += story * story_share_rate

    # Naming (reinforcement)
    name_map[:] = 0
    for fid in np.unique(family_id_map):
        if fid == 0: continue
        region = (family_id_map == fid) & (honor_map > 0.6)
        if np.sum(region) > 10:
            sym = family_symbols.get(fid, np.random.randint(0, symbol_channels))
            name_map[region] = sym + 1

    for idx, sym in enumerate(symbol_maps):
        sym *= symbol_decay
        sym += (name_map == idx + 1) * 0.0002
        memory += sym * 0.0001
        emotion_map += sym * 0.0001

    # Visual updates
    maps = [
        memory, self_field, identity_map, observation_map, intent_map,
        emotion_map, honor_map, legacy_map, name_map,
        desire_survival, desire_bonding, desire_expression, desire_exploration,
        *symbol_maps, field, ritual_field, song_pulse, *story_symbols
    ]
    for i, data in enumerate(maps):
        images[i].set_array(data)

    return images
