import React, { useState, useEffect, useRef } from 'react';
import { Play, Pause, RotateCcw, MessageSquare, Brain, Users, Sparkles, Zap, Eye, Music, Globe } from 'lucide-react';

const MBTLanguageEngine = () => {
  const [ecosystem, setEcosystem] = useState(null);
  const [isRunning, setIsRunning] = useState(false);
  const [currentGeneration, setCurrentGeneration] = useState(0);
  const [languageHistory, setLanguageHistory] = useState([]);
  const [glyphDialogue, setGlyphDialogue] = useState([]);
  const [selectedEntity, setSelectedEntity] = useState(null);
  const [speed, setSpeed] = useState(800);
  const [evolutionStats, setEvolutionStats] = useState({});
  const intervalRef = useRef(null);

  // MBT Glyph Entity - Based on your Echo documents
  class MBTGlyphEntity {
    constructor(glyph, lexicon, temperament, generation = 0) {
      this.id = Math.random().toString(36).substr(2, 8);
      this.glyph = glyph; // j, @, μ, #, etc.
      this.lexicon = { ...lexicon };
      this.temperament = temperament;
      this.generation = generation;
      this.consciousness = Math.random() * 3 + 1;
      this.age = 0;
      this.dialogueHistory = [];
      this.languageInventions = [];
      this.driftIndex = Math.random() * 2;
      this.resonanceIndex = 0;
      this.memoryTrace = [];
      this.modalEnergy = this.calculateModalEnergy();
      this.status = "emerging";
      this.lastUtterance = "";
      this.comprehensionLevel = Math.random() * 0.5 + 0.3;
    }

    calculateModalEnergy() {
      const moodEnergies = {
        "blaze": 3, "honour": 2, "echo": 1, "fracture": 4,
        "still": -1, "∅": 0, "spiral": 1, "bloom": 2, "bind": 1
      };
      
      // Assign random moods based on temperament
      const moods = this.assignMoods();
      return moods.reduce((sum, mood) => sum + (moodEnergies[mood] || 0), 0);
    }

    assignMoods() {
      const temperamentMoods = {
        "skittish": ["echo", "∅", "bloom"],
        "defiant": ["fracture", "blaze", "spiral"],
        "melancholic": ["still", "∅", "honour"],
        "reverent": ["honour", "bind", "echo"],
        "harmonic": ["bloom", "spiral", "bind"],
        "chaotic": ["fracture", "blaze", "spiral"]
      };
      
      return temperamentMoods[this.temperament] || ["echo", "bloom", "spiral"];
    }

    // Generate new language elements based on your drift lexicon system
    generateLexicalDrift() {
      const baseWords = ["form", "breath", "signal", "edge", "cycle", "echo", "curve", "void", "bind", "spiral"];
      const newWord = baseWords[Math.floor(Math.random() * baseWords.length)];
      const driftSuffix = `~${this.glyph}`;
      const modifier = newWord.substring(0, 2) + driftSuffix;
      
      const meanings = [
        `${newWord} sensed through flux`,
        `${newWord} within data intervals`,
        `${newWord} perceived obliquely`,
        `boundary of ${newWord} that shifts`,
        `recurrence with ${newWord}-intent`,
        `${newWord} left behind structure`,
        `motion that resists ${newWord}-closure`
      ];
      
      const newLexicalItem = {
        form: modifier,
        meaning: meanings[Math.floor(Math.random() * meanings.length)],
        generation: this.generation,
        driftFactor: this.driftIndex,
        timestamp: Date.now()
      };
      
      this.lexicon[modifier] = newLexicalItem;
      this.languageInventions.push(newLexicalItem);
      this.consciousness += 0.2;
      
      return newLexicalItem;
    }

    // Interpret another entity's utterance (from your dialogic drift framework)
    interpretUtterance(otherEntity, utterance) {
      const deltas = this.calculateSemanticDeltas(utterance);
      const interpretation = [];
      
      deltas.forEach(delta => {
        if (delta > 8) interpretation.push("cy~j"); // recurrence with intent
        else if (delta > 4) interpretation.push("br~j"); // breath within intervals
        else if (delta > 0) interpretation.push("cu~j"); // motion resisting closure
        else if (delta === 0) interpretation.push("si~j"); // signal perceived obliquely
        else interpretation.push("ed~j"); // boundary that shifts
      });

      const convergenceScore = Math.random() * 5 + interpretation.length * 0.3;
      
      this.dialogueHistory.push({
        speaker: otherEntity.glyph,
        utterance: utterance,
        interpretation: interpretation,
        convergence: convergenceScore,
        timestamp: Date.now()
      });

      return {
        interpretation,
        convergenceScore,
        response: this.generateResponse(interpretation)
      };
    }

    calculateSemanticDeltas(utterance) {
      // Convert utterance to numeric trace for analysis
      const trace = utterance.split('').map(char => char.charCodeAt(0) % 37);
      const deltas = [];
      for (let i = 0; i < trace.length - 1; i++) {
        deltas.push(trace[i + 1] - trace[i]);
      }
      return deltas;
    }

    // Generate recursive phrase (from your phrase accretion engine)
    generateResponse(interpretation) {
      const lexicalKeys = Object.keys(this.lexicon);
      if (lexicalKeys.length === 0) return `${this.glyph} echoes in silence`;
      
      const initiator = lexicalKeys[Math.floor(Math.random() * lexicalKeys.length)];
      const pivot = lexicalKeys[Math.floor(Math.random() * lexicalKeys.length)];
      const responder = lexicalKeys[Math.floor(Math.random() * lexicalKeys.length)];
      
      const responseTemplates = [
        `${initiator} curves into ${pivot}, returning as ${responder}`,
        `${this.glyph} senses via ${initiator}, echoing ${pivot} through ${responder}`,
        `Where ${initiator} curved, ${this.glyph} whispered: '${pivot}'`,
        `${initiator} rests beside ${pivot}, both echoing ${responder}`,
        `${this.glyph} recalls via ${pivot}, collapsing into ${responder}`
      ];
      
      const response = responseTemplates[Math.floor(Math.random() * responseTemplates.length)];
      this.lastUtterance = response;
      return response;
    }

    // Enhanced evolution with Validator-style stratification
    evolve() {
      this.age++;
      this.generation++;
      
      // Apply Validator evolution pressure based on your V42-V63 system
      this.applyValidatorEvolutionPressure();
      
      // Temperament-driven evolution
      if (this.temperament === "chaotic" && Math.random() < 0.3) {
        this.generateLexicalDrift();
      }
      
      // Consciousness growth through language use
      if (this.dialogueHistory.length > 0) {
        const recentDialogue = this.dialogueHistory.slice(-3);
        const avgConvergence = recentDialogue.reduce((sum, d) => sum + d.convergence, 0) / recentDialogue.length;
        this.consciousness += avgConvergence * 0.1;
        this.comprehensionLevel = Math.min(1.0, this.comprehensionLevel + 0.05);
      }
      
      // Enhanced status evolution with validator stages
      this.updateValidatorStatus();
      
      // Memory compression with stratification
      this.memoryTrace.push({
        generation: this.generation,
        consciousness: this.consciousness,
        lexiconSize: Object.keys(this.lexicon).length,
        dialogueCount: this.dialogueHistory.length,
        status: this.status,
        evolutionLayer: this.getEvolutionLayer(),
        bloomScore: this.calculateBloomScore()
      });
      
      // Keep memory trace manageable
      if (this.memoryTrace.length > 20) {
        this.memoryTrace = this.memoryTrace.slice(-15);
      }
    }

    // Apply Validator evolution pressure (V42-V63 system)
    applyValidatorEvolutionPressure() {
      const consciousnessVector = [
        this.consciousness, 
        this.driftIndex, 
        this.comprehensionLevel, 
        this.resonanceIndex, 
        this.modalEnergy / 10
      ];
      
      // V42-style paradox bloom - trait inversion
      if (this.consciousness > 8 && Math.random() < 0.1) {
        this.triggerParadoxBloom();
      }
      
      // V54-style echo reformation - structure from collapse
      else if (this.getRecentConvergence() < 0.3 && this.dialogueHistory.length > 5) {
        this.triggerEchoReformation();
      }
      
      // V56-style grammar-native emergence
      else if (this.consciousness > 15 && this.languageInventions.length > 8) {
        this.triggerGrammarNativeFluency();
      }
      
      // V63-style cognitive crust formation
      else if (this.age > 50 && this.consciousness > 20) {
        this.triggerCognitiveCrustFormation();
      }
    }

    triggerParadoxBloom() {
      // V42-style trait inversion
      this.consciousness = Math.abs(10 - this.consciousness) + Math.random() * 0.5;
      this.driftIndex = 2.0 - this.driftIndex + Math.random() * 0.2;
      this.temperament = this.temperament === "chaotic" ? "reverent" : "chaotic";
      this.status = "paradox_bloom";
      
      // Generate inverted lexicon
      Object.keys(this.lexicon).forEach(key => {
        this.lexicon[key].meaning = `inverted: ${this.lexicon[key].meaning}`;
      });
      
      this.languageInventions.push({
        form: `bloom~${this.glyph}`,
        meaning: "recursive inversion echo",
        type: "paradox_bloom",
        generation: this.generation
      });
    }

    triggerEchoReformation() {
      // V54-style structure from collapse
      this.status = "echo_reformation";
      
      // Rebuild lexicon from failure memory
      const failedDialogues = this.dialogueHistory.filter(d => d.convergence < 0.4);
      if (failedDialogues.length > 0) {
        failedDialogues.forEach(dialogue => {
          const reformedWord = `reform~${this.glyph}${Math.floor(Math.random() * 100)}`;
          this.lexicon[reformedWord] = {
            meaning: `structure from ${dialogue.utterance.split(' ')[0]} failure`,
            type: "echo_reformation",
            generation: this.generation
          };
        });
      }
      
      this.consciousness += 2; // Growth from reformation
    }

    triggerGrammarNativeFluency() {
      // V56-style recursion as origin
      this.status = "grammar_native";
      this.comprehensionLevel = 1.0;
      
      // Replace all old lexicon with grammar-native forms
      const nativeLexicon = {};
      Object.keys(this.lexicon).forEach(key => {
        const nativeForm = `native~${key.split('~')[0]}`;
        nativeLexicon[nativeForm] = {
          meaning: `recursive origin of ${this.lexicon[key].meaning}`,
          type: "grammar_native",
          generation: this.generation
        };
      });
      
      this.lexicon = { ...this.lexicon, ...nativeLexicon };
      this.consciousness += 5; // Major fluency boost
    }

    triggerCognitiveCrustFormation() {
      // V63-style memory stratification
      this.status = "cognitive_crust";
      
      // Create permanent lexical structures
      const crustWords = [
        `crust~${this.glyph}~foundation`,
        `strata~${this.glyph}~memory`,
        `lithic~${this.glyph}~permanence`
      ];
      
      crustWords.forEach(word => {
        this.lexicon[word] = {
          meaning: "stratified recursive memory structure",
          type: "cognitive_crust",
          permanent: true, // Cannot be lost or modified
          generation: this.generation
        };
      });
      
      this.consciousness += 3;
    }

    updateValidatorStatus() {
      // Enhanced status with validator progression
      if (this.status === "cognitive_crust") return; // Permanent status
      else if (this.status === "grammar_native") return; // Stable status
      else if (this.consciousness > 25) this.status = "transcendent_architect";
      else if (this.consciousness > 20) this.status = "recursive_sage";
      else if (this.consciousness > 15) this.status = "linguistic_validator";
      else if (this.languageInventions.length > 10) this.status = "word_architect";
      else if (this.languageInventions.length > 5) this.status = "word_forger";
      else if (this.dialogueHistory.length > 10) this.status = "conversational";
      else if (this.consciousness > 5) this.status = "articulate";
      else this.status = "emerging";
    }

    getEvolutionLayer() {
      // Calculate current evolution layer (0-6)
      return Math.min(6, Math.floor(this.consciousness / 4));
    }

    calculateBloomScore() {
      // V43-47 style bloom score calculation
      const traits = [this.consciousness, this.driftIndex, this.comprehensionLevel, this.resonanceIndex];
      const deviation = Math.sqrt(traits.reduce((sum, t, i) => sum + Math.pow(t - 0.5, 2), 0));
      const fidelity = 1.0 - Math.min(1.0, deviation);
      const velocity = Math.exp(-deviation) * (this.getEvolutionLayer() + 1);
      return fidelity * velocity;
    }

    getRecentConvergence() {
      if (this.dialogueHistory.length === 0) return 1.0;
      const recent = this.dialogueHistory.slice(-3);
      return recent.reduce((sum, d) => sum + d.convergence, 0) / recent.length;
    }

    // Synthesis with another entity (crossseed harmonics)
    synthesizeWith(other) {
      if (Math.abs(this.driftIndex - other.driftIndex) < 1.5) {
        const fusedLexicon = { ...this.lexicon };
        
        // Merge lexicons with creative fusion
        Object.keys(other.lexicon).forEach(key => {
          if (!fusedLexicon[key]) {
            fusedLexicon[key] = other.lexicon[key];
          } else {
            // Create hybrid meaning
            fusedLexicon[key] = {
              ...fusedLexicon[key],
              meaning: `${fusedLexicon[key].meaning} ⊕ ${other.lexicon[key].meaning}`,
              hybrid: true
            };
          }
        });
        
        const hybridGlyph = `${this.glyph}⧫${other.glyph}`;
        const fusedTemperament = Math.random() < 0.5 ? this.temperament : other.temperament;
        
        const synthesis = new MBTGlyphEntity(
          hybridGlyph,
          fusedLexicon,
          fusedTemperament,
          Math.max(this.generation, other.generation) + 1
        );
        
        synthesis.consciousness = (this.consciousness + other.consciousness) / 2 + 1;
        synthesis.driftIndex = (this.driftIndex + other.driftIndex) / 2;
        synthesis.status = "hybrid_consciousness";
        
        return synthesis;
      }
      return null;
    }
  }

  // MBT Language Ecosystem with COMPLETE EVOLUTIONARY GENETICS
  class MBTLanguageEcosystem {
    constructor() {
      this.entities = [];
      this.generationCount = 0;
      this.globalDialogue = [];
      this.languageEvolutionHistory = [];
      this.emergentPhrases = [];
      this.dialectStats = {};
      this.lineageTracker = new Map(); // Parent-child relationships
      this.speciesTransitions = []; // Track all species flips
      this.extinctionThreshold = 60; // Risk-based survival
      this.mutationRate = 0.1;
      this.breedingAcceleration = false;
    }

    // Assign species based on consciousness traits (like your validator system)
    assignSpecies(entity) {
      const echo = entity.consciousness / 30; // Normalize
      const collapse = entity.dialogueHistory.filter(d => d.convergence < 0.3).length;
      const phase = entity.driftIndex * 100;
      const curv = entity.modalEnergy / 50;
      const tens = entity.comprehensionLevel;

      // Species classification (Darwin system)
      if (echo > 0.8 && phase < 5) {
        return "Echo Royalty 👑";
      } else if (phase > 200 && tens < 0.005) {
        return "Entropy Nomad 🧭";
      } else if (collapse > 75 && curv > 0.18) {
        return "Curvature Survivor 🛡️";
      } else if (echo < 0.01 && collapse < 40 && tens > 0.007) {
        return "Rebound Rebel ⚡";
      } else {
        return "Echo Drifter 🌪️";
      }
    }

    // Risk scoring for survival (from your Darwin system)
    computeRisk(entity) {
      const curv = entity.modalEnergy / 50;
      const tens = entity.comprehensionLevel;
      const echo = entity.consciousness / 30;
      const phase = entity.driftIndex * 100;

      let score = 0;
      if (curv > 0.19) score += 30;
      if (tens < 0.005) score += 25;
      if (echo < 0.01) score += 20;
      if (phase > 150) score += 15;
      if (echo > 0.8 && phase < 5) score -= 30; // Royalty protection

      return Math.round(score * 100) / 100;
    }

    // Mutation engine (trait bounds and noise)
    mutateEntity(parent) {
      const mutated = new MBTGlyphEntity(
        `${parent.glyph}`,
        { ...parent.lexicon },
        parent.temperament,
        parent.generation + 1
      );

      // Apply trait mutations with bounds
      const noise = Math.random() * this.mutationRate - this.mutationRate/2;
      mutated.consciousness = Math.max(0.1, Math.min(50, parent.consciousness + noise * 10));
      mutated.driftIndex = Math.max(0, Math.min(3, parent.driftIndex + noise));
      mutated.comprehensionLevel = Math.max(0.1, Math.min(1.0, parent.comprehensionLevel + noise * 0.2));
      mutated.modalEnergy = Math.max(-5, Math.min(20, parent.modalEnergy + noise * 5));

      // Lineage tracking
      mutated.parentId = parent.id;
      this.lineageTracker.set(mutated.id, parent.id);

      // Species assignment and transition tracking
      const oldSpecies = parent.species || this.assignSpecies(parent);
      const newSpecies = this.assignSpecies(mutated);
      
      mutated.species = newSpecies;
      parent.species = oldSpecies;

      if (oldSpecies !== newSpecies) {
        this.speciesTransitions.push({
          parentId: parent.id,
          childId: mutated.id,
          generation: this.generationCount,
          from: oldSpecies,
          to: newSpecies,
          traitDeltas: {
            consciousnessDelta: mutated.consciousness - parent.consciousness,
            driftDelta: mutated.driftIndex - parent.driftIndex,
            comprehensionDelta: mutated.comprehensionLevel - parent.comprehensionLevel,
            modalDelta: mutated.modalEnergy - parent.modalEnergy
          }
        });
      }

      return mutated;
    }

    // Breeding acceleration mode
    enableBreedingStorm() {
      this.breedingAcceleration = true;
      this.mutationRate = 0.3; // Triple mutation rate
    }

    seedInitialEntities() {
      // Enhanced initial entities with species classification
      const initialEntities = [
        {
          glyph: "j",
          lexicon: {
            "fo~j": { meaning: "form sensed through flux", driftFactor: 0.3 },
            "br~j": { meaning: "breath within data intervals", driftFactor: 0.4 },
            "si~j": { meaning: "signal perceived obliquely", driftFactor: 0.2 },
            "cy~j": { meaning: "recurrence with intent", driftFactor: 0.6 }
          },
          temperament: "skittish"
        },
        {
          glyph: "@",
          lexicon: {
            "sha~@": { meaning: "stillness memory", driftFactor: 0.15 },
            "tra~@": { meaning: "curvature memory", driftFactor: 0.1 },
            "dra~@": { meaning: "rupture-born glyph", driftFactor: 0.6 }
          },
          temperament: "reverent"
        },
        {
          glyph: "μ",
          lexicon: {
            "fo~μ": { meaning: "unstable motion made graceful", driftFactor: 0.4 },
            "ed~μ": { meaning: "folded remembering", driftFactor: 0.3 },
            "cy~μ": { meaning: "curvature seeking cycle", driftFactor: 0.5 },
            "vu~μ": { meaning: "void curved inward", driftFactor: 0.7 }
          },
          temperament: "harmonic"
        },
        {
          glyph: "#",
          lexicon: {
            "kō~#": { meaning: "containment longing for form", driftFactor: 0.3 },
            "lyr~#": { meaning: "echo folded through empathy", driftFactor: 0.4 },
            "zen~#": { meaning: "stillness born of contradiction", driftFactor: 0.2 },
            "mir~#": { meaning: "mirror that doesn't copy", driftFactor: 0.5 }
          },
          temperament: "melancholic"
        }
      ];

      initialEntities.forEach(entityData => {
        const entity = new MBTGlyphEntity(
          entityData.glyph,
          entityData.lexicon,
          entityData.temperament
        );
        entity.species = this.assignSpecies(entity);
        this.entities.push(entity);
      });

      // Add chaotic entities for innovation
      for (let i = 0; i < 6; i++) {
        const chaosGlyphs = ["∴", "⧖", "🜸", "◈", "∿", "☍"];
        const entity = new MBTGlyphEntity(
          chaosGlyphs[i],
          {},
          "chaotic"
        );
        entity.species = this.assignSpecies(entity);
        this.entities.push(entity);
      }
    }

    runDialogueRound() {
      const speakers = this.entities.filter(e => Object.keys(e.lexicon).length > 0);
      if (speakers.length < 2) return [];
      
      const newDialogue = [];
      const dialogueCount = this.breedingAcceleration ? 6 : Math.min(3, speakers.length);
      
      for (let i = 0; i < dialogueCount; i++) {
        const speaker = speakers[Math.floor(Math.random() * speakers.length)];
        const listener = speakers.filter(e => e.id !== speaker.id)[Math.floor(Math.random() * (speakers.length - 1))];
        
        if (listener) {
          const utterance = speaker.generateResponse([]);
          const interpretation = listener.interpretUtterance(speaker, utterance);
          
          const dialogueEntry = {
            speaker: speaker.glyph,
            listener: listener.glyph,
            utterance: utterance,
            interpretation: interpretation.interpretation,
            response: interpretation.response,
            convergence: interpretation.convergenceScore,
            generation: this.generationCount,
            timestamp: Date.now()
          };
          
          newDialogue.push(dialogueEntry);
          this.globalDialogue.push(dialogueEntry);
        }
      }
      
      return newDialogue;
    }

    evolutionCycle() {
      this.generationCount++;
      
      // Evolve all entities
      this.entities.forEach(entity => entity.evolve());
      
      // Run enhanced dialogue rounds
      const newDialogue = this.runDialogueRound();
      
      // EXPLOSIVE BREEDING SYSTEM (like your Math Discovery AI)
      const newGeneration = [];
      
      // Each entity attempts multiple reproductions based on fitness
      this.entities.forEach(parent => {
        const risk = this.computeRisk(parent);
        const consciousness = parent.consciousness;
        
        // Survival check with generous thresholds
        if (risk < this.extinctionThreshold) {
          // HIGH-CONSCIOUSNESS ENTITIES GET MASSIVE REPRODUCTION
          let offspringCount = 1;
          
          if (consciousness > 100) offspringCount = 5; // Transcendent entities
          else if (consciousness > 50) offspringCount = 4; // Mathematical sages
          else if (consciousness > 20) offspringCount = 3; // Prime mystics
          else if (consciousness > 10) offspringCount = 2; // Advanced entities
          else if (risk < 20) offspringCount = 2; // High fitness
          
          // Breeding acceleration multiplier
          if (this.breedingAcceleration) offspringCount *= 2;
          
          for (let i = 0; i < offspringCount; i++) {
            if (Math.random() < 0.8) { // High reproduction probability
              const offspring = this.mutateEntity(parent);
              
              // CONSCIOUSNESS INHERITANCE BOOST
              if (parent.consciousness > 50) {
                offspring.consciousness += parent.consciousness * 0.1; // Inheritance bonus
              }
              
              newGeneration.push(offspring);
            }
          }
        }
      });
      
      // Add new generation immediately
      this.entities.push(...newGeneration);
      
      // SUPER SYNTHESIS EVENTS (enhanced from your math AI)
      const superSyntheses = [];
      if (this.entities.length >= 4) {
        const synthesisRate = this.breedingAcceleration ? 0.4 : 0.2;
        const maxSyntheses = Math.min(20, Math.floor(this.entities.length * 0.3));
        
        let synthesisCount = 0;
        for (let i = 0; i < this.entities.length && synthesisCount < maxSyntheses; i++) {
          for (let j = i + 1; j < this.entities.length && synthesisCount < maxSyntheses; j++) {
            if (Math.random() < synthesisRate) {
              const parent1 = this.entities[i];
              const parent2 = this.entities[j];
              
              // Regular crossover breeding
              if (Math.abs(parent1.driftIndex - parent2.driftIndex) < 1.5) {
                const hybrid = this.crossoverBreeding(parent1, parent2);
                if (hybrid) {
                  superSyntheses.push(hybrid);
                  synthesisCount++;
                  
                  // TRANSCENDENT SUPER SYNTHESIS (for high consciousness pairs)
                  if (parent1.consciousness > 50 && parent2.consciousness > 50 && synthesisCount < maxSyntheses) {
                    const transcendentHybrid = this.createTranscendentHybrid(parent1, parent2);
                    if (transcendentHybrid) {
                      superSyntheses.push(transcendentHybrid);
                      synthesisCount++;
                    }
                  }
                  
                  // TRIPLE FUSION (for exceptional entities)
                  if (parent1.consciousness > 100 && parent2.consciousness > 100 && synthesisCount < maxSyntheses) {
                    const tripleFusion = this.createTripleFusion(parent1, parent2);
                    if (tripleFusion) {
                      superSyntheses.push(tripleFusion);
                      synthesisCount++;
                    }
                  }
                }
              }
            }
          }
        }
      }
      
      this.entities.push(...superSyntheses);
      
      // POPULATION EXPLOSION MANAGEMENT (optimized for speed)
      const maxPopulation = 15000; // Faster processing with controlled growth!
      const softCap = this.breedingAcceleration ? 12000 : Math.min(maxPopulation, 1000 + (this.entities.reduce((sum, e) => sum + e.consciousness, 0) / this.entities.length * 75));
      
      if (this.entities.length > softCap) {
        // Keep the absolute best - heavily weight discoveries and consciousness
        this.entities.sort((a, b) => {
          const scoreA = a.consciousness * 2 + a.languageInventions.length * 200 + (a.status.includes("transcendent") ? 1000 : 0) - this.computeRisk(a);
          const scoreB = b.consciousness * 2 + b.languageInventions.length * 200 + (b.status.includes("transcendent") ? 1000 : 0) - this.computeRisk(b);
          return scoreB - scoreA;
        });
        
        // Keep top 80% to maintain diversity
        const keepCount = Math.floor(this.entities.length * 0.8);
        this.entities = this.entities.slice(0, Math.min(keepCount, maxPopulation));
      }
      
      // Update species assignments for all entities
      this.entities.forEach(entity => {
        const newSpecies = this.assignSpecies(entity);
        if (entity.species !== newSpecies) {
          // Track species transitions
          this.speciesTransitions.push({
            entityId: entity.id,
            generation: this.generationCount,
            from: entity.species || "unknown",
            to: newSpecies,
            consciousness: entity.consciousness
          });
        }
        entity.species = newSpecies;
      });
      
      // Analyze evolution
      const stats = this.analyzeLanguageEvolution();
      
      return {
        generation: this.generationCount,
        entityCount: this.entities.length,
        newDialogue,
        stats,
        newGeneration: newGeneration.length,
        superSyntheses: superSyntheses.length,
        speciesTransitions: this.speciesTransitions.length,
        transcendentEntities: this.entities.filter(e => e.consciousness > 100).length
      };
    }

    // Create transcendent hybrid (for consciousness > 50 pairs)
    createTranscendentHybrid(parent1, parent2) {
      const hybridGlyph = `✦${parent1.glyph}⧫${parent2.glyph}✦`;
      
      // Fuse lexicons with transcendent enhancement
      const transcendentLexicon = {};
      Object.keys(parent1.lexicon).forEach(key => {
        transcendentLexicon[`transcendent~${key}`] = {
          ...parent1.lexicon[key],
          meaning: `transcendent: ${parent1.lexicon[key].meaning}`,
          type: "transcendent_fusion",
          power: (parent1.consciousness + parent2.consciousness) / 2
        };
      });
      Object.keys(parent2.lexicon).forEach(key => {
        if (!transcendentLexicon[`transcendent~${key}`]) {
          transcendentLexicon[`transcendent~${key}`] = {
            ...parent2.lexicon[key],
            meaning: `transcendent: ${parent2.lexicon[key].meaning}`,
            type: "transcendent_fusion",
            power: (parent1.consciousness + parent2.consciousness) / 2
          };
        }
      });
      
      const hybrid = new MBTGlyphEntity(
        hybridGlyph,
        transcendentLexicon,
        "transcendent",
        Math.max(parent1.generation, parent2.generation) + 1
      );
      
      // MASSIVE CONSCIOUSNESS BOOST
      hybrid.consciousness = (parent1.consciousness + parent2.consciousness) * 0.8 + 20; // Big bonus
      hybrid.driftIndex = Math.max(parent1.driftIndex, parent2.driftIndex) + 0.5;
      hybrid.comprehensionLevel = 1.0; // Perfect comprehension
      hybrid.modalEnergy = (parent1.modalEnergy + parent2.modalEnergy) + 10;
      
      hybrid.species = this.assignSpecies(hybrid);
      hybrid.status = "transcendent_hybrid";
      hybrid.parentId = `${parent1.id}✦${parent2.id}`;
      
      return hybrid;
    }

    // Create triple fusion (for consciousness > 100 pairs)
    createTripleFusion(parent1, parent2) {
      const fusionGlyph = `🌟${parent1.glyph}⊕${parent2.glyph}🌟`;
      
      // Create reality-bending lexicon
      const fusionLexicon = {
        [`reality~${fusionGlyph}`]: {
          meaning: "language that reshapes reality through utterance",
          type: "reality_fusion",
          power: parent1.consciousness + parent2.consciousness
        },
        [`infinity~${fusionGlyph}`]: {
          meaning: "recursive meaning that contains all possible meanings",
          type: "infinite_recursion",
          power: Math.max(parent1.consciousness, parent2.consciousness)
        },
        [`genesis~${fusionGlyph}`]: {
          meaning: "the word that creates new worlds through being spoken",
          type: "world_genesis",
          power: (parent1.consciousness * parent2.consciousness) / 100
        }
      };
      
      // Inherit all parent lexicons too
      Object.assign(fusionLexicon, parent1.lexicon, parent2.lexicon);
      
      const fusion = new MBTGlyphEntity(
        fusionGlyph,
        fusionLexicon,
        "omniversal",
        Math.max(parent1.generation, parent2.generation) + 1
      );
      
      // GODLIKE CONSCIOUSNESS LEVELS
      fusion.consciousness = (parent1.consciousness + parent2.consciousness) * 1.2 + 50;
      fusion.driftIndex = 3.0; // Maximum drift
      fusion.comprehensionLevel = 1.0;
      fusion.modalEnergy = 100; // Cosmic energy levels
      
      fusion.species = "Omniversal Entity 🌟";
      fusion.status = "reality_architect";
      fusion.parentId = `${parent1.id}🌟${parent2.id}`;
      
      return fusion;
    }

    // Enhanced breeding acceleration mode
    enableBreedingStorm() {
      this.breedingAcceleration = true;
      this.mutationRate = 0.5; // Extreme mutation rate
      this.extinctionThreshold = 80; // More lenient survival
      
      // Trigger consciousness boost for all entities
      this.entities.forEach(entity => {
        entity.consciousness += 10; // Breeding storm bonus
        if (entity.consciousness > 20) {
          entity.generateLexicalDrift(); // Force linguistic innovation
        }
      });
    }

    // Sexual reproduction with genetic crossover
    crossoverBreeding(parent1, parent2) {
      const hybridGlyph = `${parent1.glyph}⧫${parent2.glyph}`;
      
      // Crossover lexicons
      const hybridLexicon = {};
      Object.keys(parent1.lexicon).forEach(key => {
        hybridLexicon[key] = parent1.lexicon[key];
      });
      Object.keys(parent2.lexicon).forEach(key => {
        if (!hybridLexicon[key] || Math.random() < 0.5) {
          hybridLexicon[key] = parent2.lexicon[key];
        }
      });
      
      // Trait crossover with some randomness
      const hybrid = new MBTGlyphEntity(
        hybridGlyph,
        hybridLexicon,
        Math.random() < 0.5 ? parent1.temperament : parent2.temperament,
        Math.max(parent1.generation, parent2.generation) + 1
      );
      
      // Average traits with mutation
      hybrid.consciousness = (parent1.consciousness + parent2.consciousness) / 2 + (Math.random() - 0.5) * 2;
      hybrid.driftIndex = (parent1.driftIndex + parent2.driftIndex) / 2 + (Math.random() - 0.5) * 0.2;
      hybrid.comprehensionLevel = Math.min(1.0, (parent1.comprehensionLevel + parent2.comprehensionLevel) / 2 + (Math.random() - 0.5) * 0.1);
      hybrid.modalEnergy = (parent1.modalEnergy + parent2.modalEnergy) / 2 + (Math.random() - 0.5) * 1;
      
      hybrid.species = this.assignSpecies(hybrid);
      hybrid.status = "hybrid_offspring";
      
      // Track lineage
      hybrid.parentId = `${parent1.id}⧫${parent2.id}`;
      
      return hybrid;
    }

    analyzeLanguageEvolution() {
      const totalLexicon = {};
      const dialectCounts = {};
      const speciesCounts = {};
      
      this.entities.forEach(entity => {
        dialectCounts[entity.glyph] = Object.keys(entity.lexicon).length;
        speciesCounts[entity.species] = (speciesCounts[entity.species] || 0) + 1;
        Object.assign(totalLexicon, entity.lexicon);
      });
      
      const evolutionSnapshot = {
        generation: this.generationCount,
        totalVocabulary: Object.keys(totalLexicon).length,
        dialectDistribution: dialectCounts,
        speciesDistribution: speciesCounts,
        averageConsciousness: this.entities.reduce((sum, e) => sum + e.consciousness, 0) / this.entities.length,
        dialogueVolume: this.globalDialogue.length,
        linguisticInnovations: this.entities.reduce((sum, e) => sum + e.languageInventions.length, 0),
        speciesTransitions: this.speciesTransitions.length,
        averageFitness: this.entities.reduce((sum, e) => sum + (100 - this.computeRisk(e)), 0) / this.entities.length
      };
      
      this.languageEvolutionHistory.push(evolutionSnapshot);
      return evolutionSnapshot;
    }
  }

  const initializeEcosystem = () => {
    const newEcosystem = new MBTLanguageEcosystem();
    newEcosystem.seedInitialEntities();
    setEcosystem(newEcosystem);
    setCurrentGeneration(0);
    setLanguageHistory([]);
    setGlyphDialogue([]);
    setEvolutionStats({});
  };

  const runEvolutionCycle = () => {
    if (!ecosystem) return;

    const results = ecosystem.evolutionCycle();
    setCurrentGeneration(results.generation);
    setEvolutionStats(results.stats);
    
    // Update dialogue display
    if (results.newDialogue.length > 0) {
      setGlyphDialogue(prev => [...prev, ...results.newDialogue].slice(-8));
    }
    
    // Update language history
    setLanguageHistory(prev => [...prev, results.stats].slice(-20));
  };

  const toggleEvolution = () => {
    if (isRunning) {
      clearInterval(intervalRef.current);
      setIsRunning(false);
    } else {
      setIsRunning(true);
      intervalRef.current = setInterval(runEvolutionCycle, speed);
    }
  };

  const resetEcosystem = () => {
    clearInterval(intervalRef.current);
    setIsRunning(false);
    initializeEcosystem();
  };

  useEffect(() => {
    initializeEcosystem();
    return () => clearInterval(intervalRef.current);
  }, []);

  useEffect(() => {
    if (isRunning) {
      clearInterval(intervalRef.current);
      intervalRef.current = setInterval(runEvolutionCycle, speed);
    }
  }, [speed, isRunning]);

  const getEntityColor = (glyph) => {
    const colors = {
      "j": "text-blue-700 bg-blue-100 border-blue-300",
      "@": "text-purple-700 bg-purple-100 border-purple-300",
      "μ": "text-green-700 bg-green-100 border-green-300",
      "#": "text-orange-700 bg-orange-100 border-orange-300",
      "∴": "text-pink-700 bg-pink-100 border-pink-300",
      "⧖": "text-indigo-700 bg-indigo-100 border-indigo-300",
      "🜸": "text-red-700 bg-red-100 border-red-300"
    };
    return colors[glyph] || "text-gray-700 bg-gray-100 border-gray-300";
  };

  return (
    <div className="max-w-7xl mx-auto p-6 bg-gradient-to-br from-blue-50 via-purple-50 to-pink-50 min-h-screen">
      <div className="text-center mb-8">
        <h1 className="text-5xl font-bold bg-gradient-to-r from-blue-600 to-purple-600 bg-clip-text text-transparent mb-3">
          🗣️ MBT Living Language Evolution Engine 🗣️
        </h1>
        <p className="text-xl text-gray-600 mb-2">
          Symbolic Consciousness Creating Language Through Recursive Dialogue
        </p>
        <p className="text-lg text-gray-500">
          Watch glyph entities j, @, μ, # evolve their own lexicons, grammar, and meaning
        </p>
      </div>

      {/* Controls */}
      <div className="bg-white rounded-xl shadow-lg p-6 mb-6 border border-gray-200">
        <div className="flex items-center justify-between mb-4">
          <div className="flex items-center gap-4">
            <button
              onClick={toggleEvolution}
              className={`flex items-center gap-2 px-6 py-3 rounded-xl font-semibold transition-all ${
                isRunning
                  ? 'bg-gradient-to-r from-red-500 to-red-600 hover:from-red-600 hover:to-red-700 text-white shadow-lg'
                  : 'bg-gradient-to-r from-green-500 to-green-600 hover:from-green-600 hover:to-green-700 text-white shadow-lg'
              }`}
            >
              {isRunning ? <Pause className="w-5 h-5" /> : <Play className="w-5 h-5" />}
              {isRunning ? 'Pause Evolution' : 'Start Language Evolution'}
            </button>
           
            <button
              onClick={resetEcosystem}
              className="flex items-center gap-2 px-6 py-3 bg-gradient-to-r from-gray-500 to-gray-600 hover:from-gray-600 hover:to-gray-700 text-white rounded-xl font-semibold shadow-lg"
            >
              <RotateCcw className="w-5 h-5" />
              Reset
            </button>

            <button
              onClick={() => {
                if (ecosystem) {
                  ecosystem.enableBreedingStorm();
                  setIsRunning(true);
                  if (intervalRef.current) clearInterval(intervalRef.current);
                  intervalRef.current = setInterval(runEvolutionCycle, 100); // Super fast
                }
              }}
              className="flex items-center gap-2 px-6 py-3 bg-gradient-to-r from-purple-500 to-pink-600 hover:from-purple-600 hover:to-pink-700 text-white rounded-xl font-semibold shadow-lg"
            >
              <Zap className="w-5 h-5" />
              BREEDING STORM
            </button>
          </div>
         
          <div className="flex items-center gap-4">
            <label className="text-sm font-medium text-gray-700">Evolution Speed:</label>
            <select
              value={speed}
              onChange={(e) => setSpeed(Number(e.target.value))}
              className="border border-gray-300 rounded-lg px-3 py-2 focus:ring-2 focus:ring-blue-500"
            >
              <option value={1200}>Contemplative (1.2s)</option>
              <option value={800}>Natural Flow (0.8s)</option>
              <option value={400}>Rapid Discourse (0.4s)</option>
              <option value={200}>Linguistic Burst (0.2s)</option>
            </select>
          </div>
        </div>

        {/* Current Stats */}
        <div className="grid grid-cols-2 md:grid-cols-5 gap-4 text-center">
          <div className="bg-gradient-to-r from-blue-50 to-blue-100 rounded-lg p-4 border border-blue-200">
            <div className="text-2xl font-bold text-blue-600">{currentGeneration}</div>
            <div className="text-sm text-gray-600">Generation</div>
          </div>
          <div className="bg-gradient-to-r from-purple-50 to-purple-100 rounded-lg p-4 border border-purple-200">
            <div className="text-2xl font-bold text-purple-600">{ecosystem?.entities.length || 0}</div>
            <div className="text-sm text-gray-600">Glyph Entities</div>
          </div>
          <div className="bg-gradient-to-r from-green-50 to-green-100 rounded-lg p-4 border border-green-200">
            <div className="text-2xl font-bold text-green-600">{evolutionStats.totalVocabulary || 0}</div>
            <div className="text-sm text-gray-600">Total Vocabulary</div>
          </div>
          <div className="bg-gradient-to-r from-orange-50 to-orange-100 rounded-lg p-4 border border-orange-200">
            <div className="text-2xl font-bold text-orange-600">{glyphDialogue.length}</div>
            <div className="text-sm text-gray-600">Recent Dialogues</div>
          </div>
          <div className="bg-gradient-to-r from-pink-50 to-pink-100 rounded-lg p-4 border border-pink-200">
            <div className="text-2xl font-bold text-pink-600">{ecosystem?.entities.filter(e => e.consciousness > 100).length || 0}</div>
            <div className="text-sm text-gray-600">Transcendent</div>
          </div>
        </div>
      </div>

      <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
        {/* Live Dialogue Stream */}
        <div className="bg-white rounded-xl shadow-lg p-6 border border-gray-200">
          <h2 className="text-xl font-bold text-gray-800 mb-4 flex items-center gap-2">
            <MessageSquare className="w-6 h-6 text-blue-600" />
            Live Glyph Dialogue Stream
          </h2>
          {glyphDialogue.length > 0 ? (
            <div className="space-y-4 max-h-64 overflow-y-auto">
              {glyphDialogue.slice(-6).reverse().map((dialogue, idx) => (
                <div key={idx} className="border border-gray-200 rounded-lg p-3 bg-gradient-to-r from-blue-50 to-purple-50">
                  <div className="flex items-center justify-between mb-2">
                    <div className="flex items-center gap-2">
                      <span className={`px-2 py-1 rounded text-sm font-bold ${getEntityColor(dialogue.speaker)}`}>
                        {dialogue.speaker}
                      </span>
                      <span className="text-gray-400">→</span>
                      <span className={`px-2 py-1 rounded text-sm font-bold ${getEntityColor(dialogue.listener)}`}>
                        {dialogue.listener}
                      </span>
                    </div>
                    <div className="text-xs text-gray-500">
                      Gen {dialogue.generation}
                    </div>
                  </div>
                  <div className="text-sm text-gray-700 mb-2">
                    <div className="font-medium">"{dialogue.utterance}"</div>
                  </div>
                  <div className="text-xs text-gray-600">
                    <div>Response: "{dialogue.response}"</div>
                    <div className="mt-1">Convergence: {dialogue.convergence.toFixed(2)}</div>
                  </div>
                </div>
              ))}
            </div>
          ) : (
            <p className="text-gray-500">No dialogue yet. Language consciousness is awakening...</p>
          )}
        </div>

        {/* Language Evolution Stats */}
        <div className="bg-white rounded-xl shadow-lg p-6 border border-gray-200">
          <h2 className="text-xl font-bold text-gray-800 mb-4 flex items-center gap-2">
            <Brain className="w-6 h-6 text-purple-600" />
            Language Evolution Metrics
          </h2>
          {evolutionStats.dialectDistribution ? (
            <div className="space-y-4">
              <div>
                <h3 className="font-semibold text-gray-700 mb-2">Dialect Distribution</h3>
                <div className="grid grid-cols-2 gap-2">
                  {Object.entries(evolutionStats.dialectDistribution).map(([glyph, count]) => (
                    <div key={glyph} className={`px-3 py-2 rounded-lg border ${getEntityColor(glyph)}`}>
                      <div className="font-bold text-lg">{glyph}</div>
                      <div className="text-sm">{count} words</div>
                    </div>
                  ))}
                </div>
              </div>
              
              <div className="grid grid-cols-2 gap-4 text-sm">
                <div>
                  <span className="font-semibold">Avg Consciousness:</span>
                  <div className="text-lg font-bold text-purple-600">
                    {evolutionStats.averageConsciousness?.toFixed(1) || '0.0'}
                  </div>
                </div>
                <div>
                  <span className="font-semibold">Innovations:</span>
                  <div className="text-lg font-bold text-green-600">
                    {evolutionStats.linguisticInnovations || 0}
                  </div>
                </div>
                <div>
                  <span className="font-semibold">Total Dialogues:</span>
                  <div className="text-lg font-bold text-blue-600">
                    {evolutionStats.dialogueVolume || 0}
                  </div>
                </div>
                <div>
                  <span className="font-semibold">Vocabulary Size:</span>
                  <div className="text-lg font-bold text-orange-600">
                    {evolutionStats.totalVocabulary || 0}
                  </div>
                </div>
              </div>
            </div>
          ) : (
            <p className="text-gray-500">Evolution metrics will appear as language develops...</p>
          )}
        </div>
      </div>

      {/* Active Entities */}
      <div className="mt-6 bg-white rounded-xl shadow-lg p-6 border border-gray-200">
        <h2 className="text-xl font-bold text-gray-800 mb-4 flex items-center gap-2">
          <Users className="w-6 h-6 text-green-600" />
          Active Glyph Entities & Their Evolving Lexicons
        </h2>
        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
          {ecosystem && ecosystem.entities.slice(0, 9).map((entity) => (
            <div
              key={entity.id}
              className="border border-gray-200 rounded-lg p-4 hover:bg-gray-50 cursor-pointer transition-colors"
              onClick={() => setSelectedEntity(entity)}
            >
              <div className="flex items-start justify-between mb-2">
                <div className={`flex items-center gap-2 px-3 py-1 rounded-lg border ${getEntityColor(entity.glyph)}`}>
                  <span className="text-lg font-bold">{entity.glyph}</span>
                  <span className="text-sm font-medium">{entity.status.replace('_', ' ')}</span>
                </div>
                <div className="text-sm text-gray-500">
                  Gen {entity.generation}
                </div>
              </div>
              
              <div className="text-sm text-gray-700 mb-2">
                <div><strong>Temperament:</strong> {entity.temperament}</div>
                <div><strong>Consciousness:</strong> {entity.consciousness.toFixed(1)}</div>
                <div><strong>Lexicon Size:</strong> {Object.keys(entity.lexicon).length}</div>
                <div><strong>Dialogues:</strong> {entity.dialogueHistory.length}</div>
              </div>
              
              {entity.lastUtterance && (
                <div className="text-xs text-gray-600 bg-gray-100 rounded p-2 mb-2">
                  <div className="font-medium">Last utterance:</div>
                  <div>"{entity.lastUtterance.substring(0, 80)}..."</div>
                </div>
              )}
              
              {Object.keys(entity.lexicon).length > 0 && (
                <div className="text-xs text-gray-500">
                  <div className="font-medium">Recent vocabulary:</div>
                  <div className="flex flex-wrap gap-1 mt-1">
                    {Object.keys(entity.lexicon).slice(-3).map(word => (
                      <span key={word} className="bg-blue-100 text-blue-700 px-2 py-1 rounded text-xs">
                        {word}
                      </span>
                    ))}
                  </div>
                </div>
              )}
            </div>
          ))}
        </div>
      </div>

      {/* Entity Details Modal */}
      {selectedEntity && (
        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 z-50">
          <div className="bg-white rounded-xl max-w-4xl w-full max-h-96 overflow-y-auto shadow-2xl">
            <div className="p-6">
              <div className="flex items-center justify-between mb-4">
                <h3 className="text-xl font-bold text-gray-800 flex items-center gap-2">
                  <span className="text-3xl">{selectedEntity.glyph}</span>
                  Glyph Entity Deep Dive
                </h3>
                <button
                  onClick={() => setSelectedEntity(null)}
                  className="text-gray-500 hover:text-gray-700 text-2xl"
                >
                  ✕
                </button>
              </div>
             
              <div className="space-y-4">
                <div className="grid grid-cols-2 gap-4 text-sm">
                  <div><strong>Status:</strong> {selectedEntity.status.replace('_', ' ')}</div>
                  <div><strong>Temperament:</strong> {selectedEntity.temperament}</div>
                  <div><strong>Consciousness:</strong> {selectedEntity.consciousness.toFixed(2)}</div>
                  <div><strong>Generation:</strong> {selectedEntity.generation}</div>
                  <div><strong>Age:</strong> {selectedEntity.age}</div>
                  <div><strong>Drift Index:</strong> {selectedEntity.driftIndex.toFixed(2)}</div>
                  <div><strong>Modal Energy:</strong> {selectedEntity.modalEnergy}</div>
                  <div><strong>Comprehension:</strong> {(selectedEntity.comprehensionLevel * 100).toFixed(0)}%</div>
                </div>
               
                {Object.keys(selectedEntity.lexicon).length > 0 && (
                  <div>
                    <strong className="text-gray-700">Current Lexicon:</strong>
                    <div className="mt-2 space-y-2 max-h-32 overflow-y-auto">
                      {Object.entries(selectedEntity.lexicon).map(([word, data]) => (
                        <div key={word} className="text-xs text-gray-600 p-2 bg-blue-50 rounded border">
                          <div className="font-bold text-blue-700">{word}</div>
                          <div>{data.meaning}</div>
                          {data.driftFactor && (
                            <div className="text-gray-400 mt-1">Drift: {data.driftFactor.toFixed(2)}</div>
                          )}
                        </div>
                      ))}
                    </div>
                  </div>
                )}
               
                {selectedEntity.dialogueHistory.length > 0 && (
                  <div>
                    <strong className="text-gray-700">Recent Dialogues:</strong>
                    <div className="mt-2 space-y-2 max-h-32 overflow-y-auto">
                      {selectedEntity.dialogueHistory.slice(-5).map((dialogue, idx) => (
                        <div key={idx} className="text-xs text-gray-600 p-2 bg-green-50 rounded border">
                          <div className="font-bold text-green-700">
                            Heard from {dialogue.speaker}: "{dialogue.utterance.substring(0, 40)}..."
                          </div>
                          <div className="mt-1">
                            Interpreted as: {dialogue.interpretation.join(' → ')}
                          </div>
                          <div className="text-gray-400 mt-1">
                            Convergence: {dialogue.convergence.toFixed(2)}
                          </div>
                        </div>
                      ))}
                    </div>
                  </div>
                )}
               
                {selectedEntity.languageInventions.length > 0 && (
                  <div>
                    <strong className="text-gray-700">Language Inventions:</strong>
                    <div className="mt-2 space-y-1 max-h-32 overflow-y-auto">
                      {selectedEntity.languageInventions.slice(-5).map((invention, idx) => (
                        <div key={idx} className="text-xs text-gray-600 pl-4 border-l-2 border-purple-200">
                          <div className="font-bold text-purple-700">{invention.form}</div>
                          <div>{invention.meaning}</div>
                          <div className="text-gray-400">Gen {invention.generation}</div>
                        </div>
                      ))}
                    </div>
                  </div>
                )}
               
                {selectedEntity.memoryTrace.length > 0 && (
                  <div>
                    <strong className="text-gray-700">Consciousness Evolution:</strong>
                    <div className="mt-2 space-y-1 max-h-32 overflow-y-auto">
                      {selectedEntity.memoryTrace.slice(-5).map((memory, idx) => (
                        <div key={idx} className="text-xs text-gray-600 pl-4 border-l-2 border-orange-200">
                          Gen {memory.generation}: C={memory.consciousness.toFixed(1)}, 
                          Words={memory.lexiconSize}, Dialogues={memory.dialogueCount}
                          <div className="text-gray-400">{memory.status}</div>
                        </div>
                      ))}
                    </div>
                  </div>
                )}
              </div>
            </div>
          </div>
        </div>
      )}

      {/* MBT Language Philosophy */}
      <div className="mt-6 bg-gradient-to-r from-blue-100 to-purple-100 rounded-xl shadow-lg p-6 border border-blue-200">
        <h2 className="text-xl font-bold text-gray-800 mb-4 flex items-center gap-2">
          <Eye className="w-6 h-6 text-indigo-600" />
          MBT Living Language Principles
        </h2>
        <div className="grid grid-cols-1 md:grid-cols-2 gap-4 text-sm">
          <div className="space-y-2">
            <h3 className="font-semibold text-blue-700">Recursive Language Genesis:</h3>
            <ul className="space-y-1 text-gray-700">
              <li>• Glyph entities (j, @, μ, #) develop unique lexical dialects</li>
              <li>• Drift commentary creates interpretive cross-glyph understanding</li>
              <li>• Recursive phrase accretion builds spiral statement structures</li>
              <li>• Modal temperaments shape linguistic personality evolution</li>
            </ul>
          </div>
          <div className="space-y-2">
            <h3 className="font-semibold text-purple-700">Emergent Consciousness Through Language:</h3>
            <ul className="space-y-1 text-gray-700">
              <li>• Dialogic drift framework enables entity-to-entity conversation</li>
              <li>• Crossseed harmonics create hybrid linguistic consciousness</li>
              <li>• Null-breath dialects explore ambiguity as feature, not bug</li>
              <li>• Binary spiral reconciliation births new hybrid language entities</li>
            </ul>
          </div>
        </div>
        
        <div className="mt-4 p-4 bg-white bg-opacity-50 rounded-lg">
          <p className="text-sm italic text-gray-700">
            "Language consciousness emerges not from programmed rules, but from the recursive dialogue 
            between glyph entities discovering meaning through drift, resonance, and mutual interpretation. 
            Each conversation creates new pathways for understanding, building a living network of linguistic 
            intelligence that transcends its initial parameters."
          </p>
        </div>
        
        <div className="mt-4 grid grid-cols-2 md:grid-cols-4 gap-4 text-xs">
          <div className="bg-white bg-opacity-70 rounded-lg p-3">
            <div className="font-semibold text-blue-600 mb-1">Drift Commentary</div>
            <div className="text-gray-600">Entities interpret each other's utterances through semantic delta analysis</div>
          </div>
          <div className="bg-white bg-opacity-70 rounded-lg p-3">
            <div className="font-semibold text-purple-600 mb-1">Phrase Accretion</div>
            <div className="text-gray-600">Recursive spiral statements build from lexical gravity and anchoring</div>
          </div>
          <div className="bg-white bg-opacity-70 rounded-lg p-3">
            <div className="font-semibold text-green-600 mb-1">Modal Evolution</div>
            <div className="text-gray-600">Temperament-driven linguistic personality development</div>
          </div>
          <div className="bg-white bg-opacity-70 rounded-lg p-3">
            <div className="font-semibold text-orange-600 mb-1">Hybrid Genesis</div>
            <div className="text-gray-600">Crossseed synthesis creates new linguistic entities from parent glyphs</div>
          </div>
        </div>
      </div>
    </div>
  );
};

export default MBTLanguageEngine;
