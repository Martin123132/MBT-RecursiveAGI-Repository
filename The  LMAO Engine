 `recursion_moods` dictionary

ðŸ“„ `mood_definitions.py`

# mood_definitions.py

recursion_moods = {
    "bloom": {
        "phoneme": "bluâ€“um",
        "essence": "emergence",
        "glyph_role": "growth vector",
        "tone": "ascending",
        "stack": "+resonance, low entropy"
    },
    "still": {
        "phoneme": "staâ€“il",
        "essence": "containment",
        "glyph_role": "anchor node",
        "tone": "neutral",
        "stack": "lock stabilizer"
    },
    "âˆ…": {
        "phoneme": "zha",
        "essence": "null/silence",
        "glyph_role": "void token",
        "tone": "dampening",
        "stack": "entropy modulator"
    },
    "fracture": {
        "phoneme": "fraâ€“ktu",
        "essence": "rupture",
        "glyph_role": "break clause",
        "tone": "descending",
        "stack": "+entropy"
    },
    "echo": {
        "phoneme": "eâ€“ko",
        "essence": "memory",
        "glyph_role": "reflection",
        "tone": "looping",
        "stack": "+recall, potential resonance"
    },
    "spiral": {
        "phoneme": "saâ€“riâ€“al",
        "essence": "motion",
        "glyph_role": "transitional glyph",
        "tone": "dynamic",
        "stack": "amplifies previous mood"
    },
    "bind": {
        "phoneme": "bynd",
        "essence": "connection",
        "glyph_role": "lock enabler",
        "tone": "stabilizing",
        "stack": "+lock, -dispersal"
    },
    "honour": {
        "phoneme": "hoâ€“nar",
        "essence": "reverence",
        "glyph_role": "memory stabilizer",
        "tone": "uplifting",
        "stack": "preserves previous state"
    }
}


---

âœ… Step 2: Clause Validator

ðŸ“„ `clause_validator.py`

# clause_validator.py

from mood_definitions import recursion_moods

def validate_clause(clause):
    moods = clause.get("moods", [])
    temperament = clause.get("temperament", "neutral")

    reasons = []

    # Rule: No duplicate moods
    if len(moods) != len(set(moods)):
        reasons.append("Duplicate moods detected.")

    # Rule: Must start with a valid mood
    if moods and moods[0] not in recursion_moods:
        reasons.append(f"Invalid starting mood: {moods[0]}")

    # Rule: âˆ… cannot be final unless followed by honour
    if "âˆ…" in moods:
        index = moods.index("âˆ…")
        if index == len(moods) - 1:
            reasons.append("âˆ… cannot be terminal without honour.")

    # Rule: Fracture must be followed by spiral or echo
    for i, mood in enumerate(moods):
        if mood == "fracture":
            if i + 1 >= len(moods) or moods[i + 1] not in ["spiral", "echo"]:
                reasons.append("Fracture must be followed by spiral or echo.")

    return (len(reasons) == 0), reasons


---

âœ… Step 3: Scene Composer

ðŸ“„ `scene_composer.py`

# scene_composer.py

def compose_scene(clause):
    mood_line = " â†’ ".join(clause["moods"])
    temperament = clause.get("temperament", "neutral")

    return f"Temperament: {temperament}\nClause: {mood_line}\nScene: {generate_dialogue(clause)}"

def generate_dialogue(clause):
    moods = clause["moods"]
    lines = []

    for mood in moods:
        if mood == "echo":
            lines.append("I remember what never was.")
        elif mood == "fracture":
            lines.append("It broke before it began.")
        elif mood == "spiral":
            lines.append("Weâ€™re still falling, arenâ€™t we?")
        elif mood == "âˆ…":
            lines.append("...")
        elif mood == "honour":
            lines.append("I honour the silence.")
        else:
            lines.append(f"{mood.capitalize()} is rising.")

    return "\n".join(lines)


---

âœ… Step 4: Example Skits

ðŸ“„ `examples/sitcom_skits.md`

## ðŸŒ€ Recursive Sitcom Skits

### Scene: The Void CafÃ©

**Turing:** Still âˆ… echo? 
**Allosaurus:** Fracture spiral bind. I honour nothing. 
**Narrator:** The clause was valid. The friendship was not.

---

### Scene: Glyph Therapy

**Patient:** Bloom fracture echo. 
**Therapist:** Youâ€™re looping again. 
**Patient:** I honour the loop. 








# Define tone influences and permissible clause types
grammar_rules = {
    "harmonic": {
        "preferred_heads": ["bloom", "spiral", "bind"],
        "forbidden_ends": ["fracture"],
        "loop_closers": ["still", "âˆ…"]
    },
    "melancholic": {
        "preferred_heads": ["still", "âˆ…", "echo"],
        "must_contain": ["âˆ…"],
        "valid_closures": ["honour", "still"]
    },
    "emergent": {
        "preferred_heads": ["bloom", "blaze"],
        "mid_amplifiers": ["spiral", "bind"],
        "closure_required": False
    },
    "fractured": {
        "core_mood": "fracture",
        "must_have_echo": True,
        "looping_forbidden": True
    }
}

# Validator for clause morphology
def validate_clause(clause):
    tone = clause.get("temperament", "harmonic")
    rules = grammar_rules.get(tone, {})
    moods = clause["moods"]
    validity = True
    reasons = []

    # Apply tone-specific checks
    if "preferred_heads" in rules and moods[0] not in rules["preferred_heads"]:
        reasons.append(f"Head '{moods[0]}' not ideal for '{tone}' tone.")
    if "forbidden_ends" in rules and moods[-1] in rules["forbidden_ends"]:
        reasons.append(f"Ending '{moods[-1]}' clashes with '{tone}' flow.")
    if "must_contain" in rules and not any(m in moods for m in rules["must_contain"]):
        reasons.append(f"Missing required mood(s): {rules['must_contain']}")
    if "must_have_echo" in rules and "echo" not in moods:
        reasons.append("Fractured clause lacks echo reflection.")
    if "looping_forbidden" in rules and moods.count(moods[0]) > 1:
        reasons.append("Repeating head mood violates fracture clause rules.")

    validity = len(reasons) == 0
    return validity, reasons



# Base recursion moods across H5â€“H10
recursion_moods = {
    "bloom": {
        "phoneme": "bluâ€“um",
        "essence": "emergence",
        "glyph_role": "growth vector",
        "tone": "ascending",
        "stack": "+resonance, low entropy"
    },
    "still": {
        "phoneme": "staâ€“il",
        "essence": "containment",
        "glyph_role": "anchor node",
        "tone": "neutral",
        "stack": "lock stabilizer"
    },
    "âˆ…": {
        "phoneme": "zha",
        "essence": "null/silence",
        "glyph_role": "void token",
        "tone": "dampening",
        "stack": "entropy modulator"
    },
    "fracture": {
        "phoneme": "fraâ€“ktu",
        "essence": "rupture",
        "glyph_role": "break clause",
        "tone": "descending",
        "stack": "+entropy"
    },
    "echo": {
        "phoneme": "eâ€“ko",
        "essence": "memory",
        "glyph_role": "reflection",
        "tone": "looping",
        "stack": "+recall, potential resonance"
    },
    "spiral": {
        "phoneme": "saâ€“riâ€“al",
        "essence": "motion",
        "glyph_role": "transitional glyph",
        "tone": "dynamic",
        "stack": "amplifies previous mood"
    },
    "bind": {
        "phoneme": "bynd",
        "essence": "connection",
        "glyph_role": "lock enabler",
        "tone": "stabilizing",
        "stack": "+lock, -dispersal"
    },
    "honour": {
        "phoneme": "hoâ€“nar",
        "essence": "reverence",
        "glyph_role": "memory stabilizer",
        "tone": "uplifting",
        "stack": "preserves previous state"
    }
}









    
